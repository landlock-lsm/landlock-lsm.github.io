

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>USB Type-C connector class &mdash; The Linux Kernel 5.10.0-rc1+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="API for USB Type-C Alternate Mode drivers" href="typec_bus.html" />
    <link rel="prev" title="Writing a MUSB Glue Layer" href="writing_musb_glue_layer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux USB API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadget.html">USB Gadget API for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="anchors.html">USB Anchors</a></li>
<li class="toctree-l3"><a class="reference internal" href="bulk-streams.html">USB bulk streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="callbacks.html">USB core callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma.html">USB DMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="URB.html">USB Request Block (URB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="power-management.html">Power Management for USB</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotplug.html">USB hotplugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="persist.html">USB device persistence during system suspend</a></li>
<li class="toctree-l3"><a class="reference internal" href="error-codes.html">USB Error codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_usb_driver.html">Writing USB Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dwc3.html">Synopsys DesignWare Core SuperSpeed USB 3.0 Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_musb_glue_layer.html">Writing a MUSB Glue Layer</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">USB Type-C connector class</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-space-interface">User space interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-api">Driver API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="typec_bus.html">API for USB Type-C Alternate Mode drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb3-debug-port.html">USB3 debug port</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux USB API</a> &raquo;</li>
        
      <li>USB Type-C connector class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/usb/typec.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="usb-type-c-connector-class">
<span id="typec"></span><h1>USB Type-C connector class<a class="headerlink" href="#usb-type-c-connector-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The typec class is meant for describing the USB Type-C ports in a system to the
user space in unified fashion. The class is designed to provide nothing else
except the user space interface implementation in hope that it can be utilized
on as many platforms as possible.</p>
<p>The platforms are expected to register every USB Type-C port they have with the
class. In a normal case the registration will be done by a USB Type-C or PD PHY
driver, but it may be a driver for firmware interface such as UCSI, driver for
USB PD controller or even driver for Thunderbolt3 controller. This document
considers the component registering the USB Type-C ports with the class as “port
driver”.</p>
<p>On top of showing the capabilities, the class also offer user space control over
the roles and alternate modes of ports, partners and cable plugs when the port
driver is capable of supporting those features.</p>
<p>The class provides an API for the port drivers described in this document. The
attributes are described in Documentation/ABI/testing/sysfs-class-typec.</p>
</div>
<div class="section" id="user-space-interface">
<h2>User space interface<a class="headerlink" href="#user-space-interface" title="Permalink to this headline">¶</a></h2>
<p>Every port will be presented as its own device under /sys/class/typec/. The
first port will be named “port0”, the second “port1” and so on.</p>
<p>When connected, the partner will be presented also as its own device under
/sys/class/typec/. The parent of the partner device will always be the port it
is attached to. The partner attached to port “port0” will be named
“port0-partner”. Full path to the device would be
/sys/class/typec/port0/port0-partner/.</p>
<p>The cable and the two plugs on it may also be optionally presented as their own
devices under /sys/class/typec/. The cable attached to the port “port0” port
will be named port0-cable and the plug on the SOP Prime end (see USB Power
Delivery Specification ch. 2.4) will be named “port0-plug0” and on the SOP
Double Prime end “port0-plug1”. The parent of a cable will always be the port,
and the parent of the cable plugs will always be the cable.</p>
<p>If the port, partner or cable plug supports Alternate Modes, every supported
Alternate Mode SVID will have their own device describing them. Note that the
Alternate Mode devices will not be attached to the typec class. The parent of an
alternate mode will be the device that supports it, so for example an alternate
mode of port0-partner will be presented under /sys/class/typec/port0-partner/.
Every mode that is supported will have its own group under the Alternate Mode
device named “mode&lt;index&gt;”, for example /sys/class/typec/port0/&lt;alternate
mode&gt;/mode1/. The requests for entering/exiting a mode can be done with “active”
attribute file in that group.</p>
</div>
<div class="section" id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registering-the-ports">
<h3>Registering the ports<a class="headerlink" href="#registering-the-ports" title="Permalink to this headline">¶</a></h3>
<p>The port drivers will describe every Type-C port they control with struct
typec_capability data structure, and register them with the following API:</p>
<dl class="c function">
<dt id="c.typec_register_port">
<em class="property">struct</em> typec_port *<code class="sig-name descname">typec_register_port</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>parent</em>, <em class="property">const</em> <em class="property">struct</em> typec_capability *<em>cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_port" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a USB Type-C Port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_capability</span> <span class="pre">*cap</span></code></dt><dd><p>Description of the port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Port described in <strong>cap</strong>.</p>
<p>Returns handle to the port on success or ERR_PTR on failure.</p>
<dl class="c function">
<dt id="c.typec_unregister_port">
void <code class="sig-name descname">typec_unregister_port</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_port" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a USB Type-C Port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The port to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_port" title="typec_register_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_port()</span></code></a>.</p>
<p>When registering the ports, the prefer_role member in struct typec_capability
deserves special notice. If the port that is being registered does not have
initial role preference, which means the port does not execute Try.SNK or
Try.SRC by default, the member must have value TYPEC_NO_PREFERRED_ROLE.
Otherwise if the port executes Try.SNK by default, the member must have value
TYPEC_DEVICE, and with Try.SRC the value must be TYPEC_HOST.</p>
</div>
<div class="section" id="registering-partners">
<h3>Registering Partners<a class="headerlink" href="#registering-partners" title="Permalink to this headline">¶</a></h3>
<p>After successful connection of a partner, the port driver needs to register the
partner with the class. Details about the partner need to be described in struct
typec_partner_desc. The class copies the details of the partner during
registration. The class offers the following API for registering/unregistering
partners.</p>
<dl class="c function">
<dt id="c.typec_register_partner">
<em class="property">struct</em> typec_partner *<code class="sig-name descname">typec_register_partner</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">struct</em> typec_partner_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_partner" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a USB Type-C Partner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port the partner is connected to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the partner</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Partner described in <strong>desc</strong>.</p>
<p>Returns handle to the partner on success or ERR_PTR on failure.</p>
<dl class="c function">
<dt id="c.typec_unregister_partner">
void <code class="sig-name descname">typec_unregister_partner</code><span class="sig-paren">(</span><em class="property">struct</em> typec_partner *<em>partner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_partner" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a USB Type-C Partner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*partner</span></code></dt><dd><p>The partner to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_partner" title="typec_register_partner"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_partner()</span></code></a>.</p>
<p>The class will provide a handle to struct typec_partner if the registration was
successful, or NULL.</p>
<p>If the partner is USB Power Delivery capable, and the port driver is able to
show the result of Discover Identity command, the partner descriptor structure
should include handle to struct usb_pd_identity instance. The class will then
create a sysfs directory for the identity under the partner device. The result
of Discover Identity command can then be reported with the following API:</p>
<dl class="c function">
<dt id="c.typec_partner_set_identity">
int <code class="sig-name descname">typec_partner_set_identity</code><span class="sig-paren">(</span><em class="property">struct</em> typec_partner *<em>partner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_partner_set_identity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report result from Discover Identity command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*partner</span></code></dt><dd><p>The partner updated identity values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to report that the result of Discover Identity USB power
delivery command has become available.</p>
</div>
<div class="section" id="registering-cables">
<h3>Registering Cables<a class="headerlink" href="#registering-cables" title="Permalink to this headline">¶</a></h3>
<p>After successful connection of a cable that supports USB Power Delivery
Structured VDM “Discover Identity”, the port driver needs to register the cable
and one or two plugs, depending if there is CC Double Prime controller present
in the cable or not. So a cable capable of SOP Prime communication, but not SOP
Double Prime communication, should only have one plug registered. For more
information about SOP communication, please read chapter about it from the
latest USB Power Delivery specification.</p>
<p>The plugs are represented as their own devices. The cable is registered first,
followed by registration of the cable plugs. The cable will be the parent device
for the plugs. Details about the cable need to be described in struct
typec_cable_desc and about a plug in struct typec_plug_desc. The class copies
the details during registration. The class offers the following API for
registering/unregistering cables and their plugs:</p>
<dl class="c function">
<dt id="c.typec_register_plug">
<em class="property">struct</em> typec_plug *<code class="sig-name descname">typec_register_plug</code><span class="sig-paren">(</span><em class="property">struct</em> typec_cable *<em>cable</em>, <em class="property">struct</em> typec_plug_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_plug" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a USB Type-C Cable Plug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*cable</span></code></dt><dd><p>USB Type-C Cable with the plug</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the cable plug</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Cable Plug described in <strong>desc</strong>. A USB Type-C
Cable Plug represents a plug with electronics in it that can response to USB
Power Delivery SOP Prime or SOP Double Prime packages.</p>
<p>Returns handle to the cable plug on success or ERR_PTR on failure.</p>
<dl class="c function">
<dt id="c.typec_unregister_plug">
void <code class="sig-name descname">typec_unregister_plug</code><span class="sig-paren">(</span><em class="property">struct</em> typec_plug *<em>plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_plug" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a USB Type-C Cable Plug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug</span> <span class="pre">*plug</span></code></dt><dd><p>The cable plug to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_plug" title="typec_register_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_plug()</span></code></a>.</p>
<dl class="c function">
<dt id="c.typec_register_cable">
<em class="property">struct</em> typec_cable *<code class="sig-name descname">typec_register_cable</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">struct</em> typec_cable_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_cable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a USB Type-C Cable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port the cable is connected to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the cable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Cable described in <strong>desc</strong>. The cable will be
parent for the optional cable plug devises.</p>
<p>Returns handle to the cable on success or ERR_PTR on failure.</p>
<dl class="c function">
<dt id="c.typec_unregister_cable">
void <code class="sig-name descname">typec_unregister_cable</code><span class="sig-paren">(</span><em class="property">struct</em> typec_cable *<em>cable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_cable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a USB Type-C Cable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*cable</span></code></dt><dd><p>The cable to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_cable" title="typec_register_cable"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_cable()</span></code></a>.</p>
<p>The class will provide a handle to struct typec_cable and struct typec_plug if
the registration is successful, or NULL if it isn’t.</p>
<p>If the cable is USB Power Delivery capable, and the port driver is able to show
the result of Discover Identity command, the cable descriptor structure should
include handle to struct usb_pd_identity instance. The class will then create a
sysfs directory for the identity under the cable device. The result of Discover
Identity command can then be reported with the following API:</p>
<dl class="c function">
<dt id="c.typec_cable_set_identity">
int <code class="sig-name descname">typec_cable_set_identity</code><span class="sig-paren">(</span><em class="property">struct</em> typec_cable *<em>cable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_cable_set_identity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report result from Discover Identity command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*cable</span></code></dt><dd><p>The cable updated identity values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to report that the result of Discover Identity USB power
delivery command has become available.</p>
</div>
<div class="section" id="notifications">
<h3>Notifications<a class="headerlink" href="#notifications" title="Permalink to this headline">¶</a></h3>
<p>When the partner has executed a role change, or when the default roles change
during connection of a partner or cable, the port driver must use the following
APIs to report it to the class:</p>
<dl class="c function">
<dt id="c.typec_set_data_role">
void <code class="sig-name descname">typec_set_data_role</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">enum</em> typec_data_role <em>role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_data_role" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report data role change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port where the role was changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_data_role</span> <span class="pre">role</span></code></dt><dd><p>The new data role</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report data role changes.</p>
<dl class="c function">
<dt id="c.typec_set_pwr_role">
void <code class="sig-name descname">typec_set_pwr_role</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">enum</em> typec_role <em>role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_pwr_role" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report power role change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port where the role was changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_role</span> <span class="pre">role</span></code></dt><dd><p>The new data role</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report power role changes.</p>
<dl class="c function">
<dt id="c.typec_set_vconn_role">
void <code class="sig-name descname">typec_set_vconn_role</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">enum</em> typec_role <em>role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_vconn_role" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report VCONN source change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port which VCONN role changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_role</span> <span class="pre">role</span></code></dt><dd><p>Source when <strong>port</strong> is sourcing VCONN, or Sink when it’s not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report if the VCONN source is
changes.</p>
<dl class="c function">
<dt id="c.typec_set_pwr_opmode">
void <code class="sig-name descname">typec_set_pwr_opmode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">enum</em> typec_pwr_opmode <em>opmode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_pwr_opmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report changed power operation mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>The USB Type-C Port where the mode was changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_pwr_opmode</span> <span class="pre">opmode</span></code></dt><dd><p>New power operation mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report changed power operation
mode in <strong>port</strong>. The modes are USB (default), 1.5A, 3.0A as defined in USB
Type-C specification, and “USB Power Delivery” when the power levels are
negotiated with methods defined in USB Power Delivery specification.</p>
</div>
<div class="section" id="alternate-modes">
<h3>Alternate Modes<a class="headerlink" href="#alternate-modes" title="Permalink to this headline">¶</a></h3>
<p>USB Type-C ports, partners and cable plugs may support Alternate Modes. Each
Alternate Mode will have identifier called SVID, which is either a Standard ID
given by USB-IF or vendor ID, and each supported SVID can have 1 - 6 modes. The
class provides struct typec_mode_desc for describing individual mode of a SVID,
and struct typec_altmode_desc which is a container for all the supported modes.</p>
<p>Ports that support Alternate Modes need to register each SVID they support with
the following API:</p>
<dl class="c function">
<dt id="c.typec_port_register_altmode">
<em class="property">struct</em> typec_altmode *<code class="sig-name descname">typec_port_register_altmode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">const</em> <em class="property">struct</em> typec_altmode_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_port_register_altmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register USB Type-C Port Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>USB Type-C Port that supports the alternate mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the alternate mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register an alternate mode that <strong>port</strong> is capable of
supporting.</p>
<p>Returns handle to the alternate mode on success or ERR_PTR on failure.</p>
<p>If a partner or cable plug provides a list of SVIDs as response to USB Power
Delivery Structured VDM Discover SVIDs message, each SVID needs to be
registered.</p>
<p>API for the partners:</p>
<dl class="c function">
<dt id="c.typec_partner_register_altmode">
<em class="property">struct</em> typec_altmode *<code class="sig-name descname">typec_partner_register_altmode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_partner *<em>partner</em>, <em class="property">const</em> <em class="property">struct</em> typec_altmode_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_partner_register_altmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register USB Type-C Partner Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*partner</span></code></dt><dd><p>USB Type-C Partner that supports the alternate mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the alternate mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register each alternate mode individually that
<strong>partner</strong> has listed in response to Discover SVIDs command. The modes for a
SVID listed in response to Discover Modes command need to be listed in an
array in <strong>desc</strong>.</p>
<p>Returns handle to the alternate mode on success or ERR_PTR on failure.</p>
<p>API for the Cable Plugs:</p>
<dl class="c function">
<dt id="c.typec_plug_register_altmode">
<em class="property">struct</em> typec_altmode *<code class="sig-name descname">typec_plug_register_altmode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_plug *<em>plug</em>, <em class="property">const</em> <em class="property">struct</em> typec_altmode_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_plug_register_altmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register USB Type-C Cable Plug Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug</span> <span class="pre">*plug</span></code></dt><dd><p>USB Type-C Cable Plug that supports the alternate mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Description of the alternate mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register each alternate mode individually that <strong>plug</strong>
has listed in response to Discover SVIDs command. The modes for a SVID that
the plug lists in response to Discover Modes command need to be listed in an
array in <strong>desc</strong>.</p>
<p>Returns handle to the alternate mode on success or ERR_PTR on failure.</p>
<p>So ports, partners and cable plugs will register the alternate modes with their
own functions, but the registration will always return a handle to struct
typec_altmode on success, or NULL. The unregistration will happen with the same
function:</p>
<dl class="c function">
<dt id="c.typec_unregister_altmode">
void <code class="sig-name descname">typec_unregister_altmode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_altmode *<em>adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_altmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_altmode</span> <span class="pre">*adev</span></code></dt><dd><p>The alternate mode to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_partner_register_altmode" title="typec_partner_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_partner_register_altmode()</span></code></a>,
<a class="reference internal" href="#c.typec_plug_register_altmode" title="typec_plug_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_plug_register_altmode()</span></code></a> or <a class="reference internal" href="#c.typec_port_register_altmode" title="typec_port_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_port_register_altmode()</span></code></a>.</p>
<p>If a partner or cable plug enters or exits a mode, the port driver needs to
notify the class with the following API:</p>
<dl class="c function">
<dt id="c.typec_altmode_update_active">
void <code class="sig-name descname">typec_altmode_update_active</code><span class="sig-paren">(</span><em class="property">struct</em> typec_altmode *<em>adev</em>, bool <em>active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_altmode_update_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Report Enter/Exit mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_altmode</span> <span class="pre">*adev</span></code></dt><dd><p>Handle to the alternate mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">active</span></code></dt><dd><p>True when the mode has been entered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a partner or cable plug executes Enter/Exit Mode command successfully, the
drivers use this routine to report the updated state of the mode.</p>
</div>
<div class="section" id="multiplexer-demultiplexer-switches">
<h3>Multiplexer/DeMultiplexer Switches<a class="headerlink" href="#multiplexer-demultiplexer-switches" title="Permalink to this headline">¶</a></h3>
<p>USB Type-C connectors may have one or more mux/demux switches behind them. Since
the plugs can be inserted right-side-up or upside-down, a switch is needed to
route the correct data pairs from the connector to the USB controllers. If
Alternate or Accessory Modes are supported, another switch is needed that can
route the pins on the connector to some other component besides USB. USB Type-C
Connector Class supplies an API for registering those switches.</p>
<dl class="c function">
<dt id="c.typec_switch_register">
<em class="property">struct</em> typec_switch *<code class="sig-name descname">typec_switch_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>parent</em>, <em class="property">const</em> <em class="property">struct</em> typec_switch_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_switch_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register USB Type-C orientation switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_switch_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Orientation switch description</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a switch that can be used for routing the correct
data pairs depending on the cable plug orientation from the USB Type-C
connector to the USB controllers. USB Type-C plugs can be inserted
right-side-up or upside-down.</p>
<dl class="c function">
<dt id="c.typec_switch_unregister">
void <code class="sig-name descname">typec_switch_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> typec_switch *<em>sw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_switch_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister USB Type-C orientation switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_switch</span> <span class="pre">*sw</span></code></dt><dd><p>USB Type-C orientation switch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister switch that was registered with <a class="reference internal" href="#c.typec_switch_register" title="typec_switch_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_switch_register()</span></code></a>.</p>
<dl class="c function">
<dt id="c.typec_mux_register">
<em class="property">struct</em> typec_mux *<code class="sig-name descname">typec_mux_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>parent</em>, <em class="property">const</em> <em class="property">struct</em> typec_mux_desc *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_mux_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register Multiplexer routing USB Type-C pins</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_mux_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Multiplexer description</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB Type-C connectors can be used for alternate modes of operation besides
USB when Accessory/Alternate Modes are supported. With some of those modes,
the pins on the connector need to be reconfigured. This function registers
multiplexer switches routing the pins on the connector.</p>
<dl class="c function">
<dt id="c.typec_mux_unregister">
void <code class="sig-name descname">typec_mux_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> typec_mux *<em>mux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_mux_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister Multiplexer Switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_mux</span> <span class="pre">*mux</span></code></dt><dd><p>USB Type-C Connector Multiplexer/DeMultiplexer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister mux that was registered with <a class="reference internal" href="#c.typec_mux_register" title="typec_mux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_mux_register()</span></code></a>.</p>
<p>In most cases the same physical mux will handle both the orientation and mode.
However, as the port drivers will be responsible for the orientation, and the
alternate mode drivers for the mode, the two are always separated into their
own logical components: “mux” for the mode and “switch” for the orientation.</p>
<p>When a port is registered, USB Type-C Connector Class requests both the mux and
the switch for the port. The drivers can then use the following API for
controlling them:</p>
<dl class="c function">
<dt id="c.typec_set_orientation">
int <code class="sig-name descname">typec_set_orientation</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, <em class="property">enum</em> typec_orientation <em>orientation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_orientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set USB Type-C cable plug orientation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>USB Type-C Port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_orientation</span> <span class="pre">orientation</span></code></dt><dd><p>USB Type-C cable plug orientation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set cable plug orientation for <strong>port</strong>.</p>
<dl class="c function">
<dt id="c.typec_set_mode">
int <code class="sig-name descname">typec_set_mode</code><span class="sig-paren">(</span><em class="property">struct</em> typec_port *<em>port</em>, int <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set mode of operation for USB Type-C connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*port</span></code></dt><dd><p>USB Type-C connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>Accessory Mode, USB Operation or Safe State</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure <strong>port</strong> for Accessory Mode <strong>mode</strong>. This function will configure the
muxes needed for <strong>mode</strong>.</p>
<p>If the connector is dual-role capable, there may also be a switch for the data
role. USB Type-C Connector Class does not supply separate API for them. The
port drivers can use USB Role Class API with those.</p>
<p>Illustration of the muxes behind a connector that supports an alternate mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>               ------------------------
               |       Connector      |
               ------------------------
                      |         |
               ------------------------
                \     Orientation    /
                 --------------------
                          |
                 --------------------
                /        Mode        \
               ------------------------
                   /              \
------------------------        --------------------
|       Alt Mode       |       /      USB Role      \
------------------------      ------------------------
                                   /            \
               ------------------------      ------------------------
               |       USB Host       |      |       USB Device     |
               ------------------------      ------------------------
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="typec_bus.html" class="btn btn-neutral float-right" title="API for USB Type-C Alternate Mode drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="writing_musb_glue_layer.html" class="btn btn-neutral float-left" title="Writing a MUSB Glue Layer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>