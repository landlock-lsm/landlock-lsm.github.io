

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Voltage and current regulator API &mdash; The Linux Kernel 5.8.0-rc4+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Industrial I/O" href="iio/index.html" />
    <link rel="prev" title="Frame Buffer Library" href="frame-buffer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0-rc4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Voltage and current regulator API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#consumer-driver-interface">Consumer driver interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enabling-and-disabling">Enabling and disabling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#callbacks">Callbacks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#regulator-driver-interface">Regulator driver interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#machine-interface">Machine interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#supplies">Supplies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constraints">Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#api-reference">API reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Voltage and current regulator API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/regulator.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="voltage-and-current-regulator-api">
<h1>Voltage and current regulator API<a class="headerlink" href="#voltage-and-current-regulator-api" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Liam Girdwood</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Mark Brown</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This framework is designed to provide a standard kernel interface to
control voltage and current regulators.</p>
<p>The intention is to allow systems to dynamically control regulator power
output in order to save power and prolong battery life. This applies to
both voltage regulators (where voltage output is controllable) and
current sinks (where current limit is controllable).</p>
<p>Note that additional (and currently more complete) documentation is
available in the Linux kernel source under
<code class="docutils literal notranslate"><span class="pre">Documentation/power/regulator</span></code>.</p>
<div class="section" id="glossary">
<h3>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h3>
<p>The regulator API uses a number of terms which may not be familiar:</p>
<p>Regulator</p>
<blockquote>
<div><p>Electronic device that supplies power to other devices. Most regulators
can enable and disable their output and some can also control their
output voltage or current.</p>
</div></blockquote>
<p>Consumer</p>
<blockquote>
<div><p>Electronic device which consumes power provided by a regulator. These
may either be static, requiring only a fixed supply, or dynamic,
requiring active management of the regulator at runtime.</p>
</div></blockquote>
<p>Power Domain</p>
<blockquote>
<div><p>The electronic circuit supplied by a given regulator, including the
regulator and all consumer devices. The configuration of the regulator
is shared between all the components in the circuit.</p>
</div></blockquote>
<p>Power Management Integrated Circuit (PMIC)</p>
<blockquote>
<div><p>An IC which contains numerous regulators and often also other
subsystems. In an embedded system the primary PMIC is often equivalent
to a combination of the PSU and southbridge in a desktop system.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="consumer-driver-interface">
<h2>Consumer driver interface<a class="headerlink" href="#consumer-driver-interface" title="Permalink to this headline">¶</a></h2>
<p>This offers a similar API to the kernel clock framework. Consumer
drivers use <a class="reference external" href="#API-regulator-get">get</a> and
<a class="reference external" href="#API-regulator-put">put</a> operations to acquire and release
regulators. Functions are provided to <a class="reference external" href="#API-regulator-enable">enable</a>
and <a class="reference external" href="#API-regulator-disable">disable</a> the regulator and to get and
set the runtime parameters of the regulator.</p>
<p>When requesting regulators consumers use symbolic names for their
supplies, such as “Vcc”, which are mapped into actual regulator devices
by the machine interface.</p>
<p>A stub version of this API is provided when the regulator framework is
not in use in order to minimise the need to use ifdefs.</p>
<div class="section" id="enabling-and-disabling">
<h3>Enabling and disabling<a class="headerlink" href="#enabling-and-disabling" title="Permalink to this headline">¶</a></h3>
<p>The regulator API provides reference counted enabling and disabling of
regulators. Consumer devices use the <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> and
<a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> functions to enable and disable
regulators. Calls to the two functions must be balanced.</p>
<p>Note that since multiple consumers may be using a regulator and machine
constraints may not allow the regulator to be disabled there is no
guarantee that calling <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> will actually
cause the supply provided by the regulator to be disabled. Consumer
drivers should assume that the regulator may be enabled at all times.</p>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>Some consumer devices may need to be able to dynamically configure their
supplies. For example, MMC drivers may need to select the correct
operating voltage for their cards. This may be done while the regulator
is enabled or disabled.</p>
<p>The <a class="reference internal" href="#c.regulator_set_voltage" title="regulator_set_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_voltage()</span></code></a> and
<a class="reference internal" href="#c.regulator_set_current_limit" title="regulator_set_current_limit"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_current_limit()</span></code></a> functions provide the primary
interface for this. Both take ranges of voltages and currents, supporting
drivers that do not require a specific value (eg, CPU frequency scaling
normally permits the CPU to use a wider range of supply voltages at lower
frequencies but does not require that the supply voltage be lowered). Where
an exact value is required both minimum and maximum values should be
identical.</p>
</div>
<div class="section" id="callbacks">
<h3>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h3>
<p>Callbacks may also be registered for events such as regulation failures.</p>
</div>
</div>
<div class="section" id="regulator-driver-interface">
<h2>Regulator driver interface<a class="headerlink" href="#regulator-driver-interface" title="Permalink to this headline">¶</a></h2>
<p>Drivers for regulator chips register the regulators with the regulator
core, providing operations structures to the core. A notifier interface
allows error conditions to be reported to the core.</p>
<p>Registration should be triggered by explicit setup done by the platform,
supplying a struct <a class="reference internal" href="#c.regulator_init_data" title="regulator_init_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">regulator_init_data</span></code></a> for the regulator
containing constraint and supply information.</p>
</div>
<div class="section" id="machine-interface">
<h2>Machine interface<a class="headerlink" href="#machine-interface" title="Permalink to this headline">¶</a></h2>
<p>This interface provides a way to define how regulators are connected to
consumers on a given system and what the valid operating parameters are
for the system.</p>
<div class="section" id="supplies">
<h3>Supplies<a class="headerlink" href="#supplies" title="Permalink to this headline">¶</a></h3>
<p>Regulator supplies are specified using struct
<a class="reference internal" href="#c.regulator_consumer_supply" title="regulator_consumer_supply"><code class="xref c c-type docutils literal notranslate"><span class="pre">regulator_consumer_supply</span></code></a>. This is done at driver registration
time as part of the machine constraints.</p>
</div>
<div class="section" id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>As well as defining the connections the machine interface also provides
constraints defining the operations that clients are allowed to perform
and the parameters that may be set. This is required since generally
regulator devices will offer more flexibility than it is safe to use on
a given system, for example supporting higher supply voltages than the
consumers are rated for.</p>
<p>This is done at driver registration time` by providing a
struct <a class="reference internal" href="#c.regulation_constraints" title="regulation_constraints"><code class="xref c c-type docutils literal notranslate"><span class="pre">regulation_constraints</span></code></a>.</p>
<p>The constraints may also specify an initial configuration for the
regulator in the constraints, which is particularly useful for use with
static consumers.</p>
</div>
</div>
<div class="section" id="api-reference">
<h2>API reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>Due to limitations of the kernel documentation framework and the
existing layout of the source code the entire regulator API is
documented here.</p>
<dl class="type">
<dt id="c.pre_voltage_change_data">
struct <code class="sig-name descname">pre_voltage_change_data</code><a class="headerlink" href="#c.pre_voltage_change_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data sent with PRE_VOLTAGE_CHANGE event</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pre_voltage_change_data {
  unsigned long old_uV;
  unsigned long min_uV;
  unsigned long max_uV;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_uV</span></code></dt><dd><p>Current voltage before change.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Min voltage we’ll change to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Max voltage we’ll change to.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.regulator_bulk_data">
struct <code class="sig-name descname">regulator_bulk_data</code><a class="headerlink" href="#c.regulator_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk regulator operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_bulk_data {
  const char *supply;
  struct regulator *consumer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supply</span></code></dt><dd><p>The name of the supply.  Initialised by the user before
using the bulk regulator APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer</span></code></dt><dd><p>The regulator consumer for the supply.  This will be managed
by the bulk API.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The regulator APIs provide a series of regulator_bulk_() API calls as
a convenience to consumers which require multiple supplies.  This
structure is used to manage data for these calls.</p>
<dl class="type">
<dt id="c.regulator_state">
struct <code class="sig-name descname">regulator_state</code><a class="headerlink" href="#c.regulator_state" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator state during low power system states</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_state {
  int uV;
  int min_uV;
  int max_uV;
  unsigned int mode;
  int enabled;
  bool changeable;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uV</span></code></dt><dd><p>Default operating voltage during suspend, it can be adjusted
among &lt;min_uV, max_uV&gt;.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Minimum suspend voltage may be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Maximum suspend voltage may be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Operating mode during suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>operations during suspend.
- DO_NOTHING_IN_SUSPEND
- DISABLE_IN_SUSPEND
- ENABLE_IN_SUSPEND</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">changeable</span></code></dt><dd><p>Is this state can be switched between enabled/disabled,</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This describes a regulators state during a system wide low power
state.  One of enabled or disabled must be set for the
configuration to be applied.</p>
<dl class="type">
<dt id="c.regulation_constraints">
struct <code class="sig-name descname">regulation_constraints</code><a class="headerlink" href="#c.regulation_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator operating constraints.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulation_constraints {
  const char *name;
  int min_uV;
  int max_uV;
  int uV_offset;
  int min_uA;
  int max_uA;
  int ilim_uA;
  int system_load;
  u32 *max_spread;
  int max_uV_step;
  unsigned int valid_modes_mask;
  unsigned int valid_ops_mask;
  int input_uV;
  struct regulator_state state_disk;
  struct regulator_state state_mem;
  struct regulator_state state_standby;
  suspend_state_t initial_state;
  unsigned int initial_mode;
  unsigned int ramp_delay;
  unsigned int settling_time;
  unsigned int settling_time_up;
  unsigned int settling_time_down;
  unsigned int enable_time;
  unsigned int active_discharge;
  unsigned always_on:1;
  unsigned boot_on:1;
  unsigned apply_uV:1;
  unsigned ramp_disable:1;
  unsigned soft_start:1;
  unsigned pull_down:1;
  unsigned over_current_protection:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Descriptive name for the constraints, used for display purposes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Smallest voltage consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Largest voltage consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uV_offset</span></code></dt><dd><p>Offset applied to voltages from consumer to compensate for
voltage drops.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uA</span></code></dt><dd><p>Smallest current consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uA</span></code></dt><dd><p>Largest current consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ilim_uA</span></code></dt><dd><p>Maximum input current.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system_load</span></code></dt><dd><p>Load that isn’t captured by any consumer requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_spread</span></code></dt><dd><p>Max possible spread between coupled regulators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_modes_mask</span></code></dt><dd><p>Mask of modes which may be configured by consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_ops_mask</span></code></dt><dd><p>Operations which may be performed by consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_uV</span></code></dt><dd><p>Input voltage for regulator when supplied by another regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_disk</span></code></dt><dd><p>State for regulator when system is suspended in disk mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_mem</span></code></dt><dd><p>State for regulator when system is suspended in mem mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_standby</span></code></dt><dd><p>State for regulator when system is suspended in standby
mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_state</span></code></dt><dd><p>Suspend state to set by default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_mode</span></code></dt><dd><p>Mode to set at startup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_delay</span></code></dt><dd><p>Time to settle down after voltage change (unit: uV/us)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time</span></code></dt><dd><p>Time to settle down after voltage change when voltage
change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time_up</span></code></dt><dd><p>Time to settle down after voltage increase when voltage
change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time_down</span></code></dt><dd><p>Time to settle down after voltage decrease when
voltage change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Turn-on time of the rails (unit: microseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge</span></code></dt><dd><p>Enable/disable active discharge. The enum
regulator_active_discharge values are used for
initialisation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">always_on</span></code></dt><dd><p>Set if the regulator should never be disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boot_on</span></code></dt><dd><p>Set if the regulator is enabled when the system is initially
started.  If the regulator is not enabled by the hardware or
bootloader then it will be enabled when the constraints are
applied.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_uV</span></code></dt><dd><p>Apply the voltage constraint when initialising.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_disable</span></code></dt><dd><p>Disable ramp delay when initialising or when setting voltage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start</span></code></dt><dd><p>Enable soft start so that voltage ramps slowly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down</span></code></dt><dd><p>Enable pull down when regulator is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_current_protection</span></code></dt><dd><p>Auto disable on over current event.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct describes regulator and board/machine specific constraints.</p>
<dl class="type">
<dt id="c.regulator_consumer_supply">
struct <code class="sig-name descname">regulator_consumer_supply</code><a class="headerlink" href="#c.regulator_consumer_supply" title="Permalink to this definition">¶</a></dt>
<dd><p>supply -&gt; device mapping</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_consumer_supply {
  const char *dev_name;
  const char *supply;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_name</span></code></dt><dd><p>Result of dev_name() for the consumer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supply</span></code></dt><dd><p>Name for the supply.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This maps a supply name to a device. Use of dev_name allows support for
buses which make struct device available late such as I2C.</p>
<dl class="type">
<dt id="c.regulator_init_data">
struct <code class="sig-name descname">regulator_init_data</code><a class="headerlink" href="#c.regulator_init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator platform initialisation data.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_init_data {
  const char *supply_regulator;
  struct regulation_constraints constraints;
  int num_consumer_supplies;
  struct regulator_consumer_supply *consumer_supplies;
  int (*regulator_init)(void *driver_data);
  void *driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supply_regulator</span></code></dt><dd><p>Parent regulator.  Specified using the regulator name
as it appears in the name field in sysfs, which can
be explicitly set using the constraints field ‘name’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">constraints</span></code></dt><dd><p>Constraints.  These must be specified for the regulator to
be usable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_consumer_supplies</span></code></dt><dd><p>Number of consumer device supplies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer_supplies</span></code></dt><dd><p>Consumer device supply configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulator_init</span></code></dt><dd><p>Callback invoked when the regulator has been registered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Data passed to regulator_init.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialisation constraints, our supply and consumers supplies.</p>
<dl class="type">
<dt id="c.regulator_ops">
struct <code class="sig-name descname">regulator_ops</code><a class="headerlink" href="#c.regulator_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_ops {
  int (*list_voltage) (struct regulator_dev *, unsigned selector);
  int (*set_voltage) (struct regulator_dev *, int min_uV, int max_uV, unsigned *selector);
  int (*map_voltage)(struct regulator_dev *, int min_uV, int max_uV);
  int (*set_voltage_sel) (struct regulator_dev *, unsigned selector);
  int (*get_voltage) (struct regulator_dev *);
  int (*get_voltage_sel) (struct regulator_dev *);
  int (*set_current_limit) (struct regulator_dev *, int min_uA, int max_uA);
  int (*get_current_limit) (struct regulator_dev *);
  int (*set_input_current_limit) (struct regulator_dev *, int lim_uA);
  int (*set_over_current_protection) (struct regulator_dev *);
  int (*set_active_discharge) (struct regulator_dev *, bool enable);
  int (*enable) (struct regulator_dev *);
  int (*disable) (struct regulator_dev *);
  int (*is_enabled) (struct regulator_dev *);
  int (*set_mode) (struct regulator_dev *, unsigned int mode);
  unsigned int (*get_mode) (struct regulator_dev *);
  int (*get_error_flags)(struct regulator_dev *, unsigned int *flags);
  int (*enable_time) (struct regulator_dev *);
  int (*set_ramp_delay) (struct regulator_dev *, int ramp_delay);
  int (*set_voltage_time) (struct regulator_dev *, int old_uV, int new_uV);
  int (*set_voltage_time_sel) (struct regulator_dev *,unsigned int old_selector, unsigned int new_selector);
  int (*set_soft_start) (struct regulator_dev *);
  int (*get_status)(struct regulator_dev *);
  unsigned int (*get_optimum_mode) (struct regulator_dev *, int input_uV, int output_uV, int load_uA);
  int (*set_load)(struct regulator_dev *, int load_uA);
  int (*set_bypass)(struct regulator_dev *dev, bool enable);
  int (*get_bypass)(struct regulator_dev *dev, bool *enable);
  int (*set_suspend_voltage) (struct regulator_dev *, int uV);
  int (*set_suspend_enable) (struct regulator_dev *);
  int (*set_suspend_disable) (struct regulator_dev *);
  int (*set_suspend_mode) (struct regulator_dev *, unsigned int mode);
  int (*resume)(struct regulator_dev *rdev);
  int (*set_pull_down) (struct regulator_dev *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list_voltage</span></code></dt><dd><p>Return one of the supported voltages, in microvolts; zero
if the selector indicates a voltage that is unusable on this system;
or negative errno.  Selectors range from zero to one less than
regulator_desc.n_voltages.  Voltages may be reported in any order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage</span></code></dt><dd><p>Set the voltage for the regulator within the range specified.
The driver should select the voltage closest to min_uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_voltage</span></code></dt><dd><p>Convert a voltage into a selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_sel</span></code></dt><dd><p>Set the voltage for the regulator using the specified
selector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_voltage</span></code></dt><dd><p>Return the currently configured voltage for the regulator;
return -ENOTRECOVERABLE if regulator can’t be read at
bootup and hasn’t been set yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_voltage_sel</span></code></dt><dd><p>Return the currently configured voltage selector for the
regulator; return -ENOTRECOVERABLE if regulator can’t
be read at bootup and hasn’t been set yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_current_limit</span></code></dt><dd><p>Configure a limit for a current-limited regulator.
The driver should select the current closest to max_uA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_current_limit</span></code></dt><dd><p>Get the configured limit for a current-limited regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_input_current_limit</span></code></dt><dd><p>Configure an input limit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_over_current_protection</span></code></dt><dd><p>Support capability of automatically shutting
down when detecting an over current event.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_active_discharge</span></code></dt><dd><p>Set active discharge enable/disable of regulators.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Configure the regulator as enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Configure the regulator as disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_enabled</span></code></dt><dd><p>Return 1 if the regulator is enabled, 0 if not.
May also return negative errno.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_mode</span></code></dt><dd><p>Set the configured operating mode for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mode</span></code></dt><dd><p>Get the configured operating mode for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_error_flags</span></code></dt><dd><p>Get the current error(s) for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Time taken for the regulator voltage output voltage to
stabilise after being enabled, in microseconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ramp_delay</span></code></dt><dd><p>Set the ramp delay for the regulator. The driver should
select ramp delay equal to or less than(closest) ramp_delay.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_time</span></code></dt><dd><p>Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage as input, it
should return the worst case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_time_sel</span></code></dt><dd><p>Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage selector as
input, it should return the worst case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_soft_start</span></code></dt><dd><p>Enable soft start for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_status</span></code></dt><dd><p>Return actual (not as-configured) status of regulator, as a
REGULATOR_STATUS value (or negative errno)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_optimum_mode</span></code></dt><dd><p>Get the most efficient operating mode for the regulator
when running with the specified parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_load</span></code></dt><dd><p>Set the load for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_bypass</span></code></dt><dd><p>Set the regulator in bypass mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_bypass</span></code></dt><dd><p>Get the regulator bypass mode state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_voltage</span></code></dt><dd><p>Set the voltage for the regulator when the system
is suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_enable</span></code></dt><dd><p>Mark the regulator as enabled when the system is
suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_disable</span></code></dt><dd><p>Mark the regulator as disabled when the system is
suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_mode</span></code></dt><dd><p>Set the operating mode for the regulator when the
system is suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_pull_down</span></code></dt><dd><p>Configure the regulator to pull down when the regulator
is disabled.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct describes regulator operations which can be implemented by
regulator chip drivers.</p>
<dl class="type">
<dt id="c.regulator_desc">
struct <code class="sig-name descname">regulator_desc</code><a class="headerlink" href="#c.regulator_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Static regulator descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_desc {
  const char *name;
  const char *supply_name;
  const char *of_match;
  const char *regulators_node;
  int (*of_parse_cb)(struct device_node *,const struct regulator_desc *, struct regulator_config *);
  int id;
  unsigned int continuous_voltage_range:1;
  unsigned n_voltages;
  unsigned int n_current_limits;
  const struct regulator_ops *ops;
  int irq;
  enum regulator_type type;
  struct module *owner;
  unsigned int min_uV;
  unsigned int uV_step;
  unsigned int linear_min_sel;
  int fixed_uV;
  unsigned int ramp_delay;
  int min_dropout_uV;
  const struct linear_range *linear_ranges;
  const unsigned int *linear_range_selectors;
  int n_linear_ranges;
  const unsigned int *volt_table;
  const unsigned int *curr_table;
  unsigned int vsel_range_reg;
  unsigned int vsel_range_mask;
  unsigned int vsel_reg;
  unsigned int vsel_mask;
  unsigned int vsel_step;
  unsigned int csel_reg;
  unsigned int csel_mask;
  unsigned int apply_reg;
  unsigned int apply_bit;
  unsigned int enable_reg;
  unsigned int enable_mask;
  unsigned int enable_val;
  unsigned int disable_val;
  bool enable_is_inverted;
  unsigned int bypass_reg;
  unsigned int bypass_mask;
  unsigned int bypass_val_on;
  unsigned int bypass_val_off;
  unsigned int active_discharge_on;
  unsigned int active_discharge_off;
  unsigned int active_discharge_mask;
  unsigned int active_discharge_reg;
  unsigned int soft_start_reg;
  unsigned int soft_start_mask;
  unsigned int soft_start_val_on;
  unsigned int pull_down_reg;
  unsigned int pull_down_mask;
  unsigned int pull_down_val_on;
  unsigned int enable_time;
  unsigned int off_on_delay;
  unsigned int (*of_map_mode)(unsigned int mode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Identifying name for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supply_name</span></code></dt><dd><p>Identifying the regulator supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_match</span></code></dt><dd><p>Name used to identify regulator in DT.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulators_node</span></code></dt><dd><p>Name of node containing regulator definitions in DT.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_parse_cb</span></code></dt><dd><p>Optional callback called only if of_match is present.
Will be called for each regulator parsed from DT, during
init_data parsing.
The regulator_config passed as argument to the callback will
be a copy of config passed to regulator_register, valid only
for this particular call. Callback may freely change the
config but it cannot store it for later usage.
Callback should return 0 on success or negative ERRNO
indicating failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Numerical identifier for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuous_voltage_range</span></code></dt><dd><p>Indicates if the regulator can set any
voltage within constrains range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_voltages</span></code></dt><dd><p>Number of selectors available for ops.list_voltage().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_current_limits</span></code></dt><dd><p>Number of selectors available for current limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Regulator operations table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Interrupt number for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Indicates if the regulator is a voltage or current regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Module providing the regulator, used for refcounting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Voltage given by the lowest selector (if linear mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uV_step</span></code></dt><dd><p>Voltage increase with each selector (if linear mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_min_sel</span></code></dt><dd><p>Minimal selector for starting linear mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fixed_uV</span></code></dt><dd><p>Fixed voltage of rails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_delay</span></code></dt><dd><p>Time to settle down after voltage change (unit: uV/us)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_dropout_uV</span></code></dt><dd><p>The minimum dropout voltage this regulator can handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_ranges</span></code></dt><dd><p>A constant table of possible voltage ranges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_range_selectors</span></code></dt><dd><p>A constant table of voltage range selectors.
If pickable ranges are used each range must
have corresponding selector here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_linear_ranges</span></code></dt><dd><p>Number of entries in the <strong>linear_ranges</strong> (and in
linear_range_selectors if used) table(s).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volt_table</span></code></dt><dd><p>Voltage mapping table (if table based mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">curr_table</span></code></dt><dd><p>Current limit mapping table (if table based mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_range_reg</span></code></dt><dd><p>Register for range selector when using pickable ranges
and <code class="docutils literal notranslate"><span class="pre">regulator_map_*_voltage_*_pickable</span></code> functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_range_mask</span></code></dt><dd><p>Mask for register bitfield used for range selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_reg</span></code></dt><dd><p>Register for selector when using <code class="docutils literal notranslate"><span class="pre">regulator_map_*_voltage_*</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_mask</span></code></dt><dd><p>Mask for register bitfield used for selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_step</span></code></dt><dd><p>Specify the resolution of selector stepping when setting
voltage. If 0, then no stepping is done (requested selector is
set directly), if &gt;0 then the regulator API will ramp the
voltage up/down gradually each time increasing/decreasing the
selector by the specified step value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csel_reg</span></code></dt><dd><p>Register for current limit selector using regmap set_current_limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csel_mask</span></code></dt><dd><p>Mask for register bitfield used for current limit selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_reg</span></code></dt><dd><p>Register for initiate voltage change on the output when
using regulator_set_voltage_sel_regmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_bit</span></code></dt><dd><p>Register bitfield used for initiate voltage change on the
output when using regulator_set_voltage_sel_regmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_reg</span></code></dt><dd><p>Register for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_mask</span></code></dt><dd><p>Mask for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_val</span></code></dt><dd><p>Enabling value for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_val</span></code></dt><dd><p>Disabling value for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_is_inverted</span></code></dt><dd><p>A flag to indicate set enable_mask bits to disable
when using regulator_enable_regmap and friends APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_reg</span></code></dt><dd><p>Register for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_mask</span></code></dt><dd><p>Mask for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_val_on</span></code></dt><dd><p>Enabling value for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_val_off</span></code></dt><dd><p>Disabling value for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_on</span></code></dt><dd><p>Disabling value for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_off</span></code></dt><dd><p>Enabling value for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_mask</span></code></dt><dd><p>Mask for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_reg</span></code></dt><dd><p>Register for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_reg</span></code></dt><dd><p>Register for control when using regmap set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_mask</span></code></dt><dd><p>Mask for control when using regmap set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_val_on</span></code></dt><dd><p>Enabling value for control when using regmap
set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_reg</span></code></dt><dd><p>Register for control when using regmap set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_mask</span></code></dt><dd><p>Mask for control when using regmap set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_val_on</span></code></dt><dd><p>Enabling value for control when using regmap
set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Time taken for initial enable of regulator (in uS).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">off_on_delay</span></code></dt><dd><p>guard time (in uS), before re-enabling a regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_map_mode</span></code></dt><dd><p>Maps a hardware mode defined in a DeviceTree to a standard mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each regulator registered with the core is described with a
structure of this type and a struct regulator_config.  This
structure contains the non-varying parts of the regulator
description.</p>
<dl class="type">
<dt id="c.regulator_config">
struct <code class="sig-name descname">regulator_config</code><a class="headerlink" href="#c.regulator_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic regulator descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_config {
  struct device *dev;
  const struct regulator_init_data *init_data;
  void *driver_data;
  struct device_node *of_node;
  struct regmap *regmap;
  struct gpio_desc *ena_gpiod;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>struct device for the regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_data</span></code></dt><dd><p>platform provided init data, passed through by driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>private regulator data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>OpenFirmware node to parse for device tree bindings (may be
NULL).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regmap</span></code></dt><dd><p>regmap to use for core regmap helpers if dev_get_regmap() is
insufficient.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ena_gpiod</span></code></dt><dd><p>GPIO controlling regulator enable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each regulator registered with the core is described with a
structure of this type and a struct regulator_desc.  This structure
contains the runtime variable parts of the regulator description.</p>
<dl class="function">
<dt id="c.regulator_lock">
void <code class="sig-name descname">regulator_lock</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock a single regulator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called many times by one task on
a single regulator and its mutex will be locked only
once. If a task, which is calling this function is other
than the one, which initially locked the mutex, it will
wait on mutex.</p>
<dl class="function">
<dt id="c.regulator_unlock">
void <code class="sig-name descname">regulator_unlock</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a single regulator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator_source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unlocks the mutex when the
reference counter reaches 0.</p>
<dl class="function">
<dt id="c.regulator_get">
struct regulator * <code class="sig-name descname">regulator_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a regulator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.</p>
<p>Use of supply names configured via regulator_set_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
<dl class="function">
<dt id="c.regulator_get_exclusive">
struct regulator * <code class="sig-name descname">regulator_get_exclusive</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain exclusive access to a regulator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.  Other consumers will be
unable to obtain this regulator while this reference is held and the
use count for the regulator will be initialised to reflect the current
state of the regulator.</p>
<p>This is intended for use by consumers which cannot tolerate shared
use of the regulator such as those which need to force the
regulator off for correct operation of the hardware they are
controlling.</p>
<p>Use of supply names configured via regulator_set_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
<dl class="function">
<dt id="c.regulator_get_optional">
struct regulator * <code class="sig-name descname">regulator_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain optional access to a regulator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.</p>
<p>This is intended for use by consumers for devices which can have
some supplies unconnected in normal use, such as some MMC devices.
It can allow the regulator core to provide stub supplies for other
supplies requested using normal <a class="reference internal" href="#c.regulator_get" title="regulator_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_get()</span></code></a> calls without
disrupting the operation of drivers that can handle absent
supplies.</p>
<p>Use of supply names configured via regulator_set_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
<dl class="function">
<dt id="c.regulator_put">
void <code class="sig-name descname">regulator_put</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the regulator source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all regulator_enable calls made on this
regulator source are balanced by regulator_disable calls prior to calling
this function.</p>
<dl class="function">
<dt id="c.regulator_register_supply_alias">
int <code class="sig-name descname">regulator_register_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> alias_dev</em>, const char *<em> alias_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide device alias for supply lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>Supply name or regulator ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">alias_dev</span></code></dt><dd><p>device that should be used to lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alias_id</span></code></dt><dd><p>Supply name or regulator ID that should be used to lookup the
supply</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All lookups for id on dev will instead be conducted for alias_id on
alias_dev.</p>
<dl class="function">
<dt id="c.regulator_unregister_supply_alias">
void <code class="sig-name descname">regulator_unregister_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove device alias</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>Supply name or regulator ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a lookup alias if one exists for id on dev.</p>
<dl class="function">
<dt id="c.regulator_bulk_register_supply_alias">
int <code class="sig-name descname">regulator_bulk_register_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *const *<em> id</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> alias_dev</em>, const char *const *<em> alias_id</em>, int<em> num_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_register_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>register multiple aliases</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>List of supply names or regulator IDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">alias_dev</span></code></dt><dd><p>device that should be used to lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">alias_id</span></code></dt><dd><p>List of supply names or regulator IDs that should be used to
lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_id</span></code></dt><dd><p>Number of aliases to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to register several supply
aliases in one operation.  If any of the aliases cannot be
registered any aliases that were registered will be removed
before returning to the caller.</p>
<dl class="function">
<dt id="c.regulator_bulk_unregister_supply_alias">
void <code class="sig-name descname">regulator_bulk_unregister_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *const *<em> id</em>, int<em> num_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_unregister_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister multiple aliases</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>List of supply names or regulator IDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_id</span></code></dt><dd><p>Number of aliases to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to unregister several supply
aliases in one operation.</p>
<dl class="function">
<dt id="c.regulator_enable">
int <code class="sig-name descname">regulator_enable</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable regulator output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request that the regulator be enabled with the regulator output at
the predefined voltage or current value.  Calls to <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a>
must be balanced with calls to <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>the output value can be set by other drivers, boot loader or may be
hardwired in the regulator.</p>
<dl class="function">
<dt id="c.regulator_disable">
int <code class="sig-name descname">regulator_disable</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable regulator output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable the regulator output voltage or current.  Calls to
<a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> must be balanced with calls to
<a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.</p>
<dl class="function">
<dt id="c.regulator_force_disable">
int <code class="sig-name descname">regulator_force_disable</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>force disable regulator output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forcibly disable the regulator output voltage or current.</p>
<p><strong>NOTE</strong></p>
<p>this <em>will</em> disable the regulator output even if other consumer
devices have it enabled. This should be used for situations when device
damage will likely occur if the regulator is not disabled (e.g. over temp).</p>
<dl class="function">
<dt id="c.regulator_disable_deferred">
int <code class="sig-name descname">regulator_disable_deferred</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_disable_deferred" title="Permalink to this definition">¶</a></dt>
<dd><p>disable regulator output with delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ms</span></code></dt><dd><p>milliseconds until the regulator is disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Execute <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> on the regulator after a delay.  This
is intended for use with devices that require some time to quiesce.</p>
<p><strong>NOTE</strong></p>
<p>this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.</p>
<dl class="function">
<dt id="c.regulator_is_enabled">
int <code class="sig-name descname">regulator_is_enabled</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>is the regulator output enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns positive if the regulator driver backing the source/client
has requested that the device be enabled, zero if it hasn’t, else a
negative errno code.</p>
<p>Note that the device backing this regulator handle can have multiple
users, so it might be enabled even if <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> was never
called for this particular source.</p>
<dl class="function">
<dt id="c.regulator_count_voltages">
int <code class="sig-name descname">regulator_count_voltages</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_count_voltages" title="Permalink to this definition">¶</a></dt>
<dd><p>count <a class="reference internal" href="#c.regulator_list_voltage" title="regulator_list_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_list_voltage()</span></code></a> selectors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of selectors, or negative errno.  Selectors are
numbered starting at zero, and typically correspond to bitfields
in hardware registers.</p>
<dl class="function">
<dt id="c.regulator_list_voltage">
int <code class="sig-name descname">regulator_list_voltage</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, unsigned<em> selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_list_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerate supported voltages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">selector</span></code></dt><dd><p>identify voltage to list</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Returns a voltage that can be passed to <strong><a class="reference internal" href="#c.regulator_set_voltage" title="regulator_set_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_voltage()</span></code></a></strong>,
zero if this selector code can’t be used on this system, or a
negative errno.</p>
<dl class="function">
<dt id="c.regulator_get_hardware_vsel_register">
int <code class="sig-name descname">regulator_get_hardware_vsel_register</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, unsigned *<em> vsel_reg</em>, unsigned *<em> vsel_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_hardware_vsel_register" title="Permalink to this definition">¶</a></dt>
<dd><p>get the HW voltage selector register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">*</span> <span class="pre">vsel_reg</span></code></dt><dd><p>voltage selector register, output parameter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">*</span> <span class="pre">vsel_mask</span></code></dt><dd><p>mask for voltage selector bitfield, output parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the hardware register offset and bitmask used for setting the
regulator voltage. This might be useful when configuring voltage-scaling
hardware or firmware that can make I2C requests behind the kernel’s back,
for example.</p>
<p>On success, the output parameters <strong>vsel_reg</strong> and <strong>vsel_mask</strong> are filled in
and 0 is returned, otherwise a negative errno is returned.</p>
<dl class="function">
<dt id="c.regulator_list_hardware_vsel">
int <code class="sig-name descname">regulator_list_hardware_vsel</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, unsigned<em> selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_list_hardware_vsel" title="Permalink to this definition">¶</a></dt>
<dd><p>get the HW-specific register value for a selector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">selector</span></code></dt><dd><p>identify voltage to list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the selector to a hardware-specific voltage selector that can be
directly written to the regulator registers. The address of the voltage
register can be determined by calling <strong>regulator_get_hardware_vsel_register</strong>.</p>
<p>On error a negative errno is returned.</p>
<dl class="function">
<dt id="c.regulator_get_linear_step">
unsigned int <code class="sig-name descname">regulator_get_linear_step</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_linear_step" title="Permalink to this definition">¶</a></dt>
<dd><p>return the voltage step size between VSEL values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the voltage step size between VSEL values for linear
regulators, or return 0 if the regulator isn’t a linear regulator.</p>
<dl class="function">
<dt id="c.regulator_is_supported_voltage">
int <code class="sig-name descname">regulator_is_supported_voltage</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> min_uV</em>, int<em> max_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_is_supported_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a voltage range can be supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>Regulator to check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uV</span></code></dt><dd><p>Minimum required voltage in uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uV</span></code></dt><dd><p>Maximum required voltage in uV.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a boolean.</p>
<dl class="function">
<dt id="c.regulator_set_voltage">
int <code class="sig-name descname">regulator_set_voltage</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> min_uV</em>, int<em> max_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator output voltage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uV</span></code></dt><dd><p>Minimum required voltage in uV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uV</span></code></dt><dd><p>Maximum acceptable voltage in uV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets a voltage regulator to the desired output voltage. This can be set
during any regulator state. IOW, regulator can be disabled or enabled.</p>
<p>If the regulator is enabled then the voltage will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new voltage when enabled.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is shared between several devices then the lowest
request voltage that meets the system constraints will be used.
Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
<dl class="function">
<dt id="c.regulator_set_voltage_time">
int <code class="sig-name descname">regulator_set_voltage_time</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> old_uV</em>, int<em> new_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage_time" title="Permalink to this definition">¶</a></dt>
<dd><p>get raise/fall time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old_uV</span></code></dt><dd><p>starting voltage in microvolts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_uV</span></code></dt><dd><p>target voltage in microvolts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provided with the starting and ending voltage, this function attempts to
calculate the time in microseconds required to rise or fall to this new
voltage.</p>
<dl class="function">
<dt id="c.regulator_set_voltage_time_sel">
int <code class="sig-name descname">regulator_set_voltage_time_sel</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em>, unsigned int<em> old_selector</em>, unsigned int<em> new_selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage_time_sel" title="Permalink to this definition">¶</a></dt>
<dd><p>get raise/fall time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator source device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">old_selector</span></code></dt><dd><p>selector for starting voltage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_selector</span></code></dt><dd><p>selector for target voltage</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provided with the starting and target voltage selectors, this function
returns time in microseconds required to rise or fall to this new voltage</p>
<p>Drivers providing ramp_delay in regulation_constraints can use this as their
set_voltage_time_sel() operation.</p>
<dl class="function">
<dt id="c.regulator_sync_voltage">
int <code class="sig-name descname">regulator_sync_voltage</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_sync_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>re-apply last regulator output voltage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Re-apply the last configured voltage.  This is intended to be used
where some external control source the consumer is cooperating with
has caused the configured voltage to change.</p>
<dl class="function">
<dt id="c.regulator_get_voltage">
int <code class="sig-name descname">regulator_get_voltage</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator output voltage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current regulator voltage in uV.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is disabled it will return the voltage value. This
function should not be used to determine regulator state.</p>
<dl class="function">
<dt id="c.regulator_set_current_limit">
int <code class="sig-name descname">regulator_set_current_limit</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> min_uA</em>, int<em> max_uA</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_current_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator output current limit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uA</span></code></dt><dd><p>Minimum supported current in uA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uA</span></code></dt><dd><p>Maximum supported current in uA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current sink to the desired output current. This can be set during
any regulator state. IOW, regulator can be disabled or enabled.</p>
<p>If the regulator is enabled then the current will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new current when enabled.</p>
<p><strong>NOTE</strong></p>
<p>Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
<dl class="function">
<dt id="c.regulator_get_current_limit">
int <code class="sig-name descname">regulator_get_current_limit</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_current_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator output current</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current supplied by the specified current sink in uA.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is disabled it will return the current value. This
function should not be used to determine regulator state.</p>
<dl class="function">
<dt id="c.regulator_set_mode">
int <code class="sig-name descname">regulator_set_mode</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, unsigned int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator operating mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>operating mode - one of the REGULATOR_MODE constants</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set regulator operating mode to increase regulator efficiency or improve
regulation performance.</p>
<p><strong>NOTE</strong></p>
<p>Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
<dl class="function">
<dt id="c.regulator_get_mode">
unsigned int <code class="sig-name descname">regulator_get_mode</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator operating mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the current regulator operating mode.</p>
<dl class="function">
<dt id="c.regulator_get_error_flags">
int <code class="sig-name descname">regulator_get_error_flags</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, unsigned int *<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_error_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator error information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt><dd><p>pointer to store error flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the current regulator error information.</p>
<dl class="function">
<dt id="c.regulator_set_load">
int <code class="sig-name descname">regulator_set_load</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, int<em> uA_load</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_load" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator load</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">uA_load</span></code></dt><dd><p>load current</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notifies the regulator core of a new device load. This is then used by
DRMS (if enabled by constraints) to set the most efficient regulator
operating mode for the new regulator loading.</p>
<p>Consumer devices notify their supply regulator of the maximum power
they will require (can be taken from device datasheet in the power
consumption tables) when they change operational status and hence power
state. Examples of operational state changes that can affect power
consumption are :-</p>
<blockquote>
<div><p>o Device is opened / closed.
o Device I/O is about to begin or has just finished.
o Device is idling in between work.</p>
</div></blockquote>
<p>This information is also exported via sysfs to userspace.</p>
<p>DRMS will sum the total requested load on the regulator and change
to the most efficient operating mode if platform constraints allow.</p>
<p>If a regulator is an always-on regulator then an individual consumer’s
load will still be removed if that consumer is fully disabled.</p>
<p>On error a negative errno is returned.</p>
<p><strong>NOTE</strong></p>
<p>when a regulator consumer requests to have a regulator
disabled then any load that consumer requested no longer counts
toward the total requested load.  If the regulator is re-enabled
then the previously requested load will start counting again.</p>
<dl class="function">
<dt id="c.regulator_allow_bypass">
int <code class="sig-name descname">regulator_allow_bypass</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_allow_bypass" title="Permalink to this definition">¶</a></dt>
<dd><p>allow the regulator to go into bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>Regulator to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>enable or disable bypass mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow the regulator to go into bypass mode if all other consumers
for the regulator also enable bypass mode and the machine
constraints allow this.  Bypass mode means that the regulator is
simply passing the input directly to the output with no regulation.</p>
<dl class="function">
<dt id="c.regulator_register_notifier">
int <code class="sig-name descname">regulator_register_notifier</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register regulator event notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register notifier block to receive regulator events.</p>
<dl class="function">
<dt id="c.regulator_unregister_notifier">
int <code class="sig-name descname">regulator_unregister_notifier</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister regulator event notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister regulator event notifier block.</p>
<dl class="function">
<dt id="c.regulator_bulk_get">
int <code class="sig-name descname">regulator_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a> *<em> consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get multiple regulator consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*</span> <span class="pre">consumers</span></code></dt><dd><p>Configuration of consumers; clients are stored here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several regulator
consumers in one operation.  If any of the regulators cannot be
acquired then any regulators that were allocated will be freed
before returning to the caller.</p>
<dl class="function">
<dt id="c.regulator_bulk_enable">
int <code class="sig-name descname">regulator_bulk_enable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a> *<em> consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable multiple regulator consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*</span> <span class="pre">consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to enable multiple regulator
clients in a single API call.  If any consumers cannot be enabled
then any others that were enabled will be disabled again prior to
return.</p>
<dl class="function">
<dt id="c.regulator_bulk_disable">
int <code class="sig-name descname">regulator_bulk_disable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a> *<em> consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable multiple regulator consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*</span> <span class="pre">consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to disable multiple regulator
clients in a single API call.  If any consumers cannot be disabled
then any others that were disabled will be enabled again prior to
return.</p>
<dl class="function">
<dt id="c.regulator_bulk_force_disable">
int <code class="sig-name descname">regulator_bulk_force_disable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a> *<em> consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>force disable multiple regulator consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*</span> <span class="pre">consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to forcibly disable multiple regulator
clients in a single API call.</p>
<p><strong>NOTE</strong></p>
<p>This should be used for situations when device damage will
likely occur if the regulators are not disabled (e.g. over temp).
Although regulator_force_disable function call for some consumers can
return error numbers, the function is called for all consumers.</p>
<dl class="function">
<dt id="c.regulator_bulk_free">
void <code class="sig-name descname">regulator_bulk_free</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a> *<em> consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free multiple regulator consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*</span> <span class="pre">consumers</span></code></dt><dd><p>Consumer data; clients are stored here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to free multiple regulator
clients in a single API call.</p>
<dl class="function">
<dt id="c.regulator_notifier_call_chain">
int <code class="sig-name descname">regulator_notifier_call_chain</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em>, unsigned long<em> event</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_notifier_call_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>call regulator event notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">event</span></code></dt><dd><p>notifier block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>callback-specific data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to notify clients a regulator event has
occurred. We also notify regulator clients downstream.
Note lock must be held by caller.</p>
<dl class="function">
<dt id="c.regulator_mode_to_status">
int <code class="sig-name descname">regulator_mode_to_status</code><span class="sig-paren">(</span>unsigned int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_mode_to_status" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a regulator mode into a status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>Mode to convert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert a regulator mode into a status.</p>
<dl class="function">
<dt id="c.regulator_register">
struct regulator_dev * <code class="sig-name descname">regulator_register</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.regulator_desc" title="regulator_desc">regulator_desc</a> *<em> regulator_desc</em>, const struct <a class="reference internal" href="#c.regulator_config" title="regulator_config">regulator_config</a> *<em> cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register regulator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">regulator_desc</span> <span class="pre">*</span> <span class="pre">regulator_desc</span></code></dt><dd><p>regulator to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">regulator_config</span> <span class="pre">*</span> <span class="pre">cfg</span></code></dt><dd><p>runtime configuration for regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to register a regulator.
Returns a valid pointer to struct regulator_dev on success
or an ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.regulator_unregister">
void <code class="sig-name descname">regulator_unregister</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister regulator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to unregister a regulator.</p>
<dl class="function">
<dt id="c.regulator_has_full_constraints">
void <code class="sig-name descname">regulator_has_full_constraints</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_has_full_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>the system has fully specified constraints</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the regulator API to disable all
regulators which have a zero use count and don’t have an always_on
constraint in a late_initcall.</p>
<p>The intention is that this will become the default behaviour in a
future kernel release so users are encouraged to use this facility
now.</p>
<dl class="function">
<dt id="c.rdev_get_drvdata">
void * <code class="sig-name descname">rdev_get_drvdata</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdev_get_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>get rdev regulator driver data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get rdev regulator driver private data. This call can be used in the
regulator driver context.</p>
<dl class="function">
<dt id="c.regulator_get_drvdata">
void * <code class="sig-name descname">regulator_get_drvdata</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator driver data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get regulator driver private data. This call can be used in the consumer
driver context when non API regulator specific functions need to be called.</p>
<dl class="function">
<dt id="c.regulator_set_drvdata">
void <code class="sig-name descname">regulator_set_drvdata</code><span class="sig-paren">(</span>struct regulator *<em> regulator</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator driver data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*</span> <span class="pre">regulator</span></code></dt><dd><p>regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rdev_get_id">
int <code class="sig-name descname">rdev_get_id</code><span class="sig-paren">(</span>struct regulator_dev *<em> rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdev_get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*</span> <span class="pre">rdev</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="iio/index.html" class="btn btn-neutral float-right" title="Industrial I/O" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="frame-buffer.html" class="btn btn-neutral float-left" title="Frame Buffer Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>