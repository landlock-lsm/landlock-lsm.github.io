

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>drm/amdgpu AMDgpu driver &mdash; The Linux Kernel 5.2.0+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="drm/amd/display - Display Core (DC)" href="amdgpu-dc.html" />
    <link rel="prev" title="GPU Driver Documentation" href="drivers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.4.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ioctl/index.html">IOCTLs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">drm/amdgpu AMDgpu driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-parameters">Module Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#core-driver-infrastructure">Core Driver Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#amdgpu-xgmi-support">AMDGPU XGMI Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#amdgpu-ras-debugfs-control-interface">AMDGPU RAS debugfs control interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpu-power-thermal-controls-and-monitoring">GPU Power/Thermal Controls and Monitoring</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="amdgpu-dc.html">drm/amd/display - Display Core (DC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcde.html">drm/mcde ST-Ericsson MCDE Multi-channel display engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l3"><a class="reference internal" href="v3d.html">drm/v3d Broadcom V3D Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vkms.html">drm/vkms Virtual Kernel Modesetting</a></li>
<li class="toctree-l3"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="xen-front.html">drm/xen-front Xen para-virtualized frontend driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="afbc.html">Arm Framebuffer Compression (AFBC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="komeda-kms.html">drm/komeda Arm display driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
          <li><a href="drivers.html">GPU Driver Documentation</a> &raquo;</li>
        
      <li>drm/amdgpu AMDgpu driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/amdgpu.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-amdgpu-amdgpu-driver">
<h1>drm/amdgpu AMDgpu driver<a class="headerlink" href="#drm-amdgpu-amdgpu-driver" title="Permalink to this headline">¶</a></h1>
<p>The drm/amdgpu driver supports all AMD Radeon GPUs based on the Graphics Core
Next (GCN) architecture.</p>
<div class="section" id="module-parameters">
<h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<p>The amdgpu driver supports the following module parameters:</p>
<p><strong>vramlimit (int)</strong></p>
<p>Restrict the total amount of VRAM in MiB for testing.  The default is 0 (Use full VRAM).</p>
<p><strong>vis_vramlimit (int)</strong></p>
<p>Restrict the amount of CPU visible VRAM in MiB for testing.  The default is 0 (Use full CPU visible VRAM).</p>
<p><strong>gartsize (uint)</strong></p>
<p>Restrict the size of GART in Mib (32, 64, etc.) for testing. The default is -1 (The size depends on asic).</p>
<p><strong>gttsize (int)</strong></p>
<p>Restrict the size of GTT domain in MiB for testing. The default is -1 (It’s VRAM size if 3GB &lt; VRAM &lt; 3/4 RAM,
otherwise 3/4 RAM size).</p>
<p><strong>moverate (int)</strong></p>
<p>Set maximum buffer migration rate in MB/s. The default is -1 (8 MB/s).</p>
<p><strong>benchmark (int)</strong></p>
<p>Run benchmarks. The default is 0 (Skip benchmarks).</p>
<p><strong>test (int)</strong></p>
<p>Test BO GTT-&gt;VRAM and VRAM-&gt;GTT GPU copies. The default is 0 (Skip test, only set 1 to run test).</p>
<p><strong>audio (int)</strong></p>
<p>Set HDMI/DPAudio. Only affects non-DC display handling. The default is -1 (Enabled), set 0 to disabled it.</p>
<p><strong>disp_priority (int)</strong></p>
<p>Set display Priority (1 = normal, 2 = high). Only affects non-DC display handling. The default is 0 (auto).</p>
<p><strong>hw_i2c (int)</strong></p>
<p>To enable hw i2c engine. Only affects non-DC display handling. The default is 0 (Disabled).</p>
<p><strong>pcie_gen2 (int)</strong></p>
<p>To disable PCIE Gen2/3 mode (0 = disable, 1 = enable). The default is -1 (auto, enabled).</p>
<p><strong>msi (int)</strong></p>
<p>To disable Message Signaled Interrupts (MSI) functionality (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>lockup_timeout (string)</strong></p>
<p>Set GPU scheduler timeout value in ms.</p>
<p>The format can be [Non-Compute] or [GFX,Compute,SDMA,Video]. That is there can be one or
multiple values specified. 0 and negative values are invalidated. They will be adjusted
to default timeout.</p>
<blockquote>
<div><ul class="simple">
<li>With one value specified, the setting will apply to all non-compute jobs.</li>
<li>With multiple values specified, the first one will be for GFX. The second one is for Compute.
And the third and fourth ones are for SDMA and Video.</li>
</ul>
</div></blockquote>
<p>By default(with no lockup_timeout settings), the timeout for all non-compute(GFX, SDMA and Video)
jobs is 10000. And there is no timeout enforced on compute jobs.</p>
<p><strong>dpm (int)</strong></p>
<p>Override for dynamic power management setting
(0 = disable, 1 = enable, 2 = enable sw smu driver for vega20)
The default is -1 (auto).</p>
<p><strong>fw_load_type (int)</strong></p>
<p>Set different firmware loading type for debugging (0 = direct, 1 = SMU, 2 = PSP). The default is -1 (auto).</p>
<p><strong>aspm (int)</strong></p>
<p>To disable ASPM (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>runpm (int)</strong></p>
<p>Override for runtime power management control for dGPUs in PX/HG laptops. The amdgpu driver can dynamically power down
the dGPU on PX/HG laptops when it is idle. The default is -1 (auto enable). Setting the value to 0 disables this functionality.</p>
<p><strong>ip_block_mask (uint)</strong></p>
<p>Override what IP blocks are enabled on the GPU. Each GPU is a collection of IP blocks (gfx, display, video, etc.).
Use this parameter to disable specific blocks. Note that the IP blocks do not have a fixed index. Some asics may not have
some IPs or may include multiple instances of an IP so the ordering various from asic to asic. See the driver output in
the kernel log for the list of IPs on the asic. The default is 0xffffffff (enable all blocks on a device).</p>
<p><strong>bapm (int)</strong></p>
<p>Bidirectional Application Power Management (BAPM) used to dynamically share TDP between CPU and GPU. Set value 0 to disable it.
The default -1 (auto, enabled)</p>
<p><strong>deep_color (int)</strong></p>
<p>Set 1 to enable Deep Color support. Only affects non-DC display handling. The default is 0 (disabled).</p>
<p><strong>vm_size (int)</strong></p>
<p>Override the size of the GPU’s per client virtual address space in GiB.  The default is -1 (automatic for each asic).</p>
<p><strong>vm_fragment_size (int)</strong></p>
<p>Override VM fragment size in bits (4, 5, etc. 4 = 64K, 9 = 2M). The default is -1 (automatic for each asic).</p>
<p><strong>vm_block_size (int)</strong></p>
<p>Override VM page table size in bits (default depending on vm_size and hw setup). The default is -1 (automatic for each asic).</p>
<p><strong>vm_fault_stop (int)</strong></p>
<p>Stop on VM fault for debugging (0 = never, 1 = print first, 2 = always). The default is 0 (No stop).</p>
<p><strong>vm_debug (int)</strong></p>
<p>Debug VM handling (0 = disabled, 1 = enabled). The default is 0 (Disabled).</p>
<p><strong>vm_update_mode (int)</strong></p>
<p>Override VM update mode. VM updated by using CPU (0 = never, 1 = Graphics only, 2 = Compute only, 3 = Both). The default
is -1 (Only in large BAR(LB) systems Compute VM tables will be updated by CPU, otherwise 0, never).</p>
<p><strong>exp_hw_support (int)</strong></p>
<p>Enable experimental hw support (1 = enable). The default is 0 (disabled).</p>
<p><strong>dc (int)</strong></p>
<p>Disable/Enable Display Core driver for debugging (1 = enable, 0 = disable). The default is -1 (automatic for each asic).</p>
<p><strong>sched_jobs (int)</strong></p>
<p>Override the max number of jobs supported in the sw queue. The default is 32.</p>
<p><strong>sched_hw_submission (int)</strong></p>
<p>Override the max number of HW submissions. The default is 2.</p>
<p><strong>ppfeaturemask (uint)</strong></p>
<p>Override power features enabled. See enum PP_FEATURE_MASK in drivers/gpu/drm/amd/include/amd_shared.h.
The default is the current set of stable power features.</p>
<p><strong>pcie_gen_cap (uint)</strong></p>
<p>Override PCIE gen speed capabilities. See the CAIL flags in drivers/gpu/drm/amd/include/amd_pcie.h.
The default is 0 (automatic for each asic).</p>
<p><strong>pcie_lane_cap (uint)</strong></p>
<p>Override PCIE lanes capabilities. See the CAIL flags in drivers/gpu/drm/amd/include/amd_pcie.h.
The default is 0 (automatic for each asic).</p>
<p><strong>cg_mask (uint)</strong></p>
<p>Override Clockgating features enabled on GPU (0 = disable clock gating). See the AMD_CG_SUPPORT flags in
drivers/gpu/drm/amd/include/amd_shared.h. The default is 0xffffffff (all enabled).</p>
<p><strong>pg_mask (uint)</strong></p>
<p>Override Powergating features enabled on GPU (0 = disable power gating). See the AMD_PG_SUPPORT flags in
drivers/gpu/drm/amd/include/amd_shared.h. The default is 0xffffffff (all enabled).</p>
<p><strong>sdma_phase_quantum (uint)</strong></p>
<p>Override SDMA context switch phase quantum (x 1K GPU clock cycles, 0 = no change). The default is 32.</p>
<p><strong>disable_cu (charp)</strong></p>
<p>Set to disable CUs (It’s set like se.sh.cu,…). The default is NULL.</p>
<p><strong>virtual_display (charp)</strong></p>
<p>Set to enable virtual display feature. This feature provides a virtual display hardware on headless boards
or in virtualized environments. It will be set like xxxx:xx:xx.x,x;xxxx:xx:xx.x,x. It’s the pci address of
the device, plus the number of crtcs to expose. E.g., 0000:26:00.0,4 would enable 4 virtual crtcs on the pci
device at 26:00.0. The default is NULL.</p>
<p><strong>ngg (int)</strong></p>
<p>Set to enable Next Generation Graphics (1 = enable). The default is 0 (disabled).</p>
<p><strong>prim_buf_per_se (int)</strong></p>
<p>Override the size of Primitive Buffer per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>pos_buf_per_se (int)</strong></p>
<p>Override the size of Position Buffer per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>cntl_sb_buf_per_se (int)</strong></p>
<p>Override the size of Control Sideband per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>param_buf_per_se (int)</strong></p>
<p>Override the size of Off-Chip Parameter Cache per Shader Engine in Byte.
The default is 0 (depending on gfx).</p>
<p><strong>job_hang_limit (int)</strong></p>
<p>Set how much time allow a job hang and not drop it. The default is 0.</p>
<p><strong>lbpw (int)</strong></p>
<p>Override Load Balancing Per Watt (LBPW) support (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>gpu_recovery (int)</strong></p>
<p>Set to enable GPU recovery mechanism (1 = enable, 0 = disable). The default is -1 (auto, disabled except SRIOV).</p>
<p><strong>emu_mode (int)</strong></p>
<p>Set value 1 to enable emulation mode. This is only needed when running on an emulator. The default is 0 (disabled).</p>
<p><strong>ras_enable (int)</strong></p>
<p>Enable RAS features on the GPU (0 = disable, 1 = enable, -1 = auto (default))</p>
<p><strong>ras_mask (uint)</strong></p>
<p>Mask of RAS features to enable (default 0xffffffff), only valid when ras_enable == 1
See the flags in drivers/gpu/drm/amd/amdgpu/amdgpu_ras.h</p>
<p><strong>si_support (int)</strong></p>
<p>Set SI support driver. This parameter works after set config CONFIG_DRM_AMDGPU_SI. For SI asic, when radeon driver is enabled,
set value 0 to use radeon driver, while set value 1 to use amdgpu driver. The default is using radeon driver when it available,
otherwise using amdgpu driver.</p>
<p><strong>cik_support (int)</strong></p>
<p>Set CIK support driver. This parameter works after set config CONFIG_DRM_AMDGPU_CIK. For CIK asic, when radeon driver is enabled,
set value 0 to use radeon driver, while set value 1 to use amdgpu driver. The default is using radeon driver when it available,
otherwise using amdgpu driver.</p>
<p><strong>smu_memory_pool_size (uint)</strong></p>
<p>It is used to reserve gtt for smu debug usage, setting value 0 to disable it. The actual size is value * 256MiB.
E.g. 0x1 = 256Mbyte, 0x2 = 512Mbyte, 0x4 = 1 Gbyte, 0x8 = 2GByte. The default is 0 (disabled).</p>
<p><strong>async_gfx_ring (int)</strong></p>
<p>It is used to enable gfx rings that could be configured with different prioritites or equal priorities</p>
<p><strong>mcbp (int)</strong></p>
<p>It is used to enable mid command buffer preemption. (0 = disabled (default), 1 = enabled)</p>
<p><strong>discovery (int)</strong></p>
<p>Allow driver to discover hardware IP information from IP Discovery table at the top of VRAM.
(-1 = auto (default), 0 = disabled, 1 = enabled)</p>
<p><strong>mes (int)</strong></p>
<p>Enable Micro Engine Scheduler. This is a new hw scheduling engine for gfx, sdma, and compute.
(0 = disabled (default), 1 = enabled)</p>
<p><strong>sched_policy (int)</strong></p>
<p>Set scheduling policy. Default is HWS(hardware scheduling) with over-subscription.
Setting 1 disables over-subscription. Setting 2 disables HWS and statically
assigns queues to HQDs.</p>
<p><strong>hws_max_conc_proc (int)</strong></p>
<p>Maximum number of processes that HWS can schedule concurrently. The maximum is the
number of VMIDs assigned to the HWS, which is also the default.</p>
<p><strong>cwsr_enable (int)</strong></p>
<p>CWSR(compute wave store and resume) allows the GPU to preempt shader execution in
the middle of a compute wave. Default is 1 to enable this feature. Setting 0
disables it.</p>
<p><strong>max_num_of_queues_per_device (int)</strong></p>
<p>Maximum number of queues per device. Valid setting is between 1 and 4096. Default
is 4096.</p>
<p><strong>send_sigterm (int)</strong></p>
<p>Send sigterm to HSA process on unhandled exceptions. Default is not to send sigterm
but just print errors on dmesg. Setting 1 enables sending sigterm.</p>
<p><strong>debug_largebar (int)</strong></p>
<p>Set debug_largebar as 1 to enable simulating large-bar capability on non-large bar
system. This limits the VRAM size reported to ROCm applications to the visible
size, usually 256MB.
Default value is 0, diabled.</p>
<p><strong>ignore_crat (int)</strong></p>
<p>Ignore CRAT table during KFD initialization. By default, KFD uses the ACPI CRAT
table to get information about AMD APUs. This option can serve as a workaround on
systems with a broken CRAT table.</p>
<p><strong>halt_if_hws_hang (int)</strong></p>
<p>Halt if HWS hang is detected. Default value, 0, disables the halt on hang.
Setting 1 enables halt on hang.</p>
<p><strong>hws_gws_support(bool)</strong></p>
<p>Whether HWS support gws barriers. Default value: false (not supported)
This will be replaced with a MEC firmware version check once firmware
is ready</p>
<p><strong>queue_preemption_timeout_ms (int)</strong></p>
<p>queue preemption timeout in ms (1 = Minimum, 9000 = default)</p>
<p><strong>dcfeaturemask (uint)</strong></p>
<p>Override display features enabled. See enum DC_FEATURE_MASK in drivers/gpu/drm/amd/include/amd_shared.h.
The default is the current set of stable display features.</p>
<p><strong>abmlevel (uint)</strong></p>
<p>Override the default ABM (Adaptive Backlight Management) level used for DC
enabled hardware. Requires DMCU to be supported and loaded.
Valid levels are 0-4. A value of 0 indicates that ABM should be disabled by
default. Values 1-4 control the maximum allowable brightness reduction via
the ABM algorithm, with 1 being the least reduction and 4 being the most
reduction.</p>
<p>Defaults to 0, or disabled. Userspace can still override this level later
after boot.</p>
</div>
<div class="section" id="core-driver-infrastructure">
<h2>Core Driver Infrastructure<a class="headerlink" href="#core-driver-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>This section covers core driver infrastructure.</p>
<div class="section" id="memory-domains">
<span id="amdgpu-memory-domains"></span><h3>Memory Domains<a class="headerlink" href="#memory-domains" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_CPU</span></code>       System memory that is not GPU accessible.
Memory in this pool could be swapped out to disk if there is pressure.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GTT</span></code>       GPU accessible system memory, mapped into the
GPU’s virtual address space via gart. Gart memory linearizes non-contiguous
pages of system memory, allows GPU access system memory in a linezrized
fashion.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_VRAM</span></code>      Local video memory. For APUs, it is memory
carved out by the BIOS.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GDS</span></code>       Global on-chip data storage used to share data
across shader threads.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GWS</span></code>       Global wave sync, used to synchronize the
execution of all the waves on a device.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_OA</span></code>        Ordered append, used by 3D or Compute engines
for appending data.</p>
</div>
<div class="section" id="buffer-objects">
<h3>Buffer Objects<a class="headerlink" href="#buffer-objects" title="Permalink to this headline">¶</a></h3>
<p>This defines the interfaces to operate on an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object which
represents memory used by driver (VRAM, system memory, etc.). The driver
provides DRM/GEM APIs to userspace. DRM/GEM APIs then use these interfaces
to create/destroy/set buffer object which are then managed by the kernel TTM
memory manager.
The interfaces are also used internally by kernel clients, including gfx,
uvd, etc. for kernel managed allocations used by the GPU.</p>
<dl class="function">
<dt id="c.amdgpu_bo_subtract_pin_size">
void <code class="descname">amdgpu_bo_subtract_pin_size</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_subtract_pin_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove BO from pin_size accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when a BO stops being pinned, and updates the
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_device</span></code> pin_size values accordingly.</p>
<dl class="function">
<dt id="c.amdgpu_bo_is_amdgpu_bo">
bool <code class="descname">amdgpu_bo_is_amdgpu_bo</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_is_amdgpu_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the buffer object is an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>buffer object to be checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses destroy function associated with the object to determine if this is
an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code>.</p>
<p><strong>Return</strong></p>
<p>true if the object belongs to <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code>, false if not.</p>
<dl class="function">
<dt id="c.amdgpu_bo_placement_from_domain">
void <code class="descname">amdgpu_bo_placement_from_domain</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;abo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_placement_from_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>set buffer’s placement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">abo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object whose placement is to be set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>requested domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer’s placement according to requested domain and the buffer’s
flags.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_reserved">
int <code class="descname">amdgpu_bo_create_reserved</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>create reserved BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use, and returns it still
reserved.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_kernel">
int <code class="descname">amdgpu_bo_create_kernel</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>create BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_free_kernel">
void <code class="descname">amdgpu_bo_free_kernel</code><span class="sig-paren">(</span>struct amdgpu_bo **<em>&nbsp;bo</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_free_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>free BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu BO to free</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>pointer to where the BO’s GPU memory space address was stored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>pointer to where the BO’s CPU memory space address was stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>unmaps and unpin a BO for kernel internal use.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create">
int <code class="descname">amdgpu_bo_create</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_param *<em>&nbsp;bp</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*</span> <span class="pre">bp</span></code></dt>
<dd>parameters to be used for the buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object; and if requested, also creates a
shadow object.
Shadow object is used to backup the original buffer object, and is always
in GTT.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_validate">
int <code class="descname">amdgpu_bo_validate</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to the buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets placement according to domain; and changes placement and caching
policy of the buffer object according to the placement.
This is used for validating shadow bos.  It calls ttm_bo_validate() to
make sure the buffer is resident where it needs to be.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_restore_shadow">
int <code class="descname">amdgpu_bo_restore_shadow</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;shadow</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_restore_shadow" title="Permalink to this definition">¶</a></dt>
<dd><p>restore an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> shadow</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">shadow</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> shadow to be restored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>dma_fence associated with the operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a buffer object’s shadow content back to the object.
This is used for recovering a buffer from its shadow in case of a gpu
reset where vram context may be lost.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kmap">
int <code class="descname">amdgpu_bo_kmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void **<em>&nbsp;ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be mapped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">ptr</span></code></dt>
<dd>kernel virtual address to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls ttm_bo_kmap() to set up the kernel virtual mapping; calls
<a class="reference internal" href="#c.amdgpu_bo_kptr" title="amdgpu_bo_kptr"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_kptr()</span></code></a> to get the kernel virtual address.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kptr">
void * <code class="descname">amdgpu_bo_kptr</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kptr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a kernel virtual address of the buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls ttm_kmap_obj_virtual() to get the kernel virtual address</p>
<p><strong>Return</strong></p>
<p>the virtual address of a buffer object area.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kunmap">
void <code class="descname">amdgpu_bo_kunmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be unmapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmaps a kernel map set up by <a class="reference internal" href="#c.amdgpu_bo_kmap" title="amdgpu_bo_kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_kmap()</span></code></a>.</p>
<dl class="function">
<dt id="c.amdgpu_bo_ref">
struct amdgpu_bo * <code class="descname">amdgpu_bo_ref</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>reference an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>References the contained <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code>.</p>
<p><strong>Return</strong></p>
<p>a refcounted pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unref">
void <code class="descname">amdgpu_bo_unref</code><span class="sig-paren">(</span>struct amdgpu_bo **<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unreferences the contained <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code> and clear the pointer</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin_restricted">
int <code class="descname">amdgpu_bo_pin_restricted</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u32<em>&nbsp;domain</em>, u64<em>&nbsp;min_offset</em>, u64<em>&nbsp;max_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin_restricted" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">min_offset</span></code></dt>
<dd>the start of requested address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">max_offset</span></code></dt>
<dd>the end of requested address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pins the buffer object according to requested domain and address range. If
the memory is unbound gart memory, binds the pages into gart table. Adjusts
pin_count and pin_size accordingly.</p>
<p>Pinning means to lock pages in memory along with keeping them at a fixed
offset. It is required when a buffer can not be moved, for example, when
a display buffer is being scanned out.</p>
<p>Compared with <a class="reference internal" href="#c.amdgpu_bo_pin" title="amdgpu_bo_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_pin()</span></code></a>, this function gives more flexibility on
where to pin a buffer if there are specific restrictions on where a buffer
must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin">
int <code class="descname">amdgpu_bo_pin</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simple wrapper to <a class="reference internal" href="#c.amdgpu_bo_pin_restricted" title="amdgpu_bo_pin_restricted"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_pin_restricted()</span></code></a>.
Provides a simpler API for buffers that do not have any strict restrictions
on where a buffer must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unpin">
int <code class="descname">amdgpu_bo_unpin</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p>unpin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be unpinned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decreases the pin_count, and clears the flags if pin_count reaches 0.
Changes placement and pin size accordingly.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_evict_vram">
int <code class="descname">amdgpu_bo_evict_vram</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_evict_vram" title="Permalink to this definition">¶</a></dt>
<dd><p>evict VRAM buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Evicts all VRAM buffers on the lru list of the memory type.
Mainly used for evicting vram at suspend time.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_init">
int <code class="descname">amdgpu_bo_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls amdgpu_ttm_init() to initialize amdgpu memory manager.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_late_init">
int <code class="descname">amdgpu_bo_late_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_late_init" title="Permalink to this definition">¶</a></dt>
<dd><p>late init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls amdgpu_ttm_late_init() to free resources used earlier during
initialization.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fini">
void <code class="descname">amdgpu_bo_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses <a class="reference internal" href="#c.amdgpu_bo_init" title="amdgpu_bo_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_init()</span></code></a> to tear down memory manager.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fbdev_mmap">
int <code class="descname">amdgpu_bo_fbdev_mmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fbdev_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap fbdev memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma as input from the fbdev mmap method</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls ttm_fbdev_mmap() to mmap fbdev memory if it is backed by a bo.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_tiling_flags">
int <code class="descname">amdgpu_bo_set_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u64<em>&nbsp;tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>set tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tiling_flags</span></code></dt>
<dd>new flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object’s tiling flags with the new one. Used by GEM ioctl or
kernel driver to set the tiling flags on a buffer.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_tiling_flags">
void <code class="descname">amdgpu_bo_get_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u64 *<em>&nbsp;tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">tiling_flags</span></code></dt>
<dd>returned flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object’s tiling flags. Used by GEM ioctl or kernel driver to
set the tiling flags on a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_metadata">
int <code class="descname">amdgpu_bo_set_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void *<em>&nbsp;metadata</em>, uint32_t<em>&nbsp;metadata_size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>set metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">metadata</span></code></dt>
<dd>new metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">metadata_size</span></code></dt>
<dd>size of the new metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags of the new metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object’s metadata, its size and flags.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_metadata">
int <code class="descname">amdgpu_bo_get_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;buffer_size</em>, uint32_t *<em>&nbsp;metadata_size</em>, uint64_t *<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>get metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>returned metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buffer_size</span></code></dt>
<dd>size of the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">metadata_size</span></code></dt>
<dd>size of the returned metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt>
<dd>flags of the returned metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object’s metadata, its size and flags. buffer_size shall not be
less than metadata_size.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_move_notify">
void <code class="descname">amdgpu_bo_move_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em>, bool<em>&nbsp;evict</em>, struct ttm_mem_reg *<em>&nbsp;new_mem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_move_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory move</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to a buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evict</span></code></dt>
<dd>if this move is evicting the buffer from the graphics address space</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_mem_reg</span> <span class="pre">*</span> <span class="pre">new_mem</span></code></dt>
<dd>new information of the bufer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the corresponding <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object as invalid, also performs
bookkeeping.
TTM driver callback which is called when ttm moves a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_release_notify">
void <code class="descname">amdgpu_bo_release_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_release_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a BO being released</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to a buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wipes VRAM buffers whose contents should not be leaked before the
memory is released.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fault_reserve_notify">
int <code class="descname">amdgpu_bo_fault_reserve_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fault_reserve_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to a buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notifies the driver we are taking a fault on this BO and have reserved it,
also performs bookkeeping.
TTM driver callback for dealing with vm faults.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fence">
void <code class="descname">amdgpu_bo_fence</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, bool<em>&nbsp;shared</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>add fence to buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>buffer object in question</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">shared</span></code></dt>
<dd>true if fence should be added shared</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_bo_sync_wait">
int <code class="descname">amdgpu_bo_sync_wait</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void *<em>&nbsp;owner</em>, bool<em>&nbsp;intr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_sync_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for BO reservation fences</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>fence owner</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>Whether the wait is interruptible</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_gpu_offset">
u64 <code class="descname">amdgpu_bo_gpu_offset</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_gpu_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>return GPU offset of bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu object for which we query the offset</dd>
</dl>
<p><strong>Note</strong></p>
<p>object should either be pinned or reserved when calling this
function, it might be useful to add check for this for debugging.</p>
<p><strong>Return</strong></p>
<p>current GPU offset of the object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_preferred_pin_domain">
uint32_t <code class="descname">amdgpu_bo_get_preferred_pin_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, uint32_t<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_preferred_pin_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>get preferred domain for scanout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">domain</span></code></dt>
<dd>allowed <a class="reference internal" href="#amdgpu-memory-domains"><span class="std std-ref">memory domains</span></a></dd>
</dl>
<p><strong>Return</strong></p>
<p>Which of the allowed domains is preferred for pinning the BO for scanout.</p>
</div>
<div class="section" id="prime-buffer-sharing">
<h3>PRIME Buffer Sharing<a class="headerlink" href="#prime-buffer-sharing" title="Permalink to this headline">¶</a></h3>
<p>The following callback implementations are used for <a class="reference internal" href="drm-mm.html#prime-buffer-sharing"><span class="std std-ref">sharing GEM buffer
objects between different devices via PRIME</span></a>.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_get_sg_table">
struct sg_table * <code class="descname">amdgpu_gem_prime_get_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_get_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_get_sg_table</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object (BO)</dd>
</dl>
<p><strong>Return</strong></p>
<p>A scatter/gather table for the pinned pages of the BO’s memory.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_vmap">
void * <code class="descname">amdgpu_gem_prime_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_vmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM BO</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up an in-kernel virtual mapping of the BO’s memory.</p>
<p><strong>Return</strong></p>
<p>The virtual address of the mapping or an error pointer.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_vunmap">
void <code class="descname">amdgpu_gem_prime_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vunmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>Virtual address (unused)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down the in-kernel virtual mapping of the BO’s memory.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_mmap">
int <code class="descname">amdgpu_gem_prime_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_mmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>Virtual memory area</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a userspace mapping of the BO’s memory in the given
virtual memory area.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_map_attach">
int <code class="descname">amdgpu_dma_buf_map_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_map_attach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.attach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes sure that the shared DMA buffer can be accessed by the target device.
For now, simply pins it to the GTT domain, where it should be accessible by
all DMA devices.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_map_detach">
void <code class="descname">amdgpu_dma_buf_map_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_map_detach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.detach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called when a shared DMA buffer no longer needs to be accessible by
another device. For now, simply unpins the buffer from GTT.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_begin_cpu_access">
int <code class="descname">amdgpu_dma_buf_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.begin_cpu_access</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>Direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called before CPU access to the shared DMA buffer’s memory. If it’s
a read access, the buffer is moved to the GTT domain if possible, for optimal
CPU read performance.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_export">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">amdgpu_gem_prime_export</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;gobj</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_export" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_export</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>GEM BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags such as DRM_CLOEXEC and DRM_RDWR.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main work is done by the <a class="reference internal" href="drm-mm.html#c.drm_gem_prime_export" title="drm_gem_prime_export"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_prime_export</span></code></a> helper.</p>
<p><strong>Return</strong></p>
<p>Shared DMA buffer representing the GEM BO from the given device.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_import_sg_table">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_gem_prime_import_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, struct sg_table *<em>&nbsp;sg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_import_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>Scatter/gather table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Imports shared DMA buffer memory exported by another device.</p>
<p><strong>Return</strong></p>
<p>A new GEM BO of the given DRM device, representing the memory
described by the given DMA-buf attachment and scatter/gather table.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_import">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_gem_prime_import</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_import" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main work is done by the <a class="reference internal" href="drm-mm.html#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_prime_import</span></code></a> helper, which in turn
uses <a class="reference internal" href="#c.amdgpu_gem_prime_import_sg_table" title="amdgpu_gem_prime_import_sg_table"><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_gem_prime_import_sg_table</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>GEM BO representing the shared DMA buffer for the given device.</p>
</div>
<div class="section" id="mmu-notifier">
<h3>MMU Notifier<a class="headerlink" href="#mmu-notifier" title="Permalink to this headline">¶</a></h3>
<p>For coherent userptr handling registers an MMU notifier to inform the driver
about updates on the page tables of a process.</p>
<p>When somebody tries to invalidate the page tables we block the update until
all operations on the pages in question are completed, then those pages are
marked as accessed and also dirty if it wasn’t a read only access.</p>
<p>New command submissions using the userptrs in question are delayed until all
page table invalidation are completed and we once more see a coherent process
address space.</p>
<dl class="type">
<dt id="c.amdgpu_mn_node">
struct <code class="descname">amdgpu_mn_node</code><a class="headerlink" href="#c.amdgpu_mn_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_mn_node {
  struct interval_tree_node       it;
  struct list_head                bos;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">it</span></code></dt>
<dd>interval node defining start-last of the affected address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bos</span></code></dt>
<dd>list of all BOs in the affected address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manages all BOs which are affected of a certain range of address space.</p>
<dl class="function">
<dt id="c.amdgpu_mn_destroy">
void <code class="descname">amdgpu_mn_destroy</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy the HMM mirror</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>previously sheduled work item</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lazy destroys the notifier from a work item</p>
<dl class="function">
<dt id="c.amdgpu_hmm_mirror_release">
void <code class="descname">amdgpu_hmm_mirror_release</code><span class="sig-paren">(</span>struct hmm_mirror *<em>&nbsp;mirror</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_hmm_mirror_release" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm destruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hmm_mirror</span> <span class="pre">*</span> <span class="pre">mirror</span></code></dt>
<dd>the HMM mirror (mm) this callback is about</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shedule a work item to lazy destroy HMM mirror.</p>
<dl class="function">
<dt id="c.amdgpu_mn_lock">
void <code class="descname">amdgpu_mn_lock</code><span class="sig-paren">(</span>struct amdgpu_mn *<em>&nbsp;mn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>take the write side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_unlock">
void <code class="descname">amdgpu_mn_unlock</code><span class="sig-paren">(</span>struct amdgpu_mn *<em>&nbsp;mn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the write side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_read_lock">
int <code class="descname">amdgpu_mn_read_lock</code><span class="sig-paren">(</span>struct amdgpu_mn *<em>&nbsp;amn</em>, bool<em>&nbsp;blockable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>take the read side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">amn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">blockable</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_read_unlock">
void <code class="descname">amdgpu_mn_read_unlock</code><span class="sig-paren">(</span>struct amdgpu_mn *<em>&nbsp;amn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the read side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">amn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_node">
void <code class="descname">amdgpu_mn_invalidate_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn_node" title="amdgpu_mn_node">amdgpu_mn_node</a> *<em>&nbsp;node</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_node" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap all BOs of a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_mn_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>the node with the BOs to unmap</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start of address range affected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>end of address range affected</dd>
</dl>
<p><strong>Description</strong></p>
<p>Block for operations on BOs to finish and mark pages as accessed and
potentially dirty.</p>
<dl class="function">
<dt id="c.amdgpu_mn_sync_pagetables_gfx">
int <code class="descname">amdgpu_mn_sync_pagetables_gfx</code><span class="sig-paren">(</span>struct hmm_mirror *<em>&nbsp;mirror</em>, const struct mmu_notifier_range *<em>&nbsp;update</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_sync_pagetables_gfx" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hmm_mirror</span> <span class="pre">*</span> <span class="pre">mirror</span></code></dt>
<dd>the hmm_mirror (mm) is about to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_notifier_range</span> <span class="pre">*</span> <span class="pre">update</span></code></dt>
<dd>the update start, end address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Block for operations on BOs to finish and mark pages as accessed and
potentially dirty.</p>
<dl class="function">
<dt id="c.amdgpu_mn_sync_pagetables_hsa">
int <code class="descname">amdgpu_mn_sync_pagetables_hsa</code><span class="sig-paren">(</span>struct hmm_mirror *<em>&nbsp;mirror</em>, const struct mmu_notifier_range *<em>&nbsp;update</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_sync_pagetables_hsa" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hmm_mirror</span> <span class="pre">*</span> <span class="pre">mirror</span></code></dt>
<dd>the hmm_mirror (mm) is about to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_notifier_range</span> <span class="pre">*</span> <span class="pre">update</span></code></dt>
<dd>the update start, end address</dd>
</dl>
<p><strong>Description</strong></p>
<p>We temporarily evict all BOs between start and end. This
necessitates evicting all user-mode queues of the process. The BOs
are restorted in amdgpu_mn_invalidate_range_end_hsa.</p>
<dl class="function">
<dt id="c.amdgpu_mn_get">
struct amdgpu_mn * <code class="descname">amdgpu_mn_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, enum amdgpu_mn_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_get" title="Permalink to this definition">¶</a></dt>
<dd><p>create HMM mirror context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">amdgpu_mn_type</span> <span class="pre">type</span></code></dt>
<dd>type of MMU notifier context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a HMM mirror context for current-&gt;mm.</p>
<dl class="function">
<dt id="c.amdgpu_mn_register">
int <code class="descname">amdgpu_mn_register</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, unsigned long<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a BO for notifier updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>userptr addr we should monitor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers an HMM mirror for the given BO at the specified address.
Returns 0 on success, -ERRNO if anything goes wrong.</p>
<dl class="function">
<dt id="c.amdgpu_mn_unregister">
void <code class="descname">amdgpu_mn_unregister</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a BO for HMM mirror updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove any registration of HMM mirror updates from the buffer object.</p>
</div>
<div class="section" id="amdgpu-virtual-memory">
<h3>AMDGPU Virtual Memory<a class="headerlink" href="#amdgpu-virtual-memory" title="Permalink to this headline">¶</a></h3>
<p>GPUVM is similar to the legacy gart on older asics, however
rather than there being a single global gart table
for the entire GPU, there are multiple VM page tables active
at any given time.  The VM page tables can contain a mix
vram pages and system memory pages and system memory pages
can be mapped as snooped (cached system pages) or unsnooped
(uncached system pages).
Each VM has an ID associated with it and there is a page table
associated with each VMID.  When execting a command buffer,
the kernel tells the the ring what VMID to use for that command
buffer.  VMIDs are allocated dynamically as commands are submitted.
The userspace drivers maintain their own address space and the kernel
sets up their pages tables accordingly when they submit their
command buffers and a VMID is assigned.
Cayman/Trinity support up to 8 active VMs at any given time;
SI supports 16.</p>
<dl class="type">
<dt id="c.amdgpu_prt_cb">
struct <code class="descname">amdgpu_prt_cb</code><a class="headerlink" href="#c.amdgpu_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to disable partial resident texture feature from a fence callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_prt_cb {
  struct amdgpu_device *adev;
  struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt>
<dd>amdgpu device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt>
<dd>callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_level_shift">
unsigned <code class="descname">amdgpu_vm_level_shift</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_level_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>return the addr shift for each level</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits the pfn needs to be right shifted for a level.</p>
<dl class="function">
<dt id="c.amdgpu_vm_num_entries">
unsigned <code class="descname">amdgpu_vm_num_entries</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_num_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of entries in a PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in a page directory or page table.</p>
<dl class="function">
<dt id="c.amdgpu_vm_num_ats_entries">
unsigned <code class="descname">amdgpu_vm_num_ats_entries</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_num_ats_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of ATS entries in the root PD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in the root page directory which needs the ATS setting.</p>
<dl class="function">
<dt id="c.amdgpu_vm_entries_mask">
uint32_t <code class="descname">amdgpu_vm_entries_mask</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned int<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_entries_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>the mask to get the entry number of a PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The mask to extract the entry number of a PD/PT from an address.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_size">
unsigned <code class="descname">amdgpu_vm_bo_size</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the BOs in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The size of the BO for a page directory or page table in bytes.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_evicted">
void <code class="descname">amdgpu_vm_bo_evicted</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_evicted" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is evicted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is evicted</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs and per VM BOs which are not at the location they should
be.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_relocated">
void <code class="descname">amdgpu_vm_bo_relocated</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_relocated" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is reloacted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is relocated</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs which needs to update their parent PD.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_moved">
void <code class="descname">amdgpu_vm_bo_moved</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_moved" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is moved</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is moved</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for per VM BOs which are moved, but that change is not yet reflected
in the page tables.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_idle">
void <code class="descname">amdgpu_vm_bo_idle</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is now idle</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs and per VM BOs which have gone through the state machine
and are now idle.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_invalidated">
void <code class="descname">amdgpu_vm_bo_invalidated</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is invalidated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is now invalidated</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for normal BOs which are invalidated and that change not yet reflected
in the PTs.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_done">
void <code class="descname">amdgpu_vm_bo_done</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_done" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">vm_bo</span></code></dt>
<dd>vm_bo which is now done</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for normal BOs which are invalidated and that change has been updated
in the PTs.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_base_init">
void <code class="descname">amdgpu_vm_bo_base_init</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;base</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_base_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds bo to the list of bos associated with the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base structure for tracking BO usage in a VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm to which bo is to be added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a bo_va_base structure and add it to the appropriate lists</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_parent">
struct amdgpu_vm_pt * <code class="descname">amdgpu_vm_pt_parent</code><span class="sig-paren">(</span>struct amdgpu_vm_pt *<em>&nbsp;pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent page directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt>
<dd>child page table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to get the parent entry for the child page table. NULL if we are at
the root page directory.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_start">
void <code class="descname">amdgpu_vm_pt_start</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;start</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start PD/PT walk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>amdgpu_vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start address of the walk</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>state to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a amdgpu_vm_pt_cursor to start a walk.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_descendant">
bool <code class="descname">amdgpu_vm_pt_descendant</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_descendant" title="Permalink to this definition">¶</a></dt>
<dd><p>go to child node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the child node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_sibling">
bool <code class="descname">amdgpu_vm_pt_sibling</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_sibling" title="Permalink to this definition">¶</a></dt>
<dd><p>go to sibling node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the sibling node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_ancestor">
bool <code class="descname">amdgpu_vm_pt_ancestor</code><span class="sig-paren">(</span>struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>go to parent node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the parent node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_next">
void <code class="descname">amdgpu_vm_pt_next</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_next" title="Permalink to this definition">¶</a></dt>
<dd><p>get next PD/PT in hieratchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the PD/PT tree to the next node.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_first_dfs">
void <code class="descname">amdgpu_vm_pt_first_dfs</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;start</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_first_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>start a deep first search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>amdgpu_vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>state to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts a deep first traversal of the PD/PT tree.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_continue_dfs">
bool <code class="descname">amdgpu_vm_pt_continue_dfs</code><span class="sig-paren">(</span>struct amdgpu_vm_pt_cursor *<em>&nbsp;start</em>, struct amdgpu_vm_pt *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_continue_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the deep first search should continue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>starting point for the search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>current entry</dd>
</dl>
<p><strong>Return</strong></p>
<p>True when the search should continue, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_next_dfs">
void <code class="descname">amdgpu_vm_pt_next_dfs</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_next_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next node for a deep first search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the cursor to the next node in a deep first search.</p>
<dl class="function">
<dt id="c.for_each_amdgpu_vm_pt_dfs_safe">
<code class="descname">for_each_amdgpu_vm_pt_dfs_safe</code><span class="sig-paren">(</span><em>adev</em>, <em>vm</em>, <em>start</em>, <em>cursor</em>, <em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_amdgpu_vm_pt_dfs_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>safe deep first search of all PDs/PTs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_get_pd_bo">
void <code class="descname">amdgpu_vm_get_pd_bo</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct list_head *<em>&nbsp;validated</em>, struct amdgpu_bo_list_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_pd_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>add the VM PD to a validation list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">validated</span></code></dt>
<dd>head of validation list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_list_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>entry to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the page directory to the list of BOs to
validate for command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_move_to_lru_tail">
void <code class="descname">amdgpu_vm_move_to_lru_tail</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_move_to_lru_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>move all BOs to the end of LRU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm providing the BOs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move all BOs to the end of LRU and remember their positions to put them
together.</p>
<dl class="function">
<dt id="c.amdgpu_vm_validate_pt_bos">
int <code class="descname">amdgpu_vm_validate_pt_bos</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, int (*<a class="reference internal" href="../networking/kapi.html#c.validate" title="validate">validate</a>) (void<em>&nbsp;*p</em>, struct amdgpu_bo<em>&nbsp;*bo</em>, void *<em>&nbsp;param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_validate_pt_bos" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the page table BOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*p,</span> <span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo)</span> <span class="pre">validate</span></code></dt>
<dd>callback to do the validation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">param</span></code></dt>
<dd>parameter for the validation callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate the page table BOs on command submission if neccessary.</p>
<p><strong>Return</strong></p>
<p>Validation result.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ready">
bool <code class="descname">amdgpu_vm_ready</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check VM is ready for updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if all VM PDs/PTs are ready for updates</p>
<p><strong>Return</strong></p>
<p>True if eviction list is empty.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_bo">
int <code class="descname">amdgpu_vm_clear_bo</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>initially clear the PDs/PTs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to clear BO from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>BO to clear</dd>
</dl>
<p><strong>Description</strong></p>
<p>Root PD needs to be reserved when calling this.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_param">
void <code class="descname">amdgpu_vm_bo_param</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, int<em>&nbsp;level</em>, struct amdgpu_bo_param *<em>&nbsp;bp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_param" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in parameters for PD/PT allocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requesting vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*</span> <span class="pre">bp</span></code></dt>
<dd>resulting BO allocation parameters</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_alloc_pts">
int <code class="descname">amdgpu_vm_alloc_pts</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_alloc_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a specific page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to allocate page tables for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>Which page table to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure a specific page table or directory is allocated.</p>
<p><strong>Return</strong></p>
<p>1 if page table needed to be allocated, 0 if page table was already
allocated, negative errno if an error occurred.</p>
<dl class="function">
<dt id="c.amdgpu_vm_free_table">
void <code class="descname">amdgpu_vm_free_table</code><span class="sig-paren">(</span>struct amdgpu_vm_pt *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_table" title="Permalink to this definition">¶</a></dt>
<dd><p>fre one PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>PDE to free</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_free_pts">
void <code class="descname">amdgpu_vm_free_pts</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_vm_pt_cursor *<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>free PD/PT levels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>amdgpu vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>optional cursor where to start freeing PDs/PTs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the page directory or page table level and all sub levels.</p>
<dl class="function">
<dt id="c.amdgpu_vm_check_compute_bug">
void <code class="descname">amdgpu_vm_check_compute_bug</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_check_compute_bug" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether asic has compute vm bug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_need_pipeline_sync">
bool <code class="descname">amdgpu_vm_need_pipeline_sync</code><span class="sig-paren">(</span>struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_job *<em>&nbsp;job</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_need_pipeline_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if pipe sync is needed for job.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>ring on which the job will be submitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>job to submit</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if sync is needed.</p>
<dl class="function">
<dt id="c.amdgpu_vm_flush">
int <code class="descname">amdgpu_vm_flush</code><span class="sig-paren">(</span>struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_job *<em>&nbsp;job</em>, bool<em>&nbsp;need_pipe_sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware flush the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>ring to use for flush</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>related job</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">need_pipe_sync</span></code></dt>
<dd>is pipe sync needed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Emit a VM flush when it is necessary.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_find">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_find</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bo_va for a specific vm &amp; bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>requested buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find <strong>bo</strong> inside the requested vm.
Search inside the <strong>bos</strong> vm list for the requested vm
Returns the found bo_va or NULL if none is found</p>
<p>Object has to be reserved!</p>
<p><strong>Return</strong></p>
<p>Found bo_va or NULL.</p>
<dl class="function">
<dt id="c.amdgpu_vm_map_gart">
uint64_t <code class="descname">amdgpu_vm_map_gart</code><span class="sig-paren">(</span>const dma_addr_t *<em>&nbsp;pages_addr</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_map_gart" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve gart mapping of addr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>optional DMA address to use for lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the unmapped addr</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up the physical address of the page that the pte resolves
to.</p>
<p><strong>Return</strong></p>
<p>The pointer for the page table entry.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_flags">
void <code class="descname">amdgpu_vm_update_flags</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params *<em>&nbsp;params</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, unsigned<em>&nbsp;level</em>, uint64_t<em>&nbsp;pe</em>, uint64_t<em>&nbsp;addr</em>, unsigned<em>&nbsp;count</em>, uint32_t<em>&nbsp;incr</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>figure out flags for PTE updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">pe</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">incr</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure to set the right flags for the PTEs at the desired level.</p>
<dl class="function">
<dt id="c.amdgpu_vm_fragment">
void <code class="descname">amdgpu_vm_fragment</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params *<em>&nbsp;params</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;end</em>, uint64_t<em>&nbsp;flags</em>, unsigned int *<em>&nbsp;frag</em>, uint64_t *<em>&nbsp;frag_end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>get fragment for PTEs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_vm_update_params definition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>first PTE to handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">end</span></code></dt>
<dd>last PTE to handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>hw mapping flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>resulting fragment size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">frag_end</span></code></dt>
<dd>end of this fragment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the first possible fragment for the start and end address.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_ptes">
int <code class="descname">amdgpu_vm_update_ptes</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params *<em>&nbsp;params</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;end</em>, uint64_t<em>&nbsp;dst</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure that page tables are valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_vm_update_params definition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of GPU address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">end</span></code></dt>
<dd>end of GPU address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">dst</span></code></dt>
<dd>destination address to map to, the next dst inside the function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>mapping flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the page tables in the range <strong>start</strong> - <strong>end</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update_mapping">
int <code class="descname">amdgpu_vm_bo_update_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;exclusive</em>, dma_addr_t *<em>&nbsp;pages_addr</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;last</em>, uint64_t<em>&nbsp;flags</em>, uint64_t<em>&nbsp;addr</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>update a mapping in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">exclusive</span></code></dt>
<dd>fence we need to sync to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of mapped range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">last</span></code></dt>
<dd>last mapped entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags for the entries</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>addr to set the area to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries between <strong>start</strong> and <strong>last</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_split_mapping">
int <code class="descname">amdgpu_vm_bo_split_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;exclusive</em>, dma_addr_t *<em>&nbsp;pages_addr</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em>, uint64_t<em>&nbsp;flags</em>, struct amdgpu_device *<em>&nbsp;bo_adev</em>, struct <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;nodes</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_split_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>split a mapping into smaller chunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">exclusive</span></code></dt>
<dd>fence we need to sync to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapped range and flags to use for the update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>HW flags for the mapping</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">bo_adev</span></code></dt>
<dd>amdgpu_device pointer that bo actually been allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">nodes</span></code></dt>
<dd>array of drm_mm_nodes with the MC addresses</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Split the mapping into smaller chunks so that each update fits
into a SDMA IB.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update">
int <code class="descname">amdgpu_vm_bo_update</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, bool<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update all BO mappings in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>requested BO and VM object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clear</span></code></dt>
<dd>if true clear the entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries for <strong>bo_va</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_prt_state">
void <code class="descname">amdgpu_vm_update_prt_state</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_prt_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update the global PRT state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_get">
void <code class="descname">amdgpu_vm_prt_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>add a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_put">
void <code class="descname">amdgpu_vm_prt_put</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_cb">
void <code class="descname">amdgpu_vm_prt_cb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a> *<em>&nbsp;_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence for the callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*</span> <span class="pre">_cb</span></code></dt>
<dd>the callback function</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_add_prt_cb">
void <code class="descname">amdgpu_vm_add_prt_cb</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_add_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>add callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence for the callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_free_mapping">
void <code class="descname">amdgpu_vm_free_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>free a mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to be freed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence of the unmap operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a mapping and make sure we decrease the PRT usage count if applicable.</p>
<dl class="function">
<dt id="c.amdgpu_vm_prt_fini">
void <code class="descname">amdgpu_vm_prt_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finish all prt mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a cleanup callback to disable PRT support after VM dies.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_freed">
int <code class="descname">amdgpu_vm_clear_freed</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_freed" title="Permalink to this definition">¶</a></dt>
<dd><p>clear freed BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence (unchanged if no work needed to be done
or if an error occurred)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all freed BOs are cleared in the PT.
PTs have to be reserved and mutex must be locked!</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<dl class="function">
<dt id="c.amdgpu_vm_handle_moved">
int <code class="descname">amdgpu_vm_handle_moved</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_handle_moved" title="Permalink to this definition">¶</a></dt>
<dd><p>handle moved BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all BOs which are moved are updated in the PTs.</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<p>PTs have to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_add">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_add</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a bo to a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>bo</strong> into the requested vm.
Add <strong>bo</strong> to the list of bos associated with the vm</p>
<p><strong>Return</strong></p>
<p>Newly added bo_va or NULL for failure</p>
<p>Object has to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_insert_map">
void <code class="descname">amdgpu_vm_bo_insert_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_insert_map" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a new mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the mapping to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new mapping into all structures.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_map">
int <code class="descname">amdgpu_vm_bo_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_replace_map">
int <code class="descname">amdgpu_vm_bo_replace_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_replace_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm, replacing existing mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM. Replace existing
mappings as we do so.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_unmap">
int <code class="descname">amdgpu_vm_bo_unmap</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>remove bo mapping from vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to remove the address from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to the BO is mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of the BO at the specefied addr from the VM.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_clear_mappings">
int <code class="descname">amdgpu_vm_bo_clear_mappings</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_clear_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all mappings in a specific range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM structure to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>start of the range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>size of the range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove all mappings in a range, split them as appropriate.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_lookup_mapping">
struct amdgpu_bo_va_mapping * <code class="descname">amdgpu_vm_bo_lookup_mapping</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_lookup_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>find mapping by address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>the requested VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a mapping by it’s address.</p>
<p><strong>Return</strong></p>
<p>The amdgpu_bo_va_mapping matching for addr or NULL</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_trace_cs">
void <code class="descname">amdgpu_vm_bo_trace_cs</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct ww_acquire_ctx *<em>&nbsp;ticket</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_trace_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>trace all reserved mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>the requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ticket</span></code></dt>
<dd>CS ticket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trace all mappings of BOs reserved during a command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_rmv">
void <code class="descname">amdgpu_vm_bo_rmv</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_rmv" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a bo to a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>requested bo_va</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove <strong>bo_va-&gt;bo</strong> from the requested vm.</p>
<p>Object have to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_invalidate">
void <code class="descname">amdgpu_vm_bo_invalidate</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, bool<em>&nbsp;evicted</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the bo as invalid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evicted</span></code></dt>
<dd>is the BO evicted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>bo</strong> as invalid.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_block_size">
uint32_t <code class="descname">amdgpu_vm_get_block_size</code><span class="sig-paren">(</span>uint64_t<em>&nbsp;vm_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate VM page table size as power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">vm_size</span></code></dt>
<dd>VM size</dd>
</dl>
<p><strong>Return</strong></p>
<p>VM page table as power of two</p>
<dl class="function">
<dt id="c.amdgpu_vm_adjust_size">
void <code class="descname">amdgpu_vm_adjust_size</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, uint32_t<em>&nbsp;min_vm_size</em>, uint32_t<em>&nbsp;fragment_size_default</em>, unsigned<em>&nbsp;max_level</em>, unsigned<em>&nbsp;max_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust vm size, block size and fragment size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">min_vm_size</span></code></dt>
<dd>the minimum vm size in GB if it’s set auto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">fragment_size_default</span></code></dt>
<dd>Default PTE fragment size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">max_level</span></code></dt>
<dd>max VMPT level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">max_bits</span></code></dt>
<dd>max address space size in bits</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_wait_idle">
long <code class="descname">amdgpu_vm_wait_idle</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_wait_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for the VM to become idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM object to wait for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for VM to become idle</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_init">
int <code class="descname">amdgpu_vm_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, int<em>&nbsp;vm_context</em>, unsigned int<em>&nbsp;pasid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vm_context</span></code></dt>
<dd>Indicates if it GFX or Compute context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd>Process address space identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Init <strong>vm</strong> fields.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_check_clean_reserved">
int <code class="descname">amdgpu_vm_check_clean_reserved</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_check_clean_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a VM is clean</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>the VM to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>check all entries of the root PD, if any subsequent PDs are allocated,
it means there are page table creating and filling, and is no a clean
VM</p>
<p><strong>Return</strong></p>
<blockquote>
<div>0 if this VM is clean</div></blockquote>
<dl class="function">
<dt id="c.amdgpu_vm_make_compute">
int <code class="descname">amdgpu_vm_make_compute</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, unsigned int<em>&nbsp;pasid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_make_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a GFX VM into a compute VM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>This only works on GFX VMs that don’t have any BOs added and no
page tables allocated yet.</p>
<p>Changes the following VM parameters:
- use_cpu_for_update
- pte_supports_ats
- pasid (old PASID is released, because compute manages its own PASIDs)</p>
<p>Reinitializes the page directory to reflect the changed ATS
setting.</p>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_release_compute">
void <code class="descname">amdgpu_vm_release_compute</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_release_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>release a compute vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>a vm turned into compute vm by calling amdgpu_vm_make_compute</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a correspondant of amdgpu_vm_make_compute. It decouples compute
pasid from vm. Compute should stop use of vm after this call.</p>
<dl class="function">
<dt id="c.amdgpu_vm_fini">
void <code class="descname">amdgpu_vm_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down <strong>vm</strong>.
Unbind the VM and remove all bos from the vm bo list</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_init">
void <code class="descname">amdgpu_vm_manager_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_init" title="Permalink to this definition">¶</a></dt>
<dd><p>init the VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the VM manager structures</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_fini">
void <code class="descname">amdgpu_vm_manager_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup the VM manager and free resources.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ioctl">
int <code class="descname">amdgpu_vm_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages VMID reservation for vm hubs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>drm_amdgpu_vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>drm file pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_task_info">
void <code class="descname">amdgpu_vm_get_task_info</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned int<em>&nbsp;pasid</em>, struct amdgpu_task_info *<em>&nbsp;task_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts task info for a PASID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>drm device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd>PASID identifier for VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_task_info</span> <span class="pre">*</span> <span class="pre">task_info</span></code></dt>
<dd>task_info to fill.</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_set_task_info">
void <code class="descname">amdgpu_vm_set_task_info</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_set_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets VMs task info.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm for which to set the info</dd>
</dl>
</div>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<p>Interrupts generated within GPU hardware raise interrupt requests that are
passed to amdgpu IRQ handler which is responsible for detecting source and
type of the interrupt and dispatching matching handlers. If handling an
interrupt requires calling kernel functions that may sleep processing is
dispatched to work handlers.</p>
<p>If MSI functionality is not disabled by module parameter then MSI
support will be enabled.</p>
<p>For GPU interrupt sources that may be driven by another driver, IRQ domain
support is used (with mapping between virtual and hardware IRQs).</p>
<dl class="function">
<dt id="c.amdgpu_hotplug_work_func">
void <code class="descname">amdgpu_hotplug_work_func</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_hotplug_work_func" title="Permalink to this definition">¶</a></dt>
<dd><p>work handler for display hotplug event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work struct pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the hotplug event work handler (all ASICs).
The work gets scheduled from the IRQ handler if there
was a hotplug interrupt.  It walks through the connector table
and calls hotplug handler for each connector. After this, it sends
a DRM hotplug event to alert userspace.</p>
<p>This design approach is required in order to defer hotplug event handling
from the IRQ handler to a work handler because hotplug handler has to use
mutexes which cannot be locked in an IRQ handler (since <a class="reference internal" href="../translations/it_IT/kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">mutex_lock</span></code></a> may
sleep).</p>
<dl class="function">
<dt id="c.amdgpu_irq_disable_all">
void <code class="descname">amdgpu_irq_disable_all</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable <em>all</em> interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable all types of interrupts from all sources.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handler">
irqreturn_t <code class="descname">amdgpu_irq_handler</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>IRQ handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>IRQ number (unused)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>pointer to DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>IRQ handler for amdgpu driver (all ASICs).</p>
<p><strong>Return</strong></p>
<p>result of handling the IRQ, as defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">irqreturn_t</span></code></p>
<dl class="function">
<dt id="c.amdgpu_irq_handle_ih1">
void <code class="descname">amdgpu_irq_handle_ih1</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handle_ih1" title="Permalink to this definition">¶</a></dt>
<dd><p>kick of processing for IH1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work structure in struct amdgpu_irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kick of processing IH ring 1.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handle_ih2">
void <code class="descname">amdgpu_irq_handle_ih2</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handle_ih2" title="Permalink to this definition">¶</a></dt>
<dd><p>kick of processing for IH2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work structure in struct amdgpu_irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kick of processing IH ring 2.</p>
<dl class="function">
<dt id="c.amdgpu_msi_ok">
bool <code class="descname">amdgpu_msi_ok</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_msi_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether MSI functionality is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer (unused)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether MSI functionality has been disabled via module parameter
(all ASICs).</p>
<p><strong>Return</strong></p>
<p><em>true</em> if MSIs are allowed to be enabled or <em>false</em> otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_init">
int <code class="descname">amdgpu_irq_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up work functions for hotplug and reset interrupts, enables MSI
functionality, initializes vblank, hotplug and reset interrupt handling.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code on failure</p>
<dl class="function">
<dt id="c.amdgpu_irq_fini">
void <code class="descname">amdgpu_irq_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>shut down interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down work functions for hotplug and reset interrupts, disables MSI
functionality, shuts down vblank, hotplug and reset interrupt handling,
turns off interrupts from all sources (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_id">
int <code class="descname">amdgpu_irq_add_id</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;client_id</em>, unsigned<em>&nbsp;src_id</em>, struct amdgpu_irq_src *<em>&nbsp;source</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_id" title="Permalink to this definition">¶</a></dt>
<dd><p>register IRQ source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">client_id</span></code></dt>
<dd>client id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>source id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>IRQ source pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers IRQ source on a client.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_dispatch">
void <code class="descname">amdgpu_irq_dispatch</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_ih_ring *<em>&nbsp;ih</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>dispatch IRQ to IP blocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ih_ring</span> <span class="pre">*</span> <span class="pre">ih</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispatches IRQ to IP blocks.</p>
<dl class="function">
<dt id="c.amdgpu_irq_update">
int <code class="descname">amdgpu_irq_update</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update hardware interrupt state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates interrupt state for the specific source (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_gpu_reset_resume_helper">
void <code class="descname">amdgpu_irq_gpu_reset_resume_helper</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_gpu_reset_resume_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>update interrupt states on all sources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates state of all types of interrupts on all sources on resume after
reset.</p>
<dl class="function">
<dt id="c.amdgpu_irq_get">
int <code class="descname">amdgpu_irq_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_get" title="Permalink to this definition">¶</a></dt>
<dd><p>enable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_put">
int <code class="descname">amdgpu_irq_put</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_put" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_enabled">
bool <code class="descname">amdgpu_irq_enabled</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether interrupt is enabled or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the given type of interrupt is enabled on the given source.</p>
<p><strong>Return</strong></p>
<p><em>true</em> if interrupt is enabled, <em>false</em> if interrupt is disabled or on
invalid parameters</p>
<dl class="function">
<dt id="c.amdgpu_irqdomain_map">
int <code class="descname">amdgpu_irqdomain_map</code><span class="sig-paren">(</span>struct irq_domain *<em>&nbsp;d</em>, unsigned int<em>&nbsp;irq</em>, irq_hw_number_t<em>&nbsp;hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irqdomain_map" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between virtual and hardware IRQ numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>amdgpu IRQ domain pointer (unused)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>virtual IRQ number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt>
<dd>hardware irq number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current implementation assigns simple interrupt handler to the given virtual
IRQ.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_domain">
int <code class="descname">amdgpu_irq_add_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>create a linear IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_remove_domain">
void <code class="descname">amdgpu_irq_remove_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_remove_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<dl class="function">
<dt id="c.amdgpu_irq_create_mapping">
unsigned <code class="descname">amdgpu_irq_create_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;src_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_create_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between domain Linux IRQs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>IH source id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates mapping between a domain IRQ (GPU IH src id) and a Linux IRQ
Use this for components that generate a GPU interrupt, but are driven
by a different driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>Linux IRQ</p>
</div>
</div>
<div class="section" id="amdgpu-xgmi-support">
<h2>AMDGPU XGMI Support<a class="headerlink" href="#amdgpu-xgmi-support" title="Permalink to this headline">¶</a></h2>
<p>XGMI is a high speed interconnect that joins multiple GPU cards
into a homogeneous memory space that is organized by a collective
hive ID and individual node IDs, both of which are 64-bit numbers.</p>
<p>The file xgmi_device_id contains the unique per GPU device ID and
is stored in the /sys/class/drm/card${cardno}/device/ directory.</p>
<p>Inside the device directory a sub-directory ‘xgmi_hive_info’ is
created which contains the hive ID and the list of nodes.</p>
<dl class="docutils">
<dt>The hive ID is stored in:</dt>
<dd>/sys/class/drm/card${cardno}/device/xgmi_hive_info/xgmi_hive_id</dd>
<dt>The node information is stored in numbered directories:</dt>
<dd>/sys/class/drm/card${cardno}/device/xgmi_hive_info/node${nodeno}/xgmi_device_id</dd>
</dl>
<p>Each device has their own xgmi_hive_info direction with a mirror
set of node sub-directories.</p>
<p>The XGMI memory space is built by contiguously adding the power of
two padded VRAM space from each node to each other.</p>
</div>
<div class="section" id="amdgpu-ras-debugfs-control-interface">
<h2>AMDGPU RAS debugfs control interface<a class="headerlink" href="#amdgpu-ras-debugfs-control-interface" title="Permalink to this headline">¶</a></h2>
<p>It accepts struct ras_debug_if who has two members.</p>
<p>First member: ras_debug_if::head or ras_debug_if::inject.</p>
<p>head is used to indicate which IP block will be under control.</p>
<p>head has four members, they are block, type, sub_block_index, name.
block: which IP will be under control.
type: what kind of error will be enabled/disabled/injected.
sub_block_index: some IPs have subcomponets. say, GFX, sDMA.
name: the name of IP.</p>
<p>inject has two more members than head, they are address, value.
As their names indicate, inject operation will write the
value to the address.</p>
<p>Second member: struct ras_debug_if::op.
It has three kinds of operations.</p>
<blockquote>
<div>0: disable RAS on the block. Take ::head as its data.
1: enable RAS on the block. Take ::head as its data.
2: inject errors on the block. Take ::inject as its data.</div></blockquote>
<p>How to use the interface?
programs:
copy the struct ras_debug_if in your codes and initialize it.
write the struct to the control node.</p>
<p>bash:
echo op block [error [sub_blcok address value]] &gt; …/ras/ras_ctrl</p>
<blockquote>
<div><dl class="docutils">
<dt>op: disable, enable, inject</dt>
<dd>disable: only block is needed
enable: block and error are needed
inject: error, address, value are needed</dd>
<dt>block: umc, smda, gfx, ………</dt>
<dd>see ras_block_string[] for details</dd>
<dt>error: ue, ce</dt>
<dd>ue: multi_uncorrectable
ce: single_correctable</dd>
</dl>
<p>sub_block: sub block index, pass 0 if there is no sub block</p>
</div></blockquote>
<dl class="docutils">
<dt>here are some examples for bash commands,</dt>
<dd>echo inject umc ue 0x0 0x0 0x0 &gt; /sys/kernel/debug/dri/0/ras/ras_ctrl
echo inject umc ce 0 0 0 &gt; /sys/kernel/debug/dri/0/ras/ras_ctrl
echo disable umc &gt; /sys/kernel/debug/dri/0/ras/ras_ctrl</dd>
</dl>
<p>How to check the result?</p>
<p>For disable/enable, please check ras features at
/sys/class/drm/card[0/1/2…]/device/ras/features</p>
<p>For inject, please check corresponding err count at
/sys/class/drm/card[0/1/2…]/device/ras/[gfx/sdma/…]_err_count</p>
<p>NOTE: operation is only allowed on blocks which are supported.
Please check ras mask at /sys/module/amdgpu/parameters/ras_mask</p>
</div>
<div class="section" id="gpu-power-thermal-controls-and-monitoring">
<h2>GPU Power/Thermal Controls and Monitoring<a class="headerlink" href="#gpu-power-thermal-controls-and-monitoring" title="Permalink to this headline">¶</a></h2>
<p>This section covers hwmon and power/thermal controls.</p>
<div class="section" id="hwmon-interfaces">
<h3>HWMON Interfaces<a class="headerlink" href="#hwmon-interfaces" title="Permalink to this headline">¶</a></h3>
<p>The amdgpu driver exposes the following sensor interfaces:</p>
<ul class="simple">
<li>GPU temperature (via the on-die sensor)</li>
<li>GPU voltage</li>
<li>Northbridge voltage (APUs only)</li>
<li>GPU power</li>
<li>GPU fan</li>
<li>GPU gfx/compute engine clock</li>
<li>GPU memory clock (dGPU only)</li>
</ul>
<p>hwmon interfaces for GPU temperature:</p>
<ul class="simple">
<li>temp[1-3]_input: the on die GPU temperature in millidegrees Celsius
- temp2_input and temp3_input are supported on SOC15 dGPUs only</li>
<li>temp[1-3]_label: temperature channel label
- temp2_label and temp3_label are supported on SOC15 dGPUs only</li>
<li>temp[1-3]_crit: temperature critical max value in millidegrees Celsius
- temp2_crit and temp3_crit are supported on SOC15 dGPUs only</li>
<li>temp[1-3]_crit_hyst: temperature hysteresis for critical limit in millidegrees Celsius
- temp2_crit_hyst and temp3_crit_hyst are supported on SOC15 dGPUs only</li>
<li>temp[1-3]_emergency: temperature emergency max value(asic shutdown) in millidegrees Celsius
- these are supported on SOC15 dGPUs only</li>
</ul>
<p>hwmon interfaces for GPU voltage:</p>
<ul class="simple">
<li>in0_input: the voltage on the GPU in millivolts</li>
<li>in1_input: the voltage on the Northbridge in millivolts</li>
</ul>
<p>hwmon interfaces for GPU power:</p>
<ul class="simple">
<li>power1_average: average power used by the GPU in microWatts</li>
<li>power1_cap_min: minimum cap supported in microWatts</li>
<li>power1_cap_max: maximum cap supported in microWatts</li>
<li>power1_cap: selected power cap in microWatts</li>
</ul>
<p>hwmon interfaces for GPU fan:</p>
<ul class="simple">
<li>pwm1: pulse width modulation fan level (0-255)</li>
<li>pwm1_enable: pulse width modulation fan control method (0: no fan speed control, 1: manual fan speed control using pwm interface, 2: automatic fan speed control)</li>
<li>pwm1_min: pulse width modulation fan control minimum level (0)</li>
<li>pwm1_max: pulse width modulation fan control maximum level (255)</li>
<li>fan1_min: an minimum value Unit: revolution/min (RPM)</li>
<li>fan1_max: an maxmum value Unit: revolution/max (RPM)</li>
<li>fan1_input: fan speed in RPM</li>
<li>fan[1-<a href="#id1"><span class="problematic" id="id2">*</span></a>]_target: Desired fan speed Unit: revolution/min (RPM)</li>
<li>fan[1-<a href="#id3"><span class="problematic" id="id4">*</span></a>]_enable: Enable or disable the sensors.1: Enable 0: Disable</li>
</ul>
<p>hwmon interfaces for GPU clocks:</p>
<ul class="simple">
<li>freq1_input: the gfx/compute clock in hertz</li>
<li>freq2_input: the memory clock in hertz</li>
</ul>
<p>You can use hwmon tools like sensors to view this information on your system.</p>
</div>
<div class="section" id="gpu-sysfs-power-state-interfaces">
<h3>GPU sysfs Power State Interfaces<a class="headerlink" href="#gpu-sysfs-power-state-interfaces" title="Permalink to this headline">¶</a></h3>
<p>GPU power controls are exposed via sysfs files.</p>
<div class="section" id="power-dpm-state">
<h4>power_dpm_state<a class="headerlink" href="#power-dpm-state" title="Permalink to this headline">¶</a></h4>
<p>The power_dpm_state file is a legacy interface and is only provided for
backwards compatibility. The amdgpu driver provides a sysfs API for adjusting
certain power related parameters.  The file power_dpm_state is used for this.
It accepts the following arguments:</p>
<ul class="simple">
<li>battery</li>
<li>balanced</li>
<li>performance</li>
</ul>
<p>battery</p>
<p>On older GPUs, the vbios provided a special power state for battery
operation.  Selecting battery switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
<p>balanced</p>
<p>On older GPUs, the vbios provided a special power state for balanced
operation.  Selecting balanced switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
<p>performance</p>
<p>On older GPUs, the vbios provided a special power state for performance
operation.  Selecting performance switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
</div>
<div class="section" id="power-dpm-force-performance-level">
<h4>power_dpm_force_performance_level<a class="headerlink" href="#power-dpm-force-performance-level" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting certain power
related parameters.  The file power_dpm_force_performance_level is
used for this.  It accepts the following arguments:</p>
<ul class="simple">
<li>auto</li>
<li>low</li>
<li>high</li>
<li>manual</li>
<li>profile_standard</li>
<li>profile_min_sclk</li>
<li>profile_min_mclk</li>
<li>profile_peak</li>
</ul>
<p>auto</p>
<p>When auto is selected, the driver will attempt to dynamically select
the optimal power profile for current conditions in the driver.</p>
<p>low</p>
<p>When low is selected, the clocks are forced to the lowest power state.</p>
<p>high</p>
<p>When high is selected, the clocks are forced to the highest power state.</p>
<p>manual</p>
<p>When manual is selected, the user can manually adjust which power states
are enabled for each clock domain via the sysfs pp_dpm_mclk, pp_dpm_sclk,
and pp_dpm_pcie files and adjust the power state transition heuristics
via the pp_power_profile_mode sysfs file.</p>
<p>profile_standard
profile_min_sclk
profile_min_mclk
profile_peak</p>
<p>When the profiling modes are selected, clock and power gating are
disabled and the clocks are set for different profiling cases. This
mode is recommended for profiling specific work loads where you do
not want clock or power gating for clock fluctuation to interfere
with your results. profile_standard sets the clocks to a fixed clock
level which varies from asic to asic.  profile_min_sclk forces the sclk
to the lowest level.  profile_min_mclk forces the mclk to the lowest level.
profile_peak sets all clocks (mclk, sclk, pcie) to the highest levels.</p>
</div>
<div class="section" id="pp-table">
<h4>pp_table<a class="headerlink" href="#pp-table" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for uploading new powerplay
tables.  The file pp_table is used for this.  Reading the file
will dump the current power play table.  Writing to the file
will attempt to upload a new powerplay table and re-initialize
powerplay using that new table.</p>
</div>
<div class="section" id="pp-od-clk-voltage">
<h4>pp_od_clk_voltage<a class="headerlink" href="#pp-od-clk-voltage" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting the clocks and voltages
in each power level within a power state.  The pp_od_clk_voltage is used for
this.</p>
<p>&lt; For Vega10 and previous ASICs &gt;</p>
<p>Reading the file will display:</p>
<ul class="simple">
<li>a list of engine clock levels and voltages labeled OD_SCLK</li>
<li>a list of memory clock levels and voltages labeled OD_MCLK</li>
<li>a list of valid ranges for sclk, mclk, and voltage labeled OD_RANGE</li>
</ul>
<p>To manually adjust these settings, first select manual using
power_dpm_force_performance_level. Enter a new value for each
level by writing a string that contains “s/m level clock voltage” to
the file.  E.g., “s 1 500 820” will update sclk level 1 to be 500 MHz
at 820 mV; “m 0 350 810” will update mclk level 0 to be 350 MHz at
810 mV.  When you have edited all of the states as needed, write
“c” (commit) to the file to commit your changes.  If you want to reset to the
default power levels, write “r” (reset) to the file to reset them.</p>
<p>&lt; For Vega20 &gt;</p>
<p>Reading the file will display:</p>
<ul class="simple">
<li>minimum and maximum engine clock labeled OD_SCLK</li>
<li>maximum memory clock labeled OD_MCLK</li>
<li>three &lt;frequency, voltage&gt; points labeled OD_VDDC_CURVE.
They can be used to calibrate the sclk voltage curve.</li>
<li>a list of valid ranges for sclk, mclk, and voltage curve points
labeled OD_RANGE</li>
</ul>
<p>To manually adjust these settings:</p>
<ul>
<li><p class="first">First select manual using power_dpm_force_performance_level</p>
</li>
<li><p class="first">For clock frequency setting, enter a new value by writing a
string that contains “s/m index clock” to the file. The index
should be 0 if to set minimum clock. And 1 if to set maximum
clock. E.g., “s 0 500” will update minimum sclk to be 500 MHz.
“m 1 800” will update maximum mclk to be 800Mhz.</p>
<p>For sclk voltage curve, enter the new values by writing a
string that contains “vc point clock voltage” to the file. The
points are indexed by 0, 1 and 2. E.g., “vc 0 300 600” will
update point1 with clock set as 300Mhz and voltage as
600mV. “vc 2 1000 1000” will update point3 with clock set
as 1000Mhz and voltage 1000mV.</p>
</li>
<li><p class="first">When you have edited all of the states as needed, write “c” (commit)
to the file to commit your changes</p>
</li>
<li><p class="first">If you want to reset to the default power levels, write “r” (reset)
to the file to reset them</p>
</li>
</ul>
</div>
<div class="section" id="pp-dpm-sclk-pp-dpm-mclk-pp-dpm-pcie">
<h4>pp_dpm_sclk pp_dpm_mclk pp_dpm_pcie<a class="headerlink" href="#pp-dpm-sclk-pp-dpm-mclk-pp-dpm-pcie" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="pp-power-profile-mode">
<h4>pp_power_profile_mode<a class="headerlink" href="#pp-power-profile-mode" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting the heuristics
related to switching between power levels in a power state.  The file
pp_power_profile_mode is used for this.</p>
<p>Reading this file outputs a list of all of the predefined power profiles
and the relevant heuristics settings for that profile.</p>
<p>To select a profile or create a custom profile, first select manual using
power_dpm_force_performance_level.  Writing the number of a predefined
profile to pp_power_profile_mode will enable those heuristics.  To
create a custom set of heuristics, write a string of numbers to the file
starting with the number of the custom profile along with a setting
for each heuristic parameter.  Due to differences across asic families
the heuristic parameters vary from family to family.</p>
</div>
<div class="section" id="busy-percent">
<h4>busy_percent<a class="headerlink" href="#busy-percent" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for reading how busy the GPU
is as a percentage.  The file gpu_busy_percent is used for this.
The SMU firmware computes a percentage of load based on the
aggregate activity level in the IP cores.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="amdgpu-dc.html" class="btn btn-neutral float-right" title="drm/amd/display - Display Core (DC)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drivers.html" class="btn btn-neutral float-left" title="GPU Driver Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>