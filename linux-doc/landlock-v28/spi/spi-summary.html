

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Overview of Linux kernel SPI support &mdash; The Linux Kernel 5.11.0-rc6+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SPI userspace API" href="spidev.html" />
    <link rel="prev" title="Serial Peripheral Interface (SPI)" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0-rc6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Serial Peripheral Interface (SPI)</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Overview of Linux kernel SPI support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-spi">What is SPI?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#who-uses-it-on-what-kinds-of-systems">Who uses it?  On what kinds of systems?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-m-confused-what-are-these-four-spi-clock-modes">I’m confused.  What are these four SPI “clock modes”?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-do-these-driver-programming-interfaces-work">How do these driver programming interfaces work?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-does-board-specific-init-code-declare-spi-devices">How does board-specific init code declare SPI devices?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#declare-controllers">Declare Controllers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#declare-slave-devices">Declare Slave Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-static-configurations">Non-static Configurations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#how-do-i-write-an-spi-protocol-driver">How do I write an “SPI Protocol Driver”?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-do-i-write-an-spi-master-controller-driver">How do I write an “SPI Master Controller Driver”?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bus-numbering">Bus Numbering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-master-methods">SPI Master Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deprecated-methods">Deprecated Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spi-message-queue">SPI Message Queue</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thanks-to">THANKS TO</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="spidev.html">SPI userspace API</a></li>
<li class="toctree-l2"><a class="reference internal" href="butterfly.html">spi_butterfly - parport-to-butterfly adapter driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="pxa2xx.html">PXA2xx SPI on SSP driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi-lm70llp.html">spi_lm70llp :  LM70-LLP parport-to-SPI adapter</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi-sc18is602.html">Kernel driver spi-sc18is602</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Serial Peripheral Interface (SPI)</a> &raquo;</li>
        
      <li>Overview of Linux kernel SPI support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/spi/spi-summary.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview-of-linux-kernel-spi-support">
<h1>Overview of Linux kernel SPI support<a class="headerlink" href="#overview-of-linux-kernel-spi-support" title="Permalink to this headline">¶</a></h1>
<p>02-Feb-2012</p>
<div class="section" id="what-is-spi">
<h2>What is SPI?<a class="headerlink" href="#what-is-spi" title="Permalink to this headline">¶</a></h2>
<p>The “Serial Peripheral Interface” (SPI) is a synchronous four wire serial
link used to connect microcontrollers to sensors, memory, and peripherals.
It’s a simple “de facto” standard, not complicated enough to acquire a
standardization body.  SPI uses a master/slave configuration.</p>
<p>The three signal wires hold a clock (SCK, often on the order of 10 MHz),
and parallel data lines with “Master Out, Slave In” (MOSI) or “Master In,
Slave Out” (MISO) signals.  (Other names are also used.)  There are four
clocking modes through which data is exchanged; mode-0 and mode-3 are most
commonly used.  Each clock cycle shifts data out and data in; the clock
doesn’t cycle except when there is a data bit to shift.  Not all data bits
are used though; not every protocol uses those full duplex capabilities.</p>
<p>SPI masters use a fourth “chip select” line to activate a given SPI slave
device, so those three signal wires may be connected to several chips
in parallel.  All SPI slaves support chipselects; they are usually active
low signals, labeled nCSx for slave ‘x’ (e.g. nCS0).  Some devices have
other signals, often including an interrupt to the master.</p>
<p>Unlike serial busses like USB or SMBus, even low level protocols for
SPI slave functions are usually not interoperable between vendors
(except for commodities like SPI memory chips).</p>
<blockquote>
<div><ul class="simple">
<li><p>SPI may be used for request/response style device protocols, as with
touchscreen sensors and memory chips.</p></li>
<li><p>It may also be used to stream data in either direction (half duplex),
or both of them at the same time (full duplex).</p></li>
<li><p>Some devices may use eight bit words.  Others may use different word
lengths, such as streams of 12-bit or 20-bit digital samples.</p></li>
<li><p>Words are usually sent with their most significant bit (MSB) first,
but sometimes the least significant bit (LSB) goes first instead.</p></li>
<li><p>Sometimes SPI is used to daisy-chain devices, like shift registers.</p></li>
</ul>
</div></blockquote>
<p>In the same way, SPI slaves will only rarely support any kind of automatic
discovery/enumeration protocol.  The tree of slave devices accessible from
a given SPI master will normally be set up manually, with configuration
tables.</p>
<p>SPI is only one of the names used by such four-wire protocols, and
most controllers have no problem handling “MicroWire” (think of it as
half-duplex SPI, for request/response protocols), SSP (“Synchronous
Serial Protocol”), PSP (“Programmable Serial Protocol”), and other
related protocols.</p>
<p>Some chips eliminate a signal line by combining MOSI and MISO, and
limiting themselves to half-duplex at the hardware level.  In fact
some SPI chips have this signal mode as a strapping option.  These
can be accessed using the same programming interface as SPI, but of
course they won’t handle full duplex transfers.  You may find such
chips described as using “three wire” signaling: SCK, data, nCSx.
(That data line is sometimes called MOMI or SISO.)</p>
<p>Microcontrollers often support both master and slave sides of the SPI
protocol.  This document (and Linux) supports both the master and slave
sides of SPI interactions.</p>
</div>
<div class="section" id="who-uses-it-on-what-kinds-of-systems">
<h2>Who uses it?  On what kinds of systems?<a class="headerlink" href="#who-uses-it-on-what-kinds-of-systems" title="Permalink to this headline">¶</a></h2>
<p>Linux developers using SPI are probably writing device drivers for embedded
systems boards.  SPI is used to control external chips, and it is also a
protocol supported by every MMC or SD memory card.  (The older “DataFlash”
cards, predating MMC cards but using the same connectors and card shape,
support only SPI.)  Some PC hardware uses SPI flash for BIOS code.</p>
<p>SPI slave chips range from digital/analog converters used for analog
sensors and codecs, to memory, to peripherals like USB controllers
or Ethernet adapters; and more.</p>
<p>Most systems using SPI will integrate a few devices on a mainboard.
Some provide SPI links on expansion connectors; in cases where no
dedicated SPI controller exists, GPIO pins can be used to create a
low speed “bitbanging” adapter.  Very few systems will “hotplug” an SPI
controller; the reasons to use SPI focus on low cost and simple operation,
and if dynamic reconfiguration is important, USB will often be a more
appropriate low-pincount peripheral bus.</p>
<p>Many microcontrollers that can run Linux integrate one or more I/O
interfaces with SPI modes.  Given SPI support, they could use MMC or SD
cards without needing a special purpose MMC/SD/SDIO controller.</p>
</div>
<div class="section" id="i-m-confused-what-are-these-four-spi-clock-modes">
<h2>I’m confused.  What are these four SPI “clock modes”?<a class="headerlink" href="#i-m-confused-what-are-these-four-spi-clock-modes" title="Permalink to this headline">¶</a></h2>
<p>It’s easy to be confused here, and the vendor documentation you’ll
find isn’t necessarily helpful.  The four modes combine two mode bits:</p>
<blockquote>
<div><ul>
<li><p>CPOL indicates the initial clock polarity.  CPOL=0 means the
clock starts low, so the first (leading) edge is rising, and
the second (trailing) edge is falling.  CPOL=1 means the clock
starts high, so the first (leading) edge is falling.</p></li>
<li><p>CPHA indicates the clock phase used to sample data; CPHA=0 says
sample on the leading edge, CPHA=1 means the trailing edge.</p>
<p>Since the signal needs to stablize before it’s sampled, CPHA=0
implies that its data is written half a clock before the first
clock edge.  The chipselect may have made it become available.</p>
</li>
</ul>
</div></blockquote>
<p>Chip specs won’t always say “uses SPI mode X” in as many words,
but their timing diagrams will make the CPOL and CPHA modes clear.</p>
<p>In the SPI mode number, CPOL is the high order bit and CPHA is the
low order bit.  So when a chip’s timing diagram shows the clock
starting low (CPOL=0) and data stabilized for sampling during the
trailing clock edge (CPHA=1), that’s SPI mode 1.</p>
<p>Note that the clock mode is relevant as soon as the chipselect goes
active.  So the master must set the clock to inactive before selecting
a slave, and the slave can tell the chosen polarity by sampling the
clock level when its select line goes active.  That’s why many devices
support for example both modes 0 and 3:  they don’t care about polarity,
and always clock data in/out on rising clock edges.</p>
</div>
<div class="section" id="how-do-these-driver-programming-interfaces-work">
<h2>How do these driver programming interfaces work?<a class="headerlink" href="#how-do-these-driver-programming-interfaces-work" title="Permalink to this headline">¶</a></h2>
<p>The &lt;linux/spi/spi.h&gt; header file includes kerneldoc, as does the
main source code, and you should certainly read that chapter of the
kernel API document.  This is just an overview, so you get the big
picture before those details.</p>
<p>SPI requests always go into I/O queues.  Requests for a given SPI device
are always executed in FIFO order, and complete asynchronously through
completion callbacks.  There are also some simple synchronous wrappers
for those calls, including ones for common transaction types like writing
a command and then reading its response.</p>
<p>There are two types of SPI driver, here called:</p>
<blockquote>
<div><dl class="simple">
<dt>Controller drivers …</dt><dd><p>controllers may be built into System-On-Chip
processors, and often support both Master and Slave roles.
These drivers touch hardware registers and may use DMA.
Or they can be PIO bitbangers, needing just GPIO pins.</p>
</dd>
<dt>Protocol drivers …</dt><dd><p>these pass messages through the controller
driver to communicate with a Slave or Master device on the
other side of an SPI link.</p>
</dd>
</dl>
</div></blockquote>
<p>So for example one protocol driver might talk to the MTD layer to export
data to filesystems stored on SPI flash like DataFlash; and others might
control audio interfaces, present touchscreen sensors as input interfaces,
or monitor temperature and voltage levels during industrial processing.
And those might all be sharing the same controller driver.</p>
<p>A “<a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span></code></a>” encapsulates the controller-side interface between
those two types of drivers.</p>
<p>There is a minimal core of SPI programming interfaces, focussing on
using the driver model to connect controller and protocol drivers using
device tables provided by board specific initialization code.  SPI
shows up in sysfs in several locations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/.../CTLR ... physical node for a given SPI controller

/sys/devices/.../CTLR/spiB.C ... spi_device on bus &quot;B&quot;,
     chipselect C, accessed through CTLR.

/sys/bus/spi/devices/spiB.C ... symlink to that physical
     .../CTLR/spiB.C device

/sys/devices/.../CTLR/spiB.C/modalias ... identifies the driver
     that should be used with this device (for hotplug/coldplug)

/sys/bus/spi/drivers/D ... driver for one or more spi*.* devices

/sys/class/spi_master/spiB ... symlink (or actual device node) to
     a logical node which could hold class related state for the SPI
     master controller managing bus &quot;B&quot;.  All spiB.* devices share one
     physical SPI bus segment, with SCLK, MOSI, and MISO.

/sys/devices/.../CTLR/slave ... virtual file for (un)registering the
     slave device for an SPI slave controller.
     Writing the driver name of an SPI slave handler to this file
     registers the slave device; writing &quot;(null)&quot; unregisters the slave
     device.
     Reading from this file shows the name of the slave device (&quot;(null)&quot;
     if not registered).

/sys/class/spi_slave/spiB ... symlink (or actual device node) to
     a logical node which could hold class related state for the SPI
     slave controller on bus &quot;B&quot;.  When registered, a single spiB.*
     device is present here, possible sharing the physical SPI bus
     segment with other SPI slave devices.
</pre></div>
</div>
<p>Note that the actual location of the controller’s class state depends
on whether you enabled CONFIG_SYSFS_DEPRECATED or not.  At this time,
the only class-specific state is the bus number (“B” in “spiB”), so
those /sys/class entries are only useful to quickly identify busses.</p>
</div>
<div class="section" id="how-does-board-specific-init-code-declare-spi-devices">
<h2>How does board-specific init code declare SPI devices?<a class="headerlink" href="#how-does-board-specific-init-code-declare-spi-devices" title="Permalink to this headline">¶</a></h2>
<p>Linux needs several kinds of information to properly configure SPI devices.
That information is normally provided by board-specific code, even for
chips that do support some of automated discovery/enumeration.</p>
<div class="section" id="declare-controllers">
<h3>Declare Controllers<a class="headerlink" href="#declare-controllers" title="Permalink to this headline">¶</a></h3>
<p>The first kind of information is a list of what SPI controllers exist.
For System-on-Chip (SOC) based boards, these will usually be platform
devices, and the controller may need some platform_data in order to
operate properly.  The “struct platform_device” will include resources
like the physical address of the controller’s first register and its IRQ.</p>
<p>Platforms will often abstract the “register SPI controller” operation,
maybe coupling it with code to initialize pin configurations, so that
the arch/…/mach-<em>/board-</em>.c files for several boards can all share the
same basic controller setup code.  This is because most SOCs have several
SPI-capable controllers, and only the ones actually usable on a given
board should normally be set up and registered.</p>
<p>So for example arch/…/mach-<em>/board-</em>.c files might have code like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;mach/spi.h&gt;   /* for mysoc_spi_data */

/* if your mach-* infrastructure doesn&#39;t support kernels that can
 * run on multiple boards, pdata wouldn&#39;t benefit from &quot;__init&quot;.
 */
static struct mysoc_spi_data pdata __initdata = { ... };

static __init board_init(void)
{
        ...
        /* this board only uses SPI controller #2 */
        mysoc_register_spi(2, &amp;pdata);
        ...
}
</pre></div>
</div>
<p>And SOC-specific utility code might look something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;mach/spi.h&gt;

static struct platform_device spi2 = { ... };

void mysoc_register_spi(unsigned n, struct mysoc_spi_data *pdata)
{
        struct mysoc_spi_data *pdata2;

        pdata2 = kmalloc(sizeof *pdata2, GFP_KERNEL);
        *pdata2 = pdata;
        ...
        if (n == 2) {
                spi2-&gt;dev.platform_data = pdata2;
                register_platform_device(&amp;spi2);

                /* also: set up pin modes so the spi2 signals are
                 * visible on the relevant pins ... bootloaders on
                 * production boards may already have done this, but
                 * developer boards will often need Linux to do it.
                 */
        }
        ...
}
</pre></div>
</div>
<p>Notice how the platform_data for boards may be different, even if the
same SOC controller is used.  For example, on one board SPI might use
an external clock, where another derives the SPI clock from current
settings of some master clock.</p>
</div>
<div class="section" id="declare-slave-devices">
<h3>Declare Slave Devices<a class="headerlink" href="#declare-slave-devices" title="Permalink to this headline">¶</a></h3>
<p>The second kind of information is a list of what SPI slave devices exist
on the target board, often with some board-specific data needed for the
driver to work correctly.</p>
<p>Normally your arch/…/mach-<em>/board-</em>.c files would provide a small table
listing the SPI devices on each board.  (This would typically be only a
small handful.)  That might look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ads7846_platform_data ads_info = {
        .vref_delay_usecs       = 100,
        .x_plate_ohms           = 580,
        .y_plate_ohms           = 410,
};

static struct spi_board_info spi_board_info[] __initdata = {
{
        .modalias       = &quot;ads7846&quot;,
        .platform_data  = &amp;ads_info,
        .mode           = SPI_MODE_0,
        .irq            = GPIO_IRQ(31),
        .max_speed_hz   = 120000 /* max sample rate at 3V */ * 16,
        .bus_num        = 1,
        .chip_select    = 0,
},
};
</pre></div>
</div>
<p>Again, notice how board-specific information is provided; each chip may need
several types.  This example shows generic constraints like the fastest SPI
clock to allow (a function of board voltage in this case) or how an IRQ pin
is wired, plus chip-specific constraints like an important delay that’s
changed by the capacitance at one pin.</p>
<p>(There’s also “controller_data”, information that may be useful to the
controller driver.  An example would be peripheral-specific DMA tuning
data or chipselect callbacks.  This is stored in spi_device later.)</p>
<p>The board_info should provide enough information to let the system work
without the chip’s driver being loaded.  The most troublesome aspect of
that is likely the SPI_CS_HIGH bit in the spi_device.mode field, since
sharing a bus with a device that interprets chipselect “backwards” is
not possible until the infrastructure knows how to deselect it.</p>
<p>Then your board initialization code would register that table with the SPI
infrastructure, so that it’s available later when the SPI master controller
driver is registered:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
</pre></div>
</div>
<p>Like with other static board-specific setup, you won’t unregister those.</p>
<p>The widely used “card” style computers bundle memory, cpu, and little else
onto a card that’s maybe just thirty square centimeters.  On such systems,
your <code class="docutils literal notranslate"><span class="pre">arch/.../mach-.../board-*.c</span></code> file would primarily provide information
about the devices on the mainboard into which such a card is plugged.  That
certainly includes SPI devices hooked up through the card connectors!</p>
</div>
<div class="section" id="non-static-configurations">
<h3>Non-static Configurations<a class="headerlink" href="#non-static-configurations" title="Permalink to this headline">¶</a></h3>
<p>Developer boards often play by different rules than product boards, and one
example is the potential need to hotplug SPI devices and/or controllers.</p>
<p>For those cases you might need to use <a class="reference internal" href="../driver-api/spi.html#c.spi_busnum_to_master" title="spi_busnum_to_master"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_busnum_to_master()</span></code></a> to look
up the spi bus master, and will likely need <a class="reference internal" href="../driver-api/spi.html#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_new_device()</span></code></a> to provide the
board info based on the board that was hotplugged.  Of course, you’d later
call at least <a class="reference internal" href="../driver-api/spi.html#c.spi_unregister_device" title="spi_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_unregister_device()</span></code></a> when that board is removed.</p>
<p>When Linux includes support for MMC/SD/SDIO/DataFlash cards through SPI, those
configurations will also be dynamic.  Fortunately, such devices all support
basic device identification probes, so they should hotplug normally.</p>
</div>
</div>
<div class="section" id="how-do-i-write-an-spi-protocol-driver">
<h2>How do I write an “SPI Protocol Driver”?<a class="headerlink" href="#how-do-i-write-an-spi-protocol-driver" title="Permalink to this headline">¶</a></h2>
<p>Most SPI drivers are currently kernel drivers, but there’s also support
for userspace drivers.  Here we talk only about kernel drivers.</p>
<p>SPI protocol drivers somewhat resemble platform device drivers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct spi_driver CHIP_driver = {
        .driver = {
                .name           = &quot;CHIP&quot;,
                .owner          = THIS_MODULE,
                .pm             = &amp;CHIP_pm_ops,
        },

        .probe          = CHIP_probe,
        .remove         = CHIP_remove,
};
</pre></div>
</div>
<p>The driver core will automatically attempt to bind this driver to any SPI
device whose board_info gave a modalias of “CHIP”.  Your probe() code
might look like this unless you’re creating a device which is managing
a bus (appearing under /sys/class/spi_master).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int CHIP_probe(struct spi_device *spi)
{
        struct CHIP                     *chip;
        struct CHIP_platform_data       *pdata;

        /* assuming the driver requires board-specific data: */
        pdata = &amp;spi-&gt;dev.platform_data;
        if (!pdata)
                return -ENODEV;

        /* get memory for driver&#39;s per-chip state */
        chip = kzalloc(sizeof *chip, GFP_KERNEL);
        if (!chip)
                return -ENOMEM;
        spi_set_drvdata(spi, chip);

        ... etc
        return 0;
}
</pre></div>
</div>
<p>As soon as it enters probe(), the driver may issue I/O requests to
the SPI device using “<a class="reference internal" href="../driver-api/spi.html#c.spi_message" title="spi_message"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span></code></a>”.  When remove() returns,
or after probe() fails, the driver guarantees that it won’t submit
any more such messages.</p>
<blockquote>
<div><ul>
<li><p>An spi_message is a sequence of protocol operations, executed
as one atomic sequence.  SPI driver controls include:</p>
<blockquote>
<div><ul class="simple">
<li><p>when bidirectional reads and writes start … by how its
sequence of spi_transfer requests is arranged;</p></li>
<li><p>which I/O buffers are used … each spi_transfer wraps a
buffer for each transfer direction, supporting full duplex
(two pointers, maybe the same one in both cases) and half
duplex (one pointer is NULL) transfers;</p></li>
<li><p>optionally defining short delays after transfers … using
the spi_transfer.delay_usecs setting (this delay can be the
only protocol effect, if the buffer length is zero);</p></li>
<li><p>whether the chipselect becomes inactive after a transfer and
any delay … by using the spi_transfer.cs_change flag;</p></li>
<li><p>hinting whether the next message is likely to go to this same
device … using the spi_transfer.cs_change flag on the last
transfer in that atomic group, and potentially saving costs
for chip deselect and select operations.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Follow standard kernel rules, and provide DMA-safe buffers in
your messages.  That way controller drivers using DMA aren’t forced
to make extra copies unless the hardware requires it (e.g. working
around hardware errata that force the use of bounce buffering).</p>
<p>If standard dma_map_single() handling of these buffers is inappropriate,
you can use spi_message.is_dma_mapped to tell the controller driver
that you’ve already provided the relevant DMA addresses.</p>
</li>
<li><p>The basic I/O primitive is <a class="reference internal" href="../driver-api/spi.html#c.spi_async" title="spi_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_async()</span></code></a>.  Async requests may be
issued in any context (irq handler, task, etc) and completion
is reported using a callback provided with the message.
After any detected error, the chip is deselected and processing
of that spi_message is aborted.</p></li>
<li><p>There are also synchronous wrappers like <a class="reference internal" href="../driver-api/spi.html#c.spi_sync" title="spi_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_sync()</span></code></a>, and wrappers
like <a class="reference internal" href="../driver-api/spi.html#c.spi_read" title="spi_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_read()</span></code></a>, <a class="reference internal" href="../driver-api/spi.html#c.spi_write" title="spi_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_write()</span></code></a>, and <a class="reference internal" href="../driver-api/spi.html#c.spi_write_then_read" title="spi_write_then_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_write_then_read()</span></code></a>.  These
may be issued only in contexts that may sleep, and they’re all
clean (and small, and “optional”) layers over <a class="reference internal" href="../driver-api/spi.html#c.spi_async" title="spi_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_async()</span></code></a>.</p></li>
<li><p>The <a class="reference internal" href="../driver-api/spi.html#c.spi_write_then_read" title="spi_write_then_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_write_then_read()</span></code></a> call, and convenience wrappers around
it, should only be used with small amounts of data where the
cost of an extra copy may be ignored.  It’s designed to support
common RPC-style requests, such as writing an eight bit command
and reading a sixteen bit response – <a class="reference internal" href="../driver-api/spi.html#c.spi_w8r16" title="spi_w8r16"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_w8r16()</span></code></a> being one its
wrappers, doing exactly that.</p></li>
</ul>
</div></blockquote>
<p>Some drivers may need to modify spi_device characteristics like the
transfer mode, wordsize, or clock rate.  This is done with <a class="reference internal" href="../driver-api/spi.html#c.spi_setup" title="spi_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_setup()</span></code></a>,
which would normally be called from probe() before the first I/O is
done to the device.  However, that can also be called at any time
that no message is pending for that device.</p>
<p>While “spi_device” would be the bottom boundary of the driver, the
upper boundaries might include sysfs (especially for sensor readings),
the input layer, ALSA, networking, MTD, the character device framework,
or other Linux subsystems.</p>
<p>Note that there are two types of memory your driver must manage as part
of interacting with SPI devices.</p>
<blockquote>
<div><ul class="simple">
<li><p>I/O buffers use the usual Linux rules, and must be DMA-safe.
You’d normally allocate them from the heap or free page pool.
Don’t use the stack, or anything that’s declared “static”.</p></li>
<li><p>The spi_message and spi_transfer metadata used to glue those
I/O buffers into a group of protocol transactions.  These can
be allocated anywhere it’s convenient, including as part of
other allocate-once driver data structures.  Zero-init these.</p></li>
</ul>
</div></blockquote>
<p>If you like, spi_message_alloc() and spi_message_free() convenience
routines are available to allocate and zero-initialize an spi_message
with several transfers.</p>
</div>
<div class="section" id="how-do-i-write-an-spi-master-controller-driver">
<h2>How do I write an “SPI Master Controller Driver”?<a class="headerlink" href="#how-do-i-write-an-spi-master-controller-driver" title="Permalink to this headline">¶</a></h2>
<p>An SPI controller will probably be registered on the platform_bus; write
a driver to bind to the device, whichever bus is involved.</p>
<p>The main task of this type of driver is to provide an “spi_master”.
Use spi_alloc_master() to allocate the master, and spi_master_get_devdata()
to get the driver-private data allocated for that device.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_master       *master;
struct CONTROLLER       *c;

master = spi_alloc_master(dev, sizeof *c);
if (!master)
        return -ENODEV;

c = spi_master_get_devdata(master);
</pre></div>
</div>
<p>The driver will initialize the fields of that spi_master, including the
bus number (maybe the same as the platform device ID) and three methods
used to interact with the SPI core and SPI protocol drivers.  It will
also initialize its own internal state.  (See below about bus numbering
and those methods.)</p>
<p>After you initialize the spi_master, then use spi_register_master() to
publish it to the rest of the system. At that time, device nodes for the
controller and any predeclared spi devices will be made available, and
the driver model core will take care of binding them to drivers.</p>
<p>If you need to remove your SPI controller driver, spi_unregister_master()
will reverse the effect of spi_register_master().</p>
<div class="section" id="bus-numbering">
<h3>Bus Numbering<a class="headerlink" href="#bus-numbering" title="Permalink to this headline">¶</a></h3>
<p>Bus numbering is important, since that’s how Linux identifies a given
SPI bus (shared SCK, MOSI, MISO).  Valid bus numbers start at zero.  On
SOC systems, the bus numbers should match the numbers defined by the chip
manufacturer.  For example, hardware controller SPI2 would be bus number 2,
and spi_board_info for devices connected to it would use that number.</p>
<p>If you don’t have such hardware-assigned bus number, and for some reason
you can’t just assign them, then provide a negative bus number.  That will
then be replaced by a dynamically assigned number. You’d then need to treat
this as a non-static configuration (see above).</p>
</div>
<div class="section" id="spi-master-methods">
<h3>SPI Master Methods<a class="headerlink" href="#spi-master-methods" title="Permalink to this headline">¶</a></h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;setup(struct</span> <span class="pre">spi_device</span> <span class="pre">*spi)</span></code></dt><dd><p>This sets up the device clock rate, SPI mode, and word sizes.
Drivers may change the defaults provided by board_info, and then
call spi_setup(spi) to invoke this routine.  It may sleep.</p>
<p>Unless each SPI slave has its own configuration registers, don’t
change them right away … otherwise drivers could corrupt I/O
that’s in progress for other SPI devices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BUG ALERT:  for some reason the first version of
many spi_master drivers seems to get this wrong.
When you code setup(), ASSUME that the controller
is actively processing transfers for another device.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;cleanup(struct</span> <span class="pre">spi_device</span> <span class="pre">*spi)</span></code></dt><dd><p>Your controller driver may use spi_device.controller_state to hold
state it dynamically associates with that device.  If you do that,
be sure to provide the cleanup() method to free that state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;prepare_transfer_hardware(struct</span> <span class="pre">spi_master</span> <span class="pre">*master)</span></code></dt><dd><p>This will be called by the queue mechanism to signal to the driver
that a message is coming in soon, so the subsystem requests the
driver to prepare the transfer hardware by issuing this call.
This may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;unprepare_transfer_hardware(struct</span> <span class="pre">spi_master</span> <span class="pre">*master)</span></code></dt><dd><p>This will be called by the queue mechanism to signal to the driver
that there are no more messages pending in the queue and it may
relax the hardware (e.g. by power management calls). This may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;transfer_one_message(struct</span> <span class="pre">spi_master</span> <span class="pre">*master,</span> <span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*mesg)</span></code></dt><dd><p>The subsystem calls the driver to transfer a single message while
queuing transfers that arrive in the meantime. When the driver is
finished with this message, it must call
<a class="reference internal" href="../driver-api/spi.html#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_message()</span></code></a> so the subsystem can issue the next
message. This may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;transfer_one(struct</span> <span class="pre">spi_master</span> <span class="pre">*master,</span> <span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi,</span> <span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*transfer)</span></code></dt><dd><p>The subsystem calls the driver to transfer a single transfer while
queuing transfers that arrive in the meantime. When the driver is
finished with this transfer, it must call
<a class="reference internal" href="../driver-api/spi.html#c.spi_finalize_current_transfer" title="spi_finalize_current_transfer"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_transfer()</span></code></a> so the subsystem can issue the next
transfer. This may sleep. Note: transfer_one and transfer_one_message
are mutually exclusive; when both are set, the generic subsystem does
not call your transfer_one callback.</p>
<p>Return values:</p>
<ul class="simple">
<li><p>negative errno: error</p></li>
<li><p>0: transfer is finished</p></li>
<li><p>1: transfer is still in progress</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;set_cs_timing(struct</span> <span class="pre">spi_device</span> <span class="pre">*spi,</span> <span class="pre">u8</span> <span class="pre">setup_clk_cycles,</span> <span class="pre">u8</span> <span class="pre">hold_clk_cycles,</span> <span class="pre">u8</span> <span class="pre">inactive_clk_cycles)</span></code></dt><dd><p>This method allows SPI client drivers to request SPI master controller
for configuring device specific CS setup, hold and inactive timing
requirements.</p>
</dd>
</dl>
</div>
<div class="section" id="deprecated-methods">
<h3>Deprecated Methods<a class="headerlink" href="#deprecated-methods" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">master-&gt;transfer(struct</span> <span class="pre">spi_device</span> <span class="pre">*spi,</span> <span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*message)</span></code></dt><dd><p>This must not sleep. Its responsibility is to arrange that the
transfer happens and its complete() callback is issued. The two
will normally happen later, after other transfers complete, and
if the controller is idle it will need to be kickstarted. This
method is not used on queued controllers and must be NULL if
transfer_one_message() and (un)prepare_transfer_hardware() are
implemented.</p>
</dd>
</dl>
</div>
<div class="section" id="spi-message-queue">
<h3>SPI Message Queue<a class="headerlink" href="#spi-message-queue" title="Permalink to this headline">¶</a></h3>
<p>If you are happy with the standard queueing mechanism provided by the
SPI subsystem, just implement the queued methods specified above. Using
the message queue has the upside of centralizing a lot of code and
providing pure process-context execution of methods. The message queue
can also be elevated to realtime priority on high-priority SPI traffic.</p>
<p>Unless the queueing mechanism in the SPI subsystem is selected, the bulk
of the driver will be managing the I/O queue fed by the now deprecated
function transfer().</p>
<p>That queue could be purely conceptual.  For example, a driver used only
for low-frequency sensor access might be fine using synchronous PIO.</p>
<p>But the queue will probably be very real, using message-&gt;queue, PIO,
often DMA (especially if the root filesystem is in SPI flash), and
execution contexts like IRQ handlers, tasklets, or workqueues (such
as keventd).  Your driver can be as fancy, or as simple, as you need.
Such a transfer() method would normally just add the message to a
queue, and then start some asynchronous transfer engine (unless it’s
already running).</p>
</div>
</div>
<div class="section" id="thanks-to">
<h2>THANKS TO<a class="headerlink" href="#thanks-to" title="Permalink to this headline">¶</a></h2>
<p>Contributors to Linux-SPI discussions include (in alphabetical order,
by last name):</p>
<ul class="simple">
<li><p>Mark Brown</p></li>
<li><p>David Brownell</p></li>
<li><p>Russell King</p></li>
<li><p>Grant Likely</p></li>
<li><p>Dmitry Pervushin</p></li>
<li><p>Stephen Street</p></li>
<li><p>Mark Underwood</p></li>
<li><p>Andrew Victor</p></li>
<li><p>Linus Walleij</p></li>
<li><p>Vitaly Wool</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="spidev.html" class="btn btn-neutral float-right" title="SPI userspace API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="Serial Peripheral Interface (SPI)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>