

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>LIBNVDIMM: Non-Volatile Devices &mdash; The Linux Kernel 5.11.0-rc6+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="BTT - Block Translation Table" href="btt.html" />
    <link rel="prev" title="Non-Volatile Memory Device (NVDIMM)" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0-rc6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Non-Volatile Memory Device (NVDIMM)</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">LIBNVDIMM: Non-Volatile Devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#glossary">Glossary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#libnvdimm-pmem-and-blk">LIBNVDIMM PMEM and BLK</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-blk">Why BLK?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-nvdimm-platform">Example NVDIMM Platform</a></li>
<li class="toctree-l4"><a class="reference internal" href="#libnvdimm-kernel-device-model-and-libndctl-userspace-api">LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="btt.html">BTT - Block Translation Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="security.html">NVDIMM Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware-activate.html">NVDIMM Runtime Firmware Activation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Non-Volatile Memory Device (NVDIMM)</a> &raquo;</li>
        
      <li>LIBNVDIMM: Non-Volatile Devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/nvdimm/nvdimm.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="libnvdimm-non-volatile-devices">
<h1>LIBNVDIMM: Non-Volatile Devices<a class="headerlink" href="#libnvdimm-non-volatile-devices" title="Permalink to this headline">¶</a></h1>
<p>libnvdimm - kernel / libndctl - userspace helper library</p>
<p><a class="reference external" href="mailto:linux-nvdimm&#37;&#52;&#48;lists&#46;01&#46;org">linux-nvdimm<span>&#64;</span>lists<span>&#46;</span>01<span>&#46;</span>org</a></p>
<p>Version 13</p>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>PMEM:</dt><dd><p>A system-physical-address range where writes are persistent.  A
block device composed of PMEM is capable of DAX.  A PMEM address range
may span an interleave of several DIMMs.</p>
</dd>
<dt>BLK:</dt><dd><p>A set of one or more programmable memory mapped apertures provided
by a DIMM to access its media.  This indirection precludes the
performance benefit of interleaving, but enables DIMM-bounded failure
modes.</p>
</dd>
<dt>DPA:</dt><dd><p>DIMM Physical Address, is a DIMM-relative offset.  With one DIMM in
the system there would be a 1:1 system-physical-address:DPA association.
Once more DIMMs are added a memory controller interleave must be
decoded to determine the DPA associated with a given
system-physical-address.  BLK capacity always has a 1:1 relationship
with a single-DIMM’s DPA range.</p>
</dd>
<dt>DAX:</dt><dd><p>File system extensions to bypass the page cache and block layer to
mmap persistent memory, from a PMEM block device, directly into a
process address space.</p>
</dd>
<dt>DSM:</dt><dd><p>Device Specific Method: ACPI method to control specific
device - in this case the firmware.</p>
</dd>
<dt>DCR:</dt><dd><p>NVDIMM Control Region Structure defined in ACPI 6 Section 5.2.25.5.
It defines a vendor-id, device-id, and interface format for a given DIMM.</p>
</dd>
<dt>BTT:</dt><dd><p>Block Translation Table: Persistent memory is byte addressable.
Existing software may have an expectation that the power-fail-atomicity
of writes is at least one sector, 512 bytes.  The BTT is an indirection
table with atomic update semantics to front a PMEM/BLK block device
driver and present arbitrary atomic sector sizes.</p>
</dd>
<dt>LABEL:</dt><dd><p>Metadata stored on a DIMM device that partitions and identifies
(persistently names) storage between PMEM and BLK.  It also partitions
BLK storage to host BTTs with different parameters per BLK-partition.
Note that traditional partition tables, GPT/MBR, are layered on top of a
BLK or PMEM device.</p>
</dd>
</dl>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The LIBNVDIMM subsystem provides support for three types of NVDIMMs, namely,
PMEM, BLK, and NVDIMM devices that can simultaneously support both PMEM
and BLK mode access.  These three modes of operation are described by
the “NVDIMM Firmware Interface Table” (NFIT) in ACPI 6.  While the LIBNVDIMM
implementation is generic and supports pre-NFIT platforms, it was guided
by the superset of capabilities need to support this ACPI 6 definition
for NVDIMM resources.  The bulk of the kernel implementation is in place
to handle the case where DPA accessible via PMEM is aliased with DPA
accessible via BLK.  When that occurs a LABEL is needed to reserve DPA
for exclusive access via one mode a time.</p>
<div class="section" id="supporting-documents">
<h3>Supporting Documents<a class="headerlink" href="#supporting-documents" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>ACPI 6:</dt><dd><p><a class="reference external" href="https://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf">https://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf</a></p>
</dd>
<dt>NVDIMM Namespace:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_Namespace_Spec.pdf">https://pmem.io/documents/NVDIMM_Namespace_Spec.pdf</a></p>
</dd>
<dt>DSM Interface Example:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf">https://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf</a></p>
</dd>
<dt>Driver Writer’s Guide:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf">https://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf</a></p>
</dd>
</dl>
</div>
<div class="section" id="git-trees">
<h3>Git Trees<a class="headerlink" href="#git-trees" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>LIBNVDIMM:</dt><dd><p><a class="reference external" href="https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git">https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git</a></p>
</dd>
<dt>LIBNDCTL:</dt><dd><p><a class="reference external" href="https://github.com/pmem/ndctl.git">https://github.com/pmem/ndctl.git</a></p>
</dd>
<dt>PMEM:</dt><dd><p><a class="reference external" href="https://github.com/01org/prd">https://github.com/01org/prd</a></p>
</dd>
</dl>
</div>
</div>
<div class="section" id="libnvdimm-pmem-and-blk">
<h2>LIBNVDIMM PMEM and BLK<a class="headerlink" href="#libnvdimm-pmem-and-blk" title="Permalink to this headline">¶</a></h2>
<p>Prior to the arrival of the NFIT, non-volatile memory was described to a
system in various ad-hoc ways.  Usually only the bare minimum was
provided, namely, a single system-physical-address range where writes
are expected to be durable after a system power loss.  Now, the NFIT
specification standardizes not only the description of PMEM, but also
BLK and platform message-passing entry points for control and
configuration.</p>
<p>For each NVDIMM access method (PMEM, BLK), LIBNVDIMM provides a block
device driver:</p>
<blockquote>
<div><ol class="arabic">
<li><p>PMEM (nd_pmem.ko): Drives a system-physical-address range.  This
range is contiguous in system memory and may be interleaved (hardware
memory controller striped) across multiple DIMMs.  When interleaved the
platform may optionally provide details of which DIMMs are participating
in the interleave.</p>
<p>Note that while LIBNVDIMM describes system-physical-address ranges that may
alias with BLK access as ND_NAMESPACE_PMEM ranges and those without
alias as ND_NAMESPACE_IO ranges, to the nd_pmem driver there is no
distinction.  The different device-types are an implementation detail
that userspace can exploit to implement policies like “only interface
with address ranges from certain DIMMs”.  It is worth noting that when
aliasing is present and a DIMM lacks a label, then no block device can
be created by default as userspace needs to do at least one allocation
of DPA to the PMEM range.  In contrast ND_NAMESPACE_IO ranges, once
registered, can be immediately attached to nd_pmem.</p>
</li>
<li><p>BLK (nd_blk.ko): This driver performs I/O using a set of platform
defined apertures.  A set of apertures will access just one DIMM.
Multiple windows (apertures) allow multiple concurrent accesses, much like
tagged-command-queuing, and would likely be used by different threads or
different CPUs.</p>
<p>The NFIT specification defines a standard format for a BLK-aperture, but
the spec also allows for vendor specific layouts, and non-NFIT BLK
implementations may have other designs for BLK I/O.  For this reason
“nd_blk” calls back into platform-specific code to perform the I/O.</p>
<p>One such implementation is defined in the “Driver Writer’s Guide” and “DSM
Interface Example”.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="why-blk">
<h2>Why BLK?<a class="headerlink" href="#why-blk" title="Permalink to this headline">¶</a></h2>
<p>While PMEM provides direct byte-addressable CPU-load/store access to
NVDIMM storage, it does not provide the best system RAS (recovery,
availability, and serviceability) model.  An access to a corrupted
system-physical-address address causes a CPU exception while an access
to a corrupted address through an BLK-aperture causes that block window
to raise an error status in a register.  The latter is more aligned with
the standard error model that host-bus-adapter attached disks present.</p>
<p>Also, if an administrator ever wants to replace a memory it is easier to
service a system at DIMM module boundaries.  Compare this to PMEM where
data could be interleaved in an opaque hardware specific manner across
several DIMMs.</p>
<div class="section" id="pmem-vs-blk">
<h3>PMEM vs BLK<a class="headerlink" href="#pmem-vs-blk" title="Permalink to this headline">¶</a></h3>
<p>BLK-apertures solve these RAS problems, but their presence is also the
major contributing factor to the complexity of the ND subsystem.  They
complicate the implementation because PMEM and BLK alias in DPA space.
Any given DIMM’s DPA-range may contribute to one or more
system-physical-address sets of interleaved DIMMs, <em>and</em> may also be
accessed in its entirety through its BLK-aperture.  Accessing a DPA
through a system-physical-address while simultaneously accessing the
same DPA through a BLK-aperture has undefined results.  For this reason,
DIMMs with this dual interface configuration include a DSM function to
store/retrieve a LABEL.  The LABEL effectively partitions the DPA-space
into exclusive system-physical-address and BLK-aperture accessible
regions.  For simplicity a DIMM is allowed a PMEM “region” per each
interleave set in which it is a member.  The remaining DPA space can be
carved into an arbitrary number of BLK devices with discontiguous
extents.</p>
<div class="section" id="blk-regions-pmem-regions-atomic-sectors-and-dax">
<h4>BLK-REGIONs, PMEM-REGIONs, Atomic Sectors, and DAX<a class="headerlink" href="#blk-regions-pmem-regions-atomic-sectors-and-dax" title="Permalink to this headline">¶</a></h4>
<p>One of the few
reasons to allow multiple BLK namespaces per REGION is so that each
BLK-namespace can be configured with a BTT with unique atomic sector
sizes.  While a PMEM device can host a BTT the LABEL specification does
not provide for a sector size to be specified for a PMEM namespace.</p>
<p>This is due to the expectation that the primary usage model for PMEM is
via DAX, and the BTT is incompatible with DAX.  However, for the cases
where an application or filesystem still needs atomic sector update
guarantees it can register a BTT on a PMEM device or partition.  See
LIBNVDIMM/NDCTL: Block Translation Table “btt”</p>
</div>
</div>
</div>
<div class="section" id="example-nvdimm-platform">
<h2>Example NVDIMM Platform<a class="headerlink" href="#example-nvdimm-platform" title="Permalink to this headline">¶</a></h2>
<p>For the remainder of this document the following diagram will be
referenced for any example sysfs layouts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                             (a)               (b)           DIMM   BLK-REGION
          +-------------------+--------+--------+--------+
+------+  |       pm0.0       | blk2.0 | pm1.0  | blk2.1 |    0      region2
| imc0 +--+- - - region0- - - +--------+        +--------+
+--+---+  |       pm0.0       | blk3.0 | pm1.0  | blk3.1 |    1      region3
   |      +-------------------+--------v        v--------+
+--+---+                               |                 |
| cpu0 |                                     region1
+--+---+                               |                 |
   |      +----------------------------^        ^--------+
+--+---+  |           blk4.0           | pm1.0  | blk4.0 |    2      region4
| imc1 +--+----------------------------|        +--------+
+------+  |           blk5.0           | pm1.0  | blk5.0 |    3      region5
          +----------------------------+--------+--------+
</pre></div>
</div>
<p>In this platform we have four DIMMs and two memory controllers in one
socket.  Each unique interface (BLK or PMEM) to DPA space is identified
by a region device with a dynamically assigned id (REGION0 - REGION5).</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The first portion of DIMM0 and DIMM1 are interleaved as REGION0. A
single PMEM namespace is created in the REGION0-SPA-range that spans most
of DIMM0 and DIMM1 with a user-specified name of “pm0.0”. Some of that
interleaved system-physical-address range is reclaimed as BLK-aperture
accessed space starting at DPA-offset (a) into each DIMM.  In that
reclaimed space we create two BLK-aperture “namespaces” from REGION2 and
REGION3 where “blk2.0” and “blk3.0” are just human readable names that
could be set to any user-desired name in the LABEL.</p></li>
<li><p>In the last portion of DIMM0 and DIMM1 we have an interleaved
system-physical-address range, REGION1, that spans those two DIMMs as
well as DIMM2 and DIMM3.  Some of REGION1 is allocated to a PMEM namespace
named “pm1.0”, the rest is reclaimed in 4 BLK-aperture namespaces (for
each DIMM in the interleave set), “blk2.1”, “blk3.1”, “blk4.0”, and
“blk5.0”.</p></li>
<li><p>The portion of DIMM2 and DIMM3 that do not participate in the REGION1
interleaved system-physical-address range (i.e. the DPA address past
offset (b) are also included in the “blk4.0” and “blk5.0” namespaces.
Note, that this example shows that BLK-aperture namespaces don’t need to
be contiguous in DPA-space.</p></li>
</ol>
<p>This bus is provided by the kernel under the device
/sys/devices/platform/nfit_test.0 when the nfit_test.ko module from
tools/testing/nvdimm is loaded.  This not only test LIBNVDIMM but the
acpi_nfit.ko driver as well.</p>
</div></blockquote>
</div>
<div class="section" id="libnvdimm-kernel-device-model-and-libndctl-userspace-api">
<h2>LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API<a class="headerlink" href="#libnvdimm-kernel-device-model-and-libndctl-userspace-api" title="Permalink to this headline">¶</a></h2>
<p>What follows is a description of the LIBNVDIMM sysfs layout and a
corresponding object hierarchy diagram as viewed through the LIBNDCTL
API.  The example sysfs paths and diagrams are relative to the Example
NVDIMM Platform which is also the LIBNVDIMM bus used in the LIBNDCTL unit
test.</p>
<div class="section" id="libndctl-context">
<h3>LIBNDCTL: Context<a class="headerlink" href="#libndctl-context" title="Permalink to this headline">¶</a></h3>
<p>Every API call in the LIBNDCTL library requires a context that holds the
logging parameters and other library instance state.  The library is
based on the libabc template:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git">https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git</a></p>
</div></blockquote>
<div class="section" id="libndctl-instantiate-a-new-library-context-example">
<h4>LIBNDCTL: instantiate a new library context example<a class="headerlink" href="#libndctl-instantiate-a-new-library-context-example" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ndctl_ctx *ctx;

if (ndctl_new(&amp;ctx) == 0)
        return ctx;
else
        return NULL;
</pre></div>
</div>
</div>
</div>
<div class="section" id="libnvdimm-libndctl-bus">
<h3>LIBNVDIMM/LIBNDCTL: Bus<a class="headerlink" href="#libnvdimm-libndctl-bus" title="Permalink to this headline">¶</a></h3>
<p>A bus has a 1:1 relationship with an NFIT.  The current expectation for
ACPI based systems is that there is only ever one platform-global NFIT.
That said, it is trivial to register multiple NFITs, the specification
does not preclude it.  The infrastructure supports multiple busses and
we use this capability to test multiple NFIT configurations in the unit
test.</p>
</div>
<div class="section" id="libnvdimm-control-class-device-in-sys-class">
<h3>LIBNVDIMM: control class device in /sys/class<a class="headerlink" href="#libnvdimm-control-class-device-in-sys-class" title="Permalink to this headline">¶</a></h3>
<p>This character device accepts DSM messages to be passed to DIMM
identified by its NFIT handle:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/nd/ndctl0
|-- dev
|-- device -&gt; ../../../ndbus0
|-- subsystem -&gt; ../../../../../../../class/nd
</pre></div>
</div>
</div>
<div class="section" id="libnvdimm-bus">
<h3>LIBNVDIMM: bus<a class="headerlink" href="#libnvdimm-bus" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvdimm_bus *nvdimm_bus_register(struct device *parent,
       struct nvdimm_bus_descriptor *nfit_desc);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- commands
|-- nd
|-- nfit
|-- nmem0
|-- nmem1
|-- nmem2
|-- nmem3
|-- power
|-- provider
|-- region0
|-- region1
|-- region2
|-- region3
|-- region4
|-- region5
|-- uevent
`-- wait_probe
</pre></div>
</div>
<div class="section" id="libndctl-bus-enumeration-example">
<h4>LIBNDCTL: bus enumeration example<a class="headerlink" href="#libndctl-bus-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Find the bus handle that describes the bus from Example NVDIMM Platform:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_bus *get_bus_by_provider(struct ndctl_ctx *ctx,
                const char *provider)
{
        struct ndctl_bus *bus;

        ndctl_bus_foreach(ctx, bus)
                if (strcmp(provider, ndctl_bus_get_provider(bus)) == 0)
                        return bus;

        return NULL;
}

bus = get_bus_by_provider(ctx, &quot;nfit_test.0&quot;);
</pre></div>
</div>
</div>
</div>
<div class="section" id="libnvdimm-libndctl-dimm-nmem">
<h3>LIBNVDIMM/LIBNDCTL: DIMM (NMEM)<a class="headerlink" href="#libnvdimm-libndctl-dimm-nmem" title="Permalink to this headline">¶</a></h3>
<p>The DIMM device provides a character device for sending commands to
hardware, and it is a container for LABELs.  If the DIMM is defined by
NFIT then an optional ‘nfit’ attribute sub-directory is available to add
NFIT-specifics.</p>
<p>Note that the kernel device name for “DIMMs” is “nmemX”.  The NFIT
describes these devices via “Memory Device to System Physical Address
Range Mapping Structure”, and there is no requirement that they actually
be physical DIMMs, so we use a more generic name.</p>
<div class="section" id="libnvdimm-dimm-nmem">
<h4>LIBNVDIMM: DIMM (NMEM)<a class="headerlink" href="#libnvdimm-dimm-nmem" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvdimm *nvdimm_create(struct nvdimm_bus *nvdimm_bus, void *provider_data,
                const struct attribute_group **groups, unsigned long flags,
                unsigned long *dsm_mask);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- nmem0
|   |-- available_slots
|   |-- commands
|   |-- dev
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nvdimm
|   |-- modalias
|   |-- nfit
|   |   |-- device
|   |   |-- format
|   |   |-- handle
|   |   |-- phys_id
|   |   |-- rev_id
|   |   |-- serial
|   |   `-- vendor
|   |-- state
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- nmem1
[..]
</pre></div>
</div>
</div>
<div class="section" id="libndctl-dimm-enumeration-example">
<h4>LIBNDCTL: DIMM enumeration example<a class="headerlink" href="#libndctl-dimm-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Note, in this example we are assuming NFIT-defined DIMMs which are
identified by an “nfit_handle” a 32-bit value where:</p>
<blockquote>
<div><ul class="simple">
<li><p>Bit 3:0 DIMM number within the memory channel</p></li>
<li><p>Bit 7:4 memory channel number</p></li>
<li><p>Bit 11:8 memory controller ID</p></li>
<li><p>Bit 15:12 socket ID (within scope of a Node controller if node
controller is present)</p></li>
<li><p>Bit 27:16 Node Controller ID</p></li>
<li><p>Bit 31:28 Reserved</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_dimm *get_dimm_by_handle(struct ndctl_bus *bus,
       unsigned int handle)
{
        struct ndctl_dimm *dimm;

        ndctl_dimm_foreach(bus, dimm)
                if (ndctl_dimm_get_handle(dimm) == handle)
                        return dimm;

        return NULL;
}

#define DIMM_HANDLE(n, s, i, c, d) \
        (((n &amp; 0xfff) &lt;&lt; 16) | ((s &amp; 0xf) &lt;&lt; 12) | ((i &amp; 0xf) &lt;&lt; 8) \
         | ((c &amp; 0xf) &lt;&lt; 4) | (d &amp; 0xf))

dimm = get_dimm_by_handle(bus, DIMM_HANDLE(0, 0, 0, 0, 0));
</pre></div>
</div>
</div>
</div>
<div class="section" id="libnvdimm-libndctl-region">
<h3>LIBNVDIMM/LIBNDCTL: Region<a class="headerlink" href="#libnvdimm-libndctl-region" title="Permalink to this headline">¶</a></h3>
<p>A generic REGION device is registered for each PMEM range or BLK-aperture
set.  Per the example there are 6 regions: 2 PMEM and 4 BLK-aperture
sets on the “nfit_test.0” bus.  The primary role of regions are to be a
container of “mappings”.  A mapping is a tuple of &lt;DIMM,
DPA-start-offset, length&gt;.</p>
<p>LIBNVDIMM provides a built-in driver for these REGION devices.  This driver
is responsible for reconciling the aliased DPA mappings across all
regions, parsing the LABEL, if present, and then emitting NAMESPACE
devices with the resolved/exclusive DPA-boundaries for the nd_pmem or
nd_blk device driver to consume.</p>
<p>In addition to the generic attributes of “mapping”s, “interleave_ways”
and “size” the REGION device also exports some convenience attributes.
“nstype” indicates the integer type of namespace-device this region
emits, “devtype” duplicates the DEVTYPE variable stored by udev at the
‘add’ event, “modalias” duplicates the MODALIAS variable stored by udev
at the ‘add’ event, and finally, the optional “spa_index” is provided in
the case where the region is defined by a SPA.</p>
<p>LIBNVDIMM: region:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,
                struct nd_region_desc *ndr_desc);
struct nd_region *nvdimm_blk_region_create(struct nvdimm_bus *nvdimm_bus,
                struct nd_region_desc *ndr_desc);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- region0
|   |-- available_size
|   |-- btt0
|   |-- btt_seed
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nd_region
|   |-- init_namespaces
|   |-- mapping0
|   |-- mapping1
|   |-- mappings
|   |-- modalias
|   |-- namespace0.0
|   |-- namespace_seed
|   |-- numa_node
|   |-- nfit
|   |   `-- spa_index
|   |-- nstype
|   |-- set_cookie
|   |-- size
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- region1
[..]
</pre></div>
</div>
<div class="section" id="libndctl-region-enumeration-example">
<h4>LIBNDCTL: region enumeration example<a class="headerlink" href="#libndctl-region-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Sample region retrieval routines based on NFIT-unique data like
“spa_index” (interleave set id) for PMEM and “nfit_handle” (dimm id) for
BLK:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_region *get_pmem_region_by_spa_index(struct ndctl_bus *bus,
                unsigned int spa_index)
{
        struct ndctl_region *region;

        ndctl_region_foreach(bus, region) {
                if (ndctl_region_get_type(region) != ND_DEVICE_REGION_PMEM)
                        continue;
                if (ndctl_region_get_spa_index(region) == spa_index)
                        return region;
        }
        return NULL;
}

static struct ndctl_region *get_blk_region_by_dimm_handle(struct ndctl_bus *bus,
                unsigned int handle)
{
        struct ndctl_region *region;

        ndctl_region_foreach(bus, region) {
                struct ndctl_mapping *map;

                if (ndctl_region_get_type(region) != ND_DEVICE_REGION_BLOCK)
                        continue;
                ndctl_mapping_foreach(region, map) {
                        struct ndctl_dimm *dimm = ndctl_mapping_get_dimm(map);

                        if (ndctl_dimm_get_handle(dimm) == handle)
                                return region;
                }
        }
        return NULL;
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="why-not-encode-the-region-type-into-the-region-name">
<h3>Why Not Encode the Region Type into the Region Name?<a class="headerlink" href="#why-not-encode-the-region-type-into-the-region-name" title="Permalink to this headline">¶</a></h3>
<p>At first glance it seems since NFIT defines just PMEM and BLK interface
types that we should simply name REGION devices with something derived
from those type names.  However, the ND subsystem explicitly keeps the
REGION name generic and expects userspace to always consider the
region-attributes for four reasons:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>There are already more than two REGION and “namespace” types.  For
PMEM there are two subtypes.  As mentioned previously we have PMEM where
the constituent DIMM devices are known and anonymous PMEM.  For BLK
regions the NFIT specification already anticipates vendor specific
implementations.  The exact distinction of what a region contains is in
the region-attributes not the region-name or the region-devtype.</p></li>
<li><p>A region with zero child-namespaces is a possible configuration.  For
example, the NFIT allows for a DCR to be published without a
corresponding BLK-aperture.  This equates to a DIMM that can only accept
control/configuration messages, but no i/o through a descendant block
device.  Again, this “type” is advertised in the attributes (‘mappings’
== 0) and the name does not tell you much.</p></li>
<li><p>What if a third major interface type arises in the future?  Outside
of vendor specific implementations, it’s not difficult to envision a
third class of interface type beyond BLK and PMEM.  With a generic name
for the REGION level of the device-hierarchy old userspace
implementations can still make sense of new kernel advertised
region-types.  Userspace can always rely on the generic region
attributes like “mappings”, “size”, etc and the expected child devices
named “namespace”.  This generic format of the device-model hierarchy
allows the LIBNVDIMM and LIBNDCTL implementations to be more uniform and
future-proof.</p></li>
<li><p>There are more robust mechanisms for determining the major type of a
region than a device name.  See the next section, How Do I Determine the
Major Type of a Region?</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="how-do-i-determine-the-major-type-of-a-region">
<h3>How Do I Determine the Major Type of a Region?<a class="headerlink" href="#how-do-i-determine-the-major-type-of-a-region" title="Permalink to this headline">¶</a></h3>
<p>Outside of the blanket recommendation of “use libndctl”, or simply
looking at the kernel header (/usr/include/linux/ndctl.h) to decode the
“nstype” integer attribute, here are some other options.</p>
<div class="section" id="module-alias-lookup">
<h4>1. module alias lookup<a class="headerlink" href="#module-alias-lookup" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The whole point of region/namespace device type differentiation is to
decide which block-device driver will attach to a given LIBNVDIMM namespace.
One can simply use the modalias to lookup the resulting module.  It’s
important to note that this method is robust in the presence of a
vendor-specific driver down the road.  If a vendor-specific
implementation wants to supplant the standard nd_blk driver it can with
minimal impact to the rest of LIBNVDIMM.</p>
<p>In fact, a vendor may also want to have a vendor-specific region-driver
(outside of nd_region).  For example, if a vendor defined its own LABEL
format it would need its own region driver to parse that LABEL and emit
the resulting namespaces.  The output from module resolution is more
accurate than a region-name or region-devtype.</p>
</div></blockquote>
</div>
<div class="section" id="udev">
<h4>2. udev<a class="headerlink" href="#udev" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The kernel “devtype” is registered in the udev database:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># udevadm info --path=/devices/platform/nfit_test.0/ndbus0/region0
P: /devices/platform/nfit_test.0/ndbus0/region0
E: DEVPATH=/devices/platform/nfit_test.0/ndbus0/region0
E: DEVTYPE=nd_pmem
E: MODALIAS=nd:t2
E: SUBSYSTEM=nd

# udevadm info --path=/devices/platform/nfit_test.0/ndbus0/region4
P: /devices/platform/nfit_test.0/ndbus0/region4
E: DEVPATH=/devices/platform/nfit_test.0/ndbus0/region4
E: DEVTYPE=nd_blk
E: MODALIAS=nd:t3
E: SUBSYSTEM=nd
</pre></div>
</div>
<p>…and is available as a region attribute, but keep in mind that the
“devtype” does not indicate sub-type variations and scripts should
really be understanding the other attributes.</p>
</div></blockquote>
</div>
<div class="section" id="type-specific-attributes">
<h4>3. type specific attributes<a class="headerlink" href="#type-specific-attributes" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>As it currently stands a BLK-aperture region will never have a
“nfit/spa_index” attribute, but neither will a non-NFIT PMEM region.  A
BLK region with a “mappings” value of 0 is, as mentioned above, a DIMM
that does not allow I/O.  A PMEM region with a “mappings” value of zero
is a simple system-physical-address range.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="libnvdimm-libndctl-namespace">
<h3>LIBNVDIMM/LIBNDCTL: Namespace<a class="headerlink" href="#libnvdimm-libndctl-namespace" title="Permalink to this headline">¶</a></h3>
<p>A REGION, after resolving DPA aliasing and LABEL specified boundaries,
surfaces one or more “namespace” devices.  The arrival of a “namespace”
device currently triggers either the nd_blk or nd_pmem driver to load
and register a disk/block device.</p>
<div class="section" id="libnvdimm-namespace">
<h4>LIBNVDIMM: namespace<a class="headerlink" href="#libnvdimm-namespace" title="Permalink to this headline">¶</a></h4>
<p>Here is a sample layout from the three major types of NAMESPACE where
namespace0.0 represents DIMM-info-backed PMEM (note that it has a ‘uuid’
attribute), namespace2.0 represents a BLK namespace (note it has a
‘sector_size’ attribute) that, and namespace6.0 represents an anonymous
PMEM namespace (note that has no ‘uuid’ attribute due to not support a
LABEL):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0/region0/namespace0.0
|-- alt_name
|-- devtype
|-- dpa_extents
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
|-- uevent
`-- uuid
/sys/devices/platform/nfit_test.0/ndbus0/region2/namespace2.0
|-- alt_name
|-- devtype
|-- dpa_extents
|-- force_raw
|-- modalias
|-- numa_node
|-- sector_size
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
|-- uevent
`-- uuid
/sys/devices/platform/nfit_test.1/ndbus1/region6/namespace6.0
|-- block
|   `-- pmem0
|-- devtype
|-- driver -&gt; ../../../../../../bus/nd/drivers/pmem
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
`-- uevent
</pre></div>
</div>
</div>
<div class="section" id="libndctl-namespace-enumeration-example">
<h4>LIBNDCTL: namespace enumeration example<a class="headerlink" href="#libndctl-namespace-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Namespaces are indexed relative to their parent region, example below.
These indexes are mostly static from boot to boot, but subsystem makes
no guarantees in this regard.  For a static namespace identifier use its
‘uuid’ attribute.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_namespace
*get_namespace_by_id(struct ndctl_region *region, unsigned int id)
{
        struct ndctl_namespace *ndns;

        ndctl_namespace_foreach(region, ndns)
                if (ndctl_namespace_get_id(ndns) == id)
                        return ndns;

        return NULL;
}
</pre></div>
</div>
</div>
<div class="section" id="libndctl-namespace-creation-example">
<h4>LIBNDCTL: namespace creation example<a class="headerlink" href="#libndctl-namespace-creation-example" title="Permalink to this headline">¶</a></h4>
<p>Idle namespaces are automatically created by the kernel if a given
region has enough available capacity to create a new namespace.
Namespace instantiation involves finding an idle namespace and
configuring it.  For the most part the setting of namespace attributes
can occur in any order, the only constraint is that ‘uuid’ must be set
before ‘size’.  This enables the kernel to track DPA allocations
internally with a static identifier:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int configure_namespace(struct ndctl_region *region,
                struct ndctl_namespace *ndns,
                struct namespace_parameters *parameters)
{
        char devname[50];

        snprintf(devname, sizeof(devname), &quot;namespace%d.%d&quot;,
                        ndctl_region_get_id(region), paramaters-&gt;id);

        ndctl_namespace_set_alt_name(ndns, devname);
        /* &#39;uuid&#39; must be set prior to setting size! */
        ndctl_namespace_set_uuid(ndns, paramaters-&gt;uuid);
        ndctl_namespace_set_size(ndns, paramaters-&gt;size);
        /* unlike pmem namespaces, blk namespaces have a sector size */
        if (parameters-&gt;lbasize)
                ndctl_namespace_set_sector_size(ndns, parameters-&gt;lbasize);
        ndctl_namespace_enable(ndns);
}
</pre></div>
</div>
</div>
<div class="section" id="why-the-term-namespace">
<h4>Why the Term “namespace”?<a class="headerlink" href="#why-the-term-namespace" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li><p>Why not “volume” for instance?  “volume” ran the risk of confusing
ND (libnvdimm subsystem) to a volume manager like device-mapper.</p></li>
<li><p>The term originated to describe the sub-devices that can be created
within a NVME controller (see the nvme specification:
<a class="reference external" href="https://www.nvmexpress.org/specifications/">https://www.nvmexpress.org/specifications/</a>), and NFIT namespaces are
meant to parallel the capabilities and configurability of
NVME-namespaces.</p></li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="libnvdimm-libndctl-block-translation-table-btt">
<h3>LIBNVDIMM/LIBNDCTL: Block Translation Table “btt”<a class="headerlink" href="#libnvdimm-libndctl-block-translation-table-btt" title="Permalink to this headline">¶</a></h3>
<p>A BTT (design document: <a class="reference external" href="https://pmem.io/2014/09/23/btt.html">https://pmem.io/2014/09/23/btt.html</a>) is a stacked
block device driver that fronts either the whole block device or a
partition of a block device emitted by either a PMEM or BLK NAMESPACE.</p>
<div class="section" id="libnvdimm-btt-layout">
<h4>LIBNVDIMM: btt layout<a class="headerlink" href="#libnvdimm-btt-layout" title="Permalink to this headline">¶</a></h4>
<p>Every region will start out with at least one BTT device which is the
seed device.  To activate it set the “namespace”, “uuid”, and
“sector_size” attributes and then bind the device to the nd_pmem or
nd_blk driver depending on the region type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.1/ndbus0/region0/btt0/
|-- namespace
|-- delete
|-- devtype
|-- modalias
|-- numa_node
|-- sector_size
|-- subsystem -&gt; ../../../../../bus/nd
|-- uevent
`-- uuid
</pre></div>
</div>
</div>
<div class="section" id="libndctl-btt-creation-example">
<h4>LIBNDCTL: btt creation example<a class="headerlink" href="#libndctl-btt-creation-example" title="Permalink to this headline">¶</a></h4>
<p>Similar to namespaces an idle BTT device is automatically created per
region.  Each time this “seed” btt device is configured and enabled a new
seed is created.  Creating a BTT configuration involves two steps of
finding and idle BTT and assigning it to consume a PMEM or BLK namespace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_btt *get_idle_btt(struct ndctl_region *region)
{
        struct ndctl_btt *btt;

        ndctl_btt_foreach(region, btt)
                if (!ndctl_btt_is_enabled(btt)
                                &amp;&amp; !ndctl_btt_is_configured(btt))
                        return btt;

        return NULL;
}

static int configure_btt(struct ndctl_region *region,
                struct btt_parameters *parameters)
{
        btt = get_idle_btt(region);

        ndctl_btt_set_uuid(btt, parameters-&gt;uuid);
        ndctl_btt_set_sector_size(btt, parameters-&gt;sector_size);
        ndctl_btt_set_namespace(btt, parameters-&gt;ndns);
        /* turn off raw mode device */
        ndctl_namespace_disable(parameters-&gt;ndns);
        /* turn on btt access */
        ndctl_btt_enable(btt);
}
</pre></div>
</div>
<p>Once instantiated a new inactive btt seed device will appear underneath
the region.</p>
<p>Once a “namespace” is removed from a BTT that instance of the BTT device
will be deleted or otherwise reset to default values.  This deletion is
only at the device model level.  In order to destroy a BTT the “info
block” needs to be destroyed.  Note, that to destroy a BTT the media
needs to be written in raw mode.  By default, the kernel will autodetect
the presence of a BTT and disable raw mode.  This autodetect behavior
can be suppressed by enabling raw mode for the namespace via the
ndctl_namespace_set_raw_mode() API.</p>
</div>
</div>
<div class="section" id="summary-libndctl-diagram">
<h3>Summary LIBNDCTL Diagram<a class="headerlink" href="#summary-libndctl-diagram" title="Permalink to this headline">¶</a></h3>
<p>For the given example above, here is the view of the objects as seen by the
LIBNDCTL API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            +---+
            |CTX|    +---------+   +--------------+  +---------------+
            +-+-+  +-&gt; REGION0 +---&gt; NAMESPACE0.0 +--&gt; PMEM8 &quot;pm0.0&quot; |
              |    | +---------+   +--------------+  +---------------+
+-------+     |    | +---------+   +--------------+  +---------------+
| DIMM0 &lt;-+   |    +-&gt; REGION1 +---&gt; NAMESPACE1.0 +--&gt; PMEM6 &quot;pm1.0&quot; |
+-------+ |   |    | +---------+   +--------------+  +---------------+
| DIMM1 &lt;-+ +-v--+ | +---------+   +--------------+  +---------------+
+-------+ +-+BUS0+---&gt; REGION2 +-+-&gt; NAMESPACE2.0 +--&gt; ND6  &quot;blk2.0&quot; |
| DIMM2 &lt;-+ +----+ | +---------+ | +--------------+  +----------------------+
+-------+ |        |             +-&gt; NAMESPACE2.1 +--&gt; ND5  &quot;blk2.1&quot; | BTT2 |
| DIMM3 &lt;-+        |               +--------------+  +----------------------+
+-------+          | +---------+   +--------------+  +---------------+
                   +-&gt; REGION3 +-+-&gt; NAMESPACE3.0 +--&gt; ND4  &quot;blk3.0&quot; |
                   | +---------+ | +--------------+  +----------------------+
                   |             +-&gt; NAMESPACE3.1 +--&gt; ND3  &quot;blk3.1&quot; | BTT1 |
                   |               +--------------+  +----------------------+
                   | +---------+   +--------------+  +---------------+
                   +-&gt; REGION4 +---&gt; NAMESPACE4.0 +--&gt; ND2  &quot;blk4.0&quot; |
                   | +---------+   +--------------+  +---------------+
                   | +---------+   +--------------+  +----------------------+
                   +-&gt; REGION5 +---&gt; NAMESPACE5.0 +--&gt; ND1  &quot;blk5.0&quot; | BTT0 |
                     +---------+   +--------------+  +---------------+------+
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="btt.html" class="btn btn-neutral float-right" title="BTT - Block Translation Table" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="Non-Volatile Memory Device (NVDIMM)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>