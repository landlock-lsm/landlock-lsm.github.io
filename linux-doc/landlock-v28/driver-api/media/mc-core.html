

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>4. Media Controller devices &mdash; The Linux Kernel 5.11.0-rc6+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5. CEC Kernel Support" href="cec-core.html" />
    <link rel="prev" title="3. Remote Controller devices" href="rc-core.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0-rc6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">4. Media Controller devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#media-controller">4.1. Media Controller</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="camera-sensor.html">7. Writing camera sensor drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers/index.html">8. Media driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Media subsystem kernel internal API</a> &raquo;</li>
        
      <li><span class="section-number">4. </span>Media Controller devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/media/mc-core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="media-controller-devices">
<h1><span class="section-number">4. </span>Media Controller devices<a class="headerlink" href="#media-controller-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="media-controller">
<h2><span class="section-number">4.1. </span>Media Controller<a class="headerlink" href="#media-controller" title="Permalink to this headline">¶</a></h2>
<p>The media controller userspace API is documented in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-controller.html#media-controller"><span class="std std-ref">the Media Controller uAPI book</span></a>. This document focus
on the kernel-side implementation of the media framework.</p>
<div class="section" id="abstract-media-device-model">
<h3><span class="section-number">4.1.1. </span>Abstract media device model<a class="headerlink" href="#abstract-media-device-model" title="Permalink to this headline">¶</a></h3>
<p>Discovering a device internal topology, and configuring it at runtime, is one
of the goals of the media framework. To achieve this, hardware devices are
modelled as an oriented graph of building blocks called entities connected
through pads.</p>
<p>An entity is a basic media hardware building block. It can correspond to
a large variety of logical blocks such as physical hardware devices
(CMOS sensor for instance), logical hardware devices (a building block
in a System-on-Chip image processing pipeline), DMA channels or physical
connectors.</p>
<p>A pad is a connection endpoint through which an entity can interact with
other entities. Data (not restricted to video) produced by an entity
flows from the entity’s output to one or more entity inputs. Pads should
not be confused with physical pins at chip boundaries.</p>
<p>A link is a point-to-point oriented connection between two pads, either
on the same entity or on different entities. Data flows from a source
pad to a sink pad.</p>
</div>
<div class="section" id="media-device">
<h3><span class="section-number">4.1.2. </span>Media device<a class="headerlink" href="#media-device" title="Permalink to this headline">¶</a></h3>
<p>A media device is represented by a <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a>
instance, defined in <code class="docutils literal notranslate"><span class="pre">include/media/media-device.h</span></code>.
Allocation of the structure is handled by the media device driver, usually by
embedding the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> instance in a larger driver-specific
structure.</p>
<p>Drivers register media device instances by calling
<a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_device_register()</span></code></a> via the macro <code class="docutils literal notranslate"><span class="pre">media_device_register()</span></code>
and unregistered by calling <a class="reference internal" href="#c.media_device_unregister" title="media_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_unregister()</span></code></a>.</p>
</div>
<div class="section" id="entities">
<h3><span class="section-number">4.1.3. </span>Entities<a class="headerlink" href="#entities" title="Permalink to this headline">¶</a></h3>
<p>Entities are represented by a <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a>
instance, defined in <code class="docutils literal notranslate"><span class="pre">include/media/media-entity.h</span></code>. The structure is usually
embedded into a higher-level structure, such as
<a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> or <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>
instances, although drivers can allocate entities directly.</p>
<p>Drivers initialize entity pads by calling
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a>.</p>
<p>Drivers register entities with a media device by calling
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a>
and unregistered by calling
<a class="reference internal" href="#c.media_device_unregister_entity" title="media_device_unregister_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_unregister_entity()</span></code></a>.</p>
</div>
<div class="section" id="interfaces">
<h3><span class="section-number">4.1.4. </span>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h3>
<p>Interfaces are represented by a
<a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_interface</span></code></a> instance, defined in
<code class="docutils literal notranslate"><span class="pre">include/media/media-entity.h</span></code>. Currently, only one type of interface is
defined: a device node. Such interfaces are represented by a
<a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_intf_devnode</span></code></a>.</p>
<p>Drivers initialize and create device node interfaces by calling
<a class="reference internal" href="#c.media_devnode_create" title="media_devnode_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_create()</span></code></a>
and remove them by calling:
<a class="reference internal" href="#c.media_devnode_remove" title="media_devnode_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_remove()</span></code></a>.</p>
</div>
<div class="section" id="pads">
<h3><span class="section-number">4.1.5. </span>Pads<a class="headerlink" href="#pads" title="Permalink to this headline">¶</a></h3>
<p>Pads are represented by a <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span></code></a> instance,
defined in <code class="docutils literal notranslate"><span class="pre">include/media/media-entity.h</span></code>. Each entity stores its pads in
a pads array managed by the entity driver. Drivers usually embed the array in
a driver-specific structure.</p>
<p>Pads are identified by their entity and their 0-based index in the pads
array.</p>
<p>Both information are stored in the <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span></code></a>,
making the <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span></code></a> pointer the canonical way
to store and pass link references.</p>
<p>Pads have flags that describe the pad capabilities and state.</p>
<p><code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_SINK</span></code> indicates that the pad supports sinking data.
<code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_SOURCE</span></code> indicates that the pad supports sourcing data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One and only one of <code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_SINK</span></code> or <code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_SOURCE</span></code> must
be set for each pad.</p>
</div>
</div>
<div class="section" id="links">
<h3><span class="section-number">4.1.6. </span>Links<a class="headerlink" href="#links" title="Permalink to this headline">¶</a></h3>
<p>Links are represented by a <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span></code></a> instance,
defined in <code class="docutils literal notranslate"><span class="pre">include/media/media-entity.h</span></code>. There are two types of links:</p>
<p><strong>1. pad to pad links</strong>:</p>
<p>Associate two entities via their PADs. Each entity has a list that points
to all links originating at or targeting any of its pads.
A given link is thus stored twice, once in the source entity and once in
the target entity.</p>
<p>Drivers create pad to pad links by calling:
<a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_pad_link()</span></code></a> and remove with
<a class="reference internal" href="#c.media_entity_remove_links" title="media_entity_remove_links"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_remove_links()</span></code></a>.</p>
<p><strong>2. interface to entity links</strong>:</p>
<p>Associate one interface to a Link.</p>
<p>Drivers create interface to entity links by calling:
<a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_intf_link()</span></code></a> and remove with
<a class="reference internal" href="#c.media_remove_intf_links" title="media_remove_intf_links"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_remove_intf_links()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Links can only be created after having both ends already created.</p>
</div>
<p>Links have flags that describe the link capabilities and state. The
valid values are described at <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_pad_link()</span></code></a> and
<a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_intf_link()</span></code></a>.</p>
</div>
<div class="section" id="graph-traversal">
<h3><span class="section-number">4.1.7. </span>Graph traversal<a class="headerlink" href="#graph-traversal" title="Permalink to this headline">¶</a></h3>
<p>The media framework provides APIs to iterate over entities in a graph.</p>
<p>To iterate over all entities belonging to a media device, drivers can use
the media_device_for_each_entity macro, defined in
<code class="docutils literal notranslate"><span class="pre">include/media/media-device.h</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">media_entity</span> <span class="o">*</span><span class="n">entity</span><span class="p">;</span>

<span class="n">media_device_for_each_entity</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">mdev</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// entity will point to each entity in turn</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Drivers might also need to iterate over all entities in a graph that can be
reached only through enabled links starting at a given entity. The media
framework provides a depth-first graph traversal API for that purpose.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Graphs with cycles (whether directed or undirected) are <strong>NOT</strong>
supported by the graph traversal API. To prevent infinite loops, the graph
traversal code limits the maximum depth to <code class="docutils literal notranslate"><span class="pre">MEDIA_ENTITY_ENUM_MAX_DEPTH</span></code>,
currently defined as 16.</p>
</div>
<p>Drivers initiate a graph traversal by calling
<a class="reference internal" href="#c.media_graph_walk_start" title="media_graph_walk_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_graph_walk_start()</span></code></a></p>
<p>The graph structure, provided by the caller, is initialized to start graph
traversal at the given entity.</p>
<p>Drivers can then retrieve the next entity by calling
<a class="reference internal" href="#c.media_graph_walk_next" title="media_graph_walk_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_graph_walk_next()</span></code></a></p>
<p>When the graph traversal is complete the function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Graph traversal can be interrupted at any moment. No cleanup function call
is required and the graph structure can be freed normally.</p>
<p>Helper functions can be used to find a link between two given pads, or a pad
connected to another pad through an enabled link
<a class="reference internal" href="#c.media_entity_find_link" title="media_entity_find_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_find_link()</span></code></a> and
<a class="reference internal" href="#c.media_entity_remote_pad" title="media_entity_remote_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_remote_pad()</span></code></a>.</p>
</div>
<div class="section" id="use-count-and-power-handling">
<h3><span class="section-number">4.1.8. </span>Use count and power handling<a class="headerlink" href="#use-count-and-power-handling" title="Permalink to this headline">¶</a></h3>
<p>Due to the wide differences between drivers regarding power management
needs, the media controller does not implement power management. However,
the <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> includes a <code class="docutils literal notranslate"><span class="pre">use_count</span></code>
field that media drivers
can use to track the number of users of every entity for power management
needs.</p>
<p>The <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a>.<code class="docutils literal notranslate"><span class="pre">use_count</span></code> field is owned by
media drivers and must not be
touched by entity drivers. Access to the field must be protected by the
<a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a>.<code class="docutils literal notranslate"><span class="pre">graph_mutex</span></code> lock.</p>
</div>
<div class="section" id="links-setup">
<h3><span class="section-number">4.1.9. </span>Links setup<a class="headerlink" href="#links-setup" title="Permalink to this headline">¶</a></h3>
<p>Link properties can be modified at runtime by calling
<a class="reference internal" href="#c.media_entity_setup_link" title="media_entity_setup_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_setup_link()</span></code></a>.</p>
</div>
<div class="section" id="pipelines-and-media-streams">
<h3><span class="section-number">4.1.10. </span>Pipelines and media streams<a class="headerlink" href="#pipelines-and-media-streams" title="Permalink to this headline">¶</a></h3>
<p>When starting streaming, drivers must notify all entities in the pipeline to
prevent link states from being modified during streaming by calling
<a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a>.</p>
<p>The function will mark all entities connected to the given entity through
enabled links, either directly or indirectly, as streaming.</p>
<p>The <a class="reference internal" href="#c.media_pipeline" title="media_pipeline"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span></code></a> instance pointed to by
the pipe argument will be stored in every entity in the pipeline.
Drivers should embed the <a class="reference internal" href="#c.media_pipeline" title="media_pipeline"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span></code></a>
in higher-level pipeline structures and can then access the
pipeline through the <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a>
pipe field.</p>
<p>Calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> can be nested.
The pipeline pointer must be identical for all nested calls to the function.</p>
<p><a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> may return an error. In that case,
it will clean up any of the changes it did by itself.</p>
<p>When stopping the stream, drivers must notify the entities with
<a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a>.</p>
<p>If multiple calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> have been
made the same number of <a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a> calls
are required to stop streaming.
The <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a>.<code class="docutils literal notranslate"><span class="pre">pipe</span></code> field is reset to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on the last
nested stop call.</p>
<p>Link configuration will fail with <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> by default if either end of the
link is a streaming entity. Links that can be modified while streaming must
be marked with the <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_DYNAMIC</span></code> flag.</p>
<p>If other operations need to be disallowed on streaming entities (such as
changing entities configuration parameters) drivers can explicitly check the
media_entity stream_count field to find out if an entity is streaming. This
operation must be done with the media_device graph_mutex held.</p>
</div>
<div class="section" id="link-validation">
<h3><span class="section-number">4.1.11. </span>Link validation<a class="headerlink" href="#link-validation" title="Permalink to this headline">¶</a></h3>
<p>Link validation is performed by <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a>
for any entity which has sink pads in the pipeline. The
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a>.<code class="docutils literal notranslate"><span class="pre">link_validate()</span></code> callback is used for that
purpose. In <code class="docutils literal notranslate"><span class="pre">link_validate()</span></code> callback, entity driver should check
that the properties of the source pad of the connected entity and its own
sink pad match. It is up to the type of the entity (and in the end, the
properties of the hardware) what matching actually means.</p>
<p>Subsystems should facilitate link validation by providing subsystem specific
helper functions to provide easy access for commonly needed information, and
in the end provide a way to use driver-specific callbacks.</p>
</div>
<div class="section" id="media-controller-device-allocator-api">
<h3><span class="section-number">4.1.12. </span>Media Controller Device Allocator API<a class="headerlink" href="#media-controller-device-allocator-api" title="Permalink to this headline">¶</a></h3>
<p>When the media device belongs to more than one driver, the shared media
device is allocated with the shared <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> as the key for look ups.</p>
<p>The shared media device should stay in registered state until the last
driver unregisters it. In addition, the media device should be released when
all the references are released. Each driver gets a reference to the media
device during probe, when it allocates the media device. If media device is
already allocated, the allocate API bumps up the refcount and returns the
existing media device. The driver puts the reference back in its disconnect
routine when it calls <a class="reference internal" href="#c.media_device_delete" title="media_device_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_delete()</span></code></a>.</p>
<p>The media device is unregistered and cleaned up from the kref put handler to
ensure that the media device stays in registered state until the last driver
unregisters the media device.</p>
<p><strong>Driver Usage</strong></p>
<p>Drivers should use the appropriate media-core routines to manage the shared
media device life-time handling the two states:
1. allocate -&gt; register -&gt; delete
2. get reference to already registered device -&gt; delete</p>
<p>call <a class="reference internal" href="#c.media_device_delete" title="media_device_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_delete()</span></code></a> routine to make sure the shared media
device delete is handled correctly.</p>
<p><strong>driver probe:</strong>
Call <a class="reference internal" href="#c.media_device_usb_allocate" title="media_device_usb_allocate"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_usb_allocate()</span></code></a> to allocate or get a reference
Call <a class="reference internal" href="#c.media_device_register" title="media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register()</span></code></a>, if media devnode isn’t registered</p>
<p><strong>driver disconnect:</strong>
Call <a class="reference internal" href="#c.media_device_delete" title="media_device_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_delete()</span></code></a> to free the media_device. Freeing is
handled by the kref put handler.</p>
</div>
<div class="section" id="api-definitions">
<h3><span class="section-number">4.1.13. </span>API Definitions<a class="headerlink" href="#api-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.media_entity_notify">
<em class="property">struct </em><code class="sig-name descname">media_entity_notify</code><a class="headerlink" href="#c.media_entity_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media Entity Notify</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_entity_notify {
  struct list_head list;
  void *notify_data;
  void (*notify)(struct media_entity *entity, void *notify_data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notify_data</span></code></dt><dd><p>Input data to invoke the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notify</span></code></dt><dd><p>Callback function pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may register a callback to take action when new entities get
registered with the media device. This handler is intended for creating
links between existing entities and should not create entities and register
them.</p>
<dl class="c struct">
<dt id="c.media_device_ops">
<em class="property">struct </em><code class="sig-name descname">media_device_ops</code><a class="headerlink" href="#c.media_device_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media device operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_device_ops {
  int (*link_notify)(struct media_link *link, u32 flags, unsigned int notification);
  struct media_request *(*req_alloc)(struct media_device *mdev);
  void (*req_free)(struct media_request *req);
  int (*req_validate)(struct media_request *req);
  void (*req_queue)(struct media_request *req);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">link_notify</span></code></dt><dd><p>Link state change notification callback. This callback is
called with the graph_mutex held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_alloc</span></code></dt><dd><p>Allocate a request. Set this if you need to allocate a struct
larger then <a class="reference internal" href="#c.media_request" title="media_request"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span></code></a>. <strong>req_alloc</strong> and <strong>req_free</strong> must
either both be set or both be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_free</span></code></dt><dd><p>Free a request. Set this if <strong>req_alloc</strong> was set as well, leave
to NULL otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_validate</span></code></dt><dd><p>Validate a request, but do not queue yet. The req_queue_mutex
lock is held when this op is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_queue</span></code></dt><dd><p>Queue a validated request, cannot fail. If something goes
wrong when queueing this request then it should be marked
as such internally in the driver and any related buffers
must eventually return to vb2 with state VB2_BUF_STATE_ERROR.
The req_queue_mutex lock is held when this op is called.
It is important that vb2 buffer objects are queued last after
all other object types are queued: queueing a buffer kickstarts
the request processing, so all other objects related to the
request (and thus the buffer) must be available to the driver.
And once a buffer is queued, then the driver can complete
or delete objects from the request before req_queue exits.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_device">
<em class="property">struct </em><code class="sig-name descname">media_device</code><a class="headerlink" href="#c.media_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_device {
  struct device *dev;
  struct media_devnode *devnode;
  char model[32];
  char driver_name[32];
  char serial[40];
  char bus_info[32];
  u32 hw_revision;
  u64 topology_version;
  u32 id;
  struct ida entity_internal_idx;
  int entity_internal_idx_max;
  struct list_head entities;
  struct list_head interfaces;
  struct list_head pads;
  struct list_head links;
  struct list_head entity_notify;
  struct mutex graph_mutex;
  struct media_graph pm_count_walk;
  void *source_priv;
  int (*enable_source)(struct media_entity *entity, struct media_pipeline *pipe);
  void (*disable_source)(struct media_entity *entity);
  const struct media_device_ops *ops;
  struct mutex req_queue_mutex;
  atomic_t request_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devnode</span></code></dt><dd><p>Media device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">model</span></code></dt><dd><p>Device model name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_name</span></code></dt><dd><p>Optional device driver name. If not set, calls to
<code class="docutils literal notranslate"><span class="pre">MEDIA_IOC_DEVICE_INFO</span></code> will return <code class="docutils literal notranslate"><span class="pre">dev-&gt;driver-&gt;name</span></code>.
This is needed for USB drivers for example, as otherwise
they’ll all appear as if the driver name was “usb”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">serial</span></code></dt><dd><p>Device serial number (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_info</span></code></dt><dd><p>Unique and stable device location identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_revision</span></code></dt><dd><p>Hardware device revision</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_version</span></code></dt><dd><p>Monotonic counter for storing the version of the graph
topology. Should be incremented each time the topology changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Unique ID used on the last registered graph object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity_internal_idx</span></code></dt><dd><p>Unique internal entity ID used by the graph traversal
algorithms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity_internal_idx_max</span></code></dt><dd><p>Allocated internal entity indices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entities</span></code></dt><dd><p>List of registered entities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interfaces</span></code></dt><dd><p>List of registered interfaces</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pads</span></code></dt><dd><p>List of registered pads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt><dd><p>List of registered links</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity_notify</span></code></dt><dd><p>List of registered entity_notify callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">graph_mutex</span></code></dt><dd><p>Protects access to <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a> data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_count_walk</span></code></dt><dd><p>Graph walk for power state walk. Access serialised using
graph_mutex.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">source_priv</span></code></dt><dd><p>Driver Private data for enable/disable source handlers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_source</span></code></dt><dd><p>Enable Source Handler function pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_source</span></code></dt><dd><p>Disable Source Handler function pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Operation handler callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_queue_mutex</span></code></dt><dd><p>Serialise the MEDIA_REQUEST_IOC_QUEUE ioctl w.r.t.
other operations that stop or start streaming.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_id</span></code></dt><dd><p>Used to generate unique request IDs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an abstract high-level media device. It allows easy
access to entities and provides basic media device-level support. The
structure can be allocated directly or embedded in a larger structure.</p>
<p>The parent <strong>dev</strong> is a physical device. It must be set before registering the
media device.</p>
<p><strong>model</strong> is a descriptive model name exported through sysfs. It doesn’t have to
be unique.</p>
<p><strong>enable_source</strong> is a handler to find source entity for the
sink entity  and activate the link between them if source
entity is free. Drivers should call this handler before
accessing the source.</p>
<p><strong>disable_source</strong> is a handler to find source entity for the
sink entity  and deactivate the link between them. Drivers
should call this handler to release the source.</p>
<p>Use-case: find tuner entity connected to the decoder
entity and check if it is available, and activate the
link between them from <strong>enable_source</strong> and deactivate
from <strong>disable_source</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bridge driver is expected to implement and set the
handler when <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> is registered or when
bridge driver finds the media_device during probe.
Bridge driver sets source_priv with information
necessary to run <strong>enable_source</strong> and <strong>disable_source</strong> handlers.
Callers should hold graph_mutex to access and call <strong>enable_source</strong>
and <strong>disable_source</strong> handlers.</p>
</div>
<dl class="c function">
<dt id="c.media_entity_enum_init">
int <code class="sig-name descname">media_entity_enum_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>The related media device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code.</p>
<dl class="c function">
<dt id="c.media_device_init">
void <code class="sig-name descname">media_device_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initializes a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the media device prior to its registration.
The media device initialization and registration is split in two functions
to avoid race conditions and make the media device available to user-space
before the media graph has been completed.</p>
<p>So drivers need to first initialize the media device, register any entity
within the media device, create pad to pad links and then finally register
the media device by calling <a class="reference internal" href="#c.media_device_register" title="media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register()</span></code></a> as a final step.</p>
<dl class="c function">
<dt id="c.media_device_cleanup">
void <code class="sig-name descname">media_device_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cleanups a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function that will destroy the graph_mutex that is
initialized in <a class="reference internal" href="#c.media_device_init" title="media_device_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_init()</span></code></a>.</p>
<dl class="c function">
<dt id="c.__media_device_register">
int <code class="sig-name descname">__media_device_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> module *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_device_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>should be filled with <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Users, should, instead, call the <a class="reference internal" href="#c.media_device_register" title="media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register()</span></code></a> macro.</p>
<p>The caller is responsible for initializing the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> structure
before registration. The following fields of <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> must be set:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.dev</span></code></a> must point to the parent device (usually a <code class="xref c c-type docutils literal notranslate"><span class="pre">pci_dev</span></code>,
<a class="reference internal" href="../usb/usb.html#c.usb_interface" title="usb_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_interface</span></code></a> or <code class="xref c c-type docutils literal notranslate"><span class="pre">platform_device</span></code> instance).</p></li>
<li><p><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.model</span></code></a> must be filled with the device model name as a
NUL-terminated UTF-8 string. The device/model revision must not be
stored in this field.</p></li>
</ul>
</div></blockquote>
<p>The following fields are optional:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.serial</span></code></a> is a unique serial number stored as a
NUL-terminated ASCII string. The field is big enough to store a GUID
in text form. If the hardware doesn’t provide a unique serial number
this field must be left empty.</p></li>
<li><p><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.bus_info</span></code></a> represents the location of the device in the
system as a NUL-terminated ASCII string. For PCI/PCIe devices
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.bus_info</span></code></a> must be set to “PCI:” (or “PCIe:”) followed by
the value of pci_name(). For USB devices,the <a class="reference internal" href="../usb/usb.html#c.usb_make_path" title="usb_make_path"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_make_path()</span></code></a> function
must be used. This field is used by applications to distinguish between
otherwise identical devices that don’t provide a serial number.</p></li>
<li><p><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.hw_revision</span></code></a> is the hardware device revision in a
driver-specific format. When possible the revision should be formatted
with the KERNEL_VERSION() macro.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Upon successful registration a character device named media[0-9]+ is created. The device major and minor numbers are dynamic. The model name is exported as a sysfs attribute.</p></li>
<li><p>Unregistering a media device that hasn’t been registered is <strong>NOT</strong> safe.</p></li>
</ol>
</div>
<p><strong>Return</strong></p>
<p>returns zero on success or a negative error code.</p>
<dl class="c macro">
<dt id="c.media_device_register">
<code class="sig-name descname">media_device_register</code><a class="headerlink" href="#c.media_device_register" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">media_device_register</span> <span class="pre">(mdev)</span></code></p>
<blockquote>
<div><p>Registers a media device element</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro calls <a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_device_register()</span></code></a> passing <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> as
the <a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_device_register()</span></code></a> second argument (<strong>owner</strong>).</p>
<dl class="c function">
<dt id="c.media_device_unregister">
void <code class="sig-name descname">media_device_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregisters a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is safe to call this function on an unregistered (but initialised)
media device.</p>
<dl class="c function">
<dt id="c.media_device_register_entity">
int <code class="sig-name descname">media_device_register_entity</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_register_entity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>registers a media entity inside a previously registered media device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> to be registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Entities are identified by a unique positive integer ID. The media
controller framework will such ID automatically. IDs are not guaranteed
to be contiguous, and the ID number can change on newer Kernel versions.
So, neither the driver nor userspace should hardcode ID numbers to refer
to the entities, but, instead, use the framework to find the ID, when
needed.</p>
<p>The media_entity name, type and flags fields should be initialized before
calling <a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a>. Entities embedded in higher-level
standard structures can have some of those fields set by the higher-level
framework.</p>
<p>If the device has pads, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a> should be called before
this function. Otherwise, the <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.pad</span></code></a> and <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity.num_pads</span></code></a>
should be zeroed before calling this function.</p>
<p>Entities have flags that describe the entity capabilities and state:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_ENT_FL_DEFAULT</span></code></dt><dd><p>indicates the default entity for a given type.
This can be used to report the default audio and video devices or the
default camera sensor.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Drivers should set the entity function before calling this function.
Please notice that the values <code class="docutils literal notranslate"><span class="pre">MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN</span></code> and
<code class="docutils literal notranslate"><span class="pre">MEDIA_ENT_F_UNKNOWN</span></code> should not be used by the drivers.</p>
</div>
<dl class="c function">
<dt id="c.media_device_unregister_entity">
void <code class="sig-name descname">media_device_unregister_entity</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister_entity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregisters a media entity.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All links associated with the entity and all PADs are automatically
unregistered from the media_device when this function is called.</p>
<p>Unregistering an entity will not change the IDs of the other entities and
the previoully used ID will never be reused for a newly registered entities.</p>
<p>When a media device is unregistered, all its entities are unregistered
automatically. No manual entities unregistration is then required.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The media_entity instance itself must be freed explicitly by
the driver if required.</p>
</div>
<dl class="c function">
<dt id="c.media_device_register_entity_notify">
int <code class="sig-name descname">media_device_register_entity_notify</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity_notify" title="media_entity_notify">media_entity_notify</a> *<em>nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_register_entity_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Registers a media entity_notify callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>The media device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_notify</span> <span class="pre">*nptr</span></code></dt><dd><p>The media_entity_notify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a new entity is registered, all the registered
media_entity_notify callbacks are invoked.</p>
</div>
<dl class="c function">
<dt id="c.media_device_unregister_entity_notify">
void <code class="sig-name descname">media_device_unregister_entity_notify</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity_notify" title="media_entity_notify">media_entity_notify</a> *<em>nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister_entity_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a media entity notify callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>The media device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_notify</span> <span class="pre">*nptr</span></code></dt><dd><p>The media_entity_notify</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_device_pci_init">
void <code class="sig-name descname">media_device_pci_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_device_pci_init" title="pci_dev">pci_dev</a> *<em>pci_dev</em>, <em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_pci_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pci_dev</span></code></dt><dd><p>pointer to struct pci_dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>media device name. If <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the routine will use the default
name for the pci device, given by pci_name() macro.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.__media_device_usb_init">
void <code class="sig-name descname">__media_device_usb_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="../usb/usb.html#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em>, <em class="property">const</em> char *<em>board_name</em>, <em class="property">const</em> char *<em>driver_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_device_usb_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>pointer to <a class="reference internal" href="../usb/usb.html#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*board_name</span></code></dt><dd><p>media device name. If <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the routine will use the usb
product name, if available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*driver_name</span></code></dt><dd><p>name of the driver. if <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the routine will use the name
given by <code class="docutils literal notranslate"><span class="pre">udev-&gt;dev-&gt;driver-&gt;name</span></code>, with is usually the wrong
thing to do.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is better to call <a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_usb_init()</span></code></a> instead, as
such macro fills driver_name with <code class="docutils literal notranslate"><span class="pre">KBUILD_MODNAME</span></code>.</p>
</div>
<dl class="c macro">
<dt id="c.media_device_usb_init">
<code class="sig-name descname">media_device_usb_init</code><a class="headerlink" href="#c.media_device_usb_init" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">media_device_usb_init</span> <span class="pre">(mdev,</span> <span class="pre">udev,</span> <span class="pre">name)</span></code></p>
<blockquote>
<div><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">udev</span></code></dt><dd><p>pointer to <a class="reference internal" href="../usb/usb.html#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>media device name. If <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the routine will use the usb
product name, if available.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro calls <a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_usb_init()</span></code></a> passing the
<a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_usb_init()</span></code></a> <strong>driver_name</strong> parameter filled with
<code class="docutils literal notranslate"><span class="pre">KBUILD_MODNAME</span></code>.</p>
<dl class="c struct">
<dt id="c.media_file_operations">
<em class="property">struct </em><code class="sig-name descname">media_file_operations</code><a class="headerlink" href="#c.media_file_operations" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media device file operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_file_operations {
  struct module *owner;
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  __poll_t (*poll) (struct file *, struct poll_table_struct *);
  long (*ioctl) (struct file *, unsigned int, unsigned long);
  long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
  int (*open) (struct file *);
  int (*release) (struct file *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>should be filled with <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>pointer to the function that implements read() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>pointer to the function that implements write() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>pointer to the function that implements poll() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p>pointer to the function that implements ioctl() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl</span></code></dt><dd><p>pointer to the function that will handle 32 bits userspace
calls to the ioctl() syscall on a Kernel compiled with 64 bits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>pointer to the function that implements open() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>pointer to the function that will release the resources allocated
by the <strong>open</strong> function.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_devnode">
<em class="property">struct </em><code class="sig-name descname">media_devnode</code><a class="headerlink" href="#c.media_devnode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media device node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_devnode {
  struct media_device *media_dev;
  const struct media_file_operations *fops;
  struct device dev;
  struct cdev cdev;
  struct device *parent;
  int minor;
  unsigned long flags;
  void (*release)(struct media_devnode *devnode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">media_dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fops</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_file_operations" title="media_file_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_file_operations</span></code></a> with media device ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> containing the media controller device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdev</span></code></dt><dd><p>struct cdev pointer character device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>device node minor number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags, combination of the <code class="docutils literal notranslate"><span class="pre">MEDIA_FLAG_*</span></code> constants</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>release callback called at the end of <code class="docutils literal notranslate"><span class="pre">media_devnode_release()</span></code>
routine at media-device.c.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a media-related device node.</p>
<p>The <strong>parent</strong> is a physical device. It must be set by core or device drivers
before registering the node.</p>
<dl class="c function">
<dt id="c.media_devnode_register">
int <code class="sig-name descname">media_devnode_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>devnode</em>, <em class="property">struct</em> module *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a media device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p><a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a> we want to register a device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*devnode</span></code></dt><dd><p>media device node structure we want to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>should be filled with <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The registration code assigns minor numbers and registers the new device node
with the kernel. An error is returned if no free minor number can be found,
or if the registration of the device node fails.</p>
<p>Zero is returned on success.</p>
<p>Note that if the media_devnode_register call fails, the release() callback of
the media_devnode structure is <em>not</em> called, so the caller is responsible for
freeing any data.</p>
<dl class="c function">
<dt id="c.media_devnode_unregister_prepare">
void <code class="sig-name descname">media_devnode_unregister_prepare</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_unregister_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear the media device node register bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*devnode</span></code></dt><dd><p>the device node to prepare for unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This clears the passed device register bit. Future open calls will be met
with errors. Should be called before <a class="reference internal" href="#c.media_devnode_unregister" title="media_devnode_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_unregister()</span></code></a> to avoid
races with unregister and device file open calls.</p>
<p>This function can safely be called if the device node has never been
registered or has already been unregistered.</p>
<dl class="c function">
<dt id="c.media_devnode_unregister">
void <code class="sig-name descname">media_devnode_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a media device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*devnode</span></code></dt><dd><p>the device node to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unregisters the passed device. Future open calls will be met with
errors.</p>
<p>Should be called after <a class="reference internal" href="#c.media_devnode_unregister_prepare" title="media_devnode_unregister_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_unregister_prepare()</span></code></a></p>
<dl class="c function">
<dt id="c.media_devnode_data">
<em class="property">struct</em> <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<code class="sig-name descname">media_devnode_data</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns a pointer to the <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_devnode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_devnode_is_registered">
int <code class="sig-name descname">media_devnode_is_registered</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_is_registered" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns true if <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_devnode</span></code></a> is registered; false otherwise.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*devnode</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_devnode</span></code></a>.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>If mdev is NULL, it also returns false.</p>
<dl class="c enum">
<dt id="c.media_gobj_type">
<em class="property">enum </em><code class="sig-name descname">media_gobj_type</code><a class="headerlink" href="#c.media_gobj_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>type of a graph object</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_GRAPH_ENTITY</span></code></dt><dd><p>Identify a media entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_GRAPH_PAD</span></code></dt><dd><p>Identify a media pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_GRAPH_LINK</span></code></dt><dd><p>Identify a media link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_GRAPH_INTF_DEVNODE</span></code></dt><dd><p>Identify a media Kernel API interface via
a device node</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_gobj">
<em class="property">struct </em><code class="sig-name descname">media_gobj</code><a class="headerlink" href="#c.media_gobj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Define a graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_gobj {
  struct media_device     *mdev;
  u32 id;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> that owns the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Non-zero object ID identifier. The ID should be unique
inside a media_device, as it is composed by
<code class="docutils literal notranslate"><span class="pre">MEDIA_BITS_PER_TYPE</span></code> to store the type plus
<code class="docutils literal notranslate"><span class="pre">MEDIA_BITS_PER_ID</span></code> to store the ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List entry stored in one of the per-type mdev object lists</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All objects on the media graph should have this struct embedded</p>
<dl class="c struct">
<dt id="c.media_entity_enum">
<em class="property">struct </em><code class="sig-name descname">media_entity_enum</code><a class="headerlink" href="#c.media_entity_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An enumeration of media entities.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_entity_enum {
  unsigned long *bmap;
  int idx_max;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bmap</span></code></dt><dd><p>Bit map in which each bit represents one entity at <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">media_entity</span></code></a>-&gt;internal_idx.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idx_max</span></code></dt><dd><p>Number of bits in bmap</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_graph">
<em class="property">struct </em><code class="sig-name descname">media_graph</code><a class="headerlink" href="#c.media_graph" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media graph traversal state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_graph {
  struct {
    struct media_entity *entity;
    struct list_head *link;
  } stack[MEDIA_ENTITY_ENUM_MAX_DEPTH];
  struct media_entity_enum ent_enum;
  int top;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stack</span></code></dt><dd><p>Graph traversal stack; the stack contains information
on the path the media entities to be walked and the
links through which they were reached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stack.entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> at the graph.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stack.link</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ent_enum</span></code></dt><dd><p>Visited entities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top</span></code></dt><dd><p>The top of the stack</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_pipeline">
<em class="property">struct </em><code class="sig-name descname">media_pipeline</code><a class="headerlink" href="#c.media_pipeline" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media pipeline related information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_pipeline {
  int streaming_count;
  struct media_graph graph;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">streaming_count</span></code></dt><dd><p>Streaming start count - streaming stop count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">graph</span></code></dt><dd><p>Media graph walk during pipeline start / stop</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_link">
<em class="property">struct </em><code class="sig-name descname">media_link</code><a class="headerlink" href="#c.media_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A link object part of a media graph.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_link {
  struct media_gobj graph_obj;
  struct list_head list;
  union {
    struct media_gobj *gobj0;
    struct media_pad *source;
    struct media_interface *intf;
  };
  union {
    struct media_gobj *gobj1;
    struct media_pad *sink;
    struct media_entity *entity;
  };
  struct media_link *reverse;
  unsigned long flags;
  bool is_backlink;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">graph_obj</span></code></dt><dd><p>Embedded structure containing the media object common data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Linked list associated with an entity or an interface that
owns the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gobj0</span></code></dt><dd><p>Part of a union. Used to get the pointer for the first
graph_object of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">source</span></code></dt><dd><p>Part of a union. Used only if the first object (gobj0) is
a pad. In that case, it represents the source pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf</span></code></dt><dd><p>Part of a union. Used only if the first object (gobj0) is
an interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gobj1</span></code></dt><dd><p>Part of a union. Used to get the pointer for the second
graph_object of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sink</span></code></dt><dd><p>Part of a union. Used only if the second object (gobj1) is
a pad. In that case, it represents the sink pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>Part of a union. Used only if the second object (gobj1) is
an entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reverse</span></code></dt><dd><p>Pointer to the link for the reverse direction of a pad to pad
link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Link flags, as defined in uapi/media.h (MEDIA_LNK_FL_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_backlink</span></code></dt><dd><p>Indicate if the link is a backlink.</p>
</dd>
</dl>
<dl class="c enum">
<dt id="c.media_pad_signal_type">
<em class="property">enum </em><code class="sig-name descname">media_pad_signal_type</code><a class="headerlink" href="#c.media_pad_signal_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>type of the signal inside a media pad</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PAD_SIGNAL_DEFAULT</span></code></dt><dd><p>Default signal. Use this when all inputs or all outputs are
uniquely identified by the pad number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PAD_SIGNAL_ANALOG</span></code></dt><dd><p>The pad contains an analog signal. It can be Radio Frequency,
Intermediate Frequency, a baseband signal or sub-cariers.
Tuner inputs, IF-PLL demodulators, composite and s-video signals
should use it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PAD_SIGNAL_DV</span></code></dt><dd><p>Contains a digital video signal, with can be a bitstream of samples
taken from an analog TV video source. On such case, it usually
contains the VBI data on it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PAD_SIGNAL_AUDIO</span></code></dt><dd><p>Contains an Intermediate Frequency analog signal from an audio
sub-carrier or an audio bitstream. IF signals are provided by tuners
and consumed by audio AM/FM decoders. Bitstream audio is provided by
an audio decoder.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_pad">
<em class="property">struct </em><code class="sig-name descname">media_pad</code><a class="headerlink" href="#c.media_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A media pad graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_pad {
  struct media_gobj graph_obj;
  struct media_entity *entity;
  u16 index;
  enum media_pad_signal_type sig_type;
  unsigned long flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">graph_obj</span></code></dt><dd><p>Embedded structure containing the media object common data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>Entity this pad belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Pad index in the entity pads array, numbered from 0 to n</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_type</span></code></dt><dd><p>Type of the signal inside a media pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Pad flags, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_*</span></code>)</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_entity_operations">
<em class="property">struct </em><code class="sig-name descname">media_entity_operations</code><a class="headerlink" href="#c.media_entity_operations" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media entity operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_entity_operations {
  int (*get_fwnode_pad)(struct media_entity *entity, struct fwnode_endpoint *endpoint);
  int (*link_setup)(struct media_entity *entity,const struct media_pad *local, const struct media_pad *remote, u32 flags);
  int (*link_validate)(struct media_link *link);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">get_fwnode_pad</span></code></dt><dd><p>Return the pad number based on a fwnode endpoint or
a negative value on error. This operation can be used
to map a fwnode to a media pad number. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_setup</span></code></dt><dd><p>Notify the entity of link changes. The operation can
return an error, in which case link setup will be
cancelled. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_validate</span></code></dt><dd><p>Return whether a link is valid from the entity point of
view. The <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> function
validates all links by calling this operation. Optional.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Those these callbacks are called with struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device.graph_mutex</span></code></a>
mutex held.</p>
</div>
<dl class="c enum">
<dt id="c.media_entity_type">
<em class="property">enum </em><code class="sig-name descname">media_entity_type</code><a class="headerlink" href="#c.media_entity_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media entity type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_ENTITY_TYPE_BASE</span></code></dt><dd><p>The entity isn’t embedded in another subsystem structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_ENTITY_TYPE_VIDEO_DEVICE</span></code></dt><dd><p>The entity is embedded in a <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_ENTITY_TYPE_V4L2_SUBDEV</span></code></dt><dd><p>The entity is embedded in a <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a> instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Media entity objects are often not instantiated directly, but the media
entity structure is inherited by (through embedding) other subsystem-specific
structures. The media entity type identifies the type of the subclass
structure that implements a media entity instance.</p>
<p>This allows runtime type identification of media entities and safe casting to
the correct object type. For instance, a media entity structure instance
embedded in a v4l2_subdev structure instance will have the type
<code class="docutils literal notranslate"><span class="pre">MEDIA_ENTITY_TYPE_V4L2_SUBDEV</span></code> and can safely be cast to a <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>
structure using the <a class="reference internal" href="../basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal notranslate"><span class="pre">container_of()</span></code></a> macro.</p>
<dl class="c struct">
<dt id="c.media_entity">
<em class="property">struct </em><code class="sig-name descname">media_entity</code><a class="headerlink" href="#c.media_entity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A media entity graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_entity {
  struct media_gobj graph_obj;
  const char *name;
  enum media_entity_type obj_type;
  u32 function;
  unsigned long flags;
  u16 num_pads;
  u16 num_links;
  u16 num_backlinks;
  int internal_idx;
  struct media_pad *pads;
  struct list_head links;
  const struct media_entity_operations *ops;
  int stream_count;
  int use_count;
  struct media_pipeline *pipe;
  union {
    struct {
      u32 major;
      u32 minor;
    } dev;
  } info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">graph_obj</span></code></dt><dd><p>Embedded structure containing the media object common data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Entity name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj_type</span></code></dt><dd><p>Type of the object that implements the media_entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>Entity main function, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_ENT_F_*</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Entity flags, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_ENT_FL_*</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_pads</span></code></dt><dd><p>Number of sink and source pads.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_links</span></code></dt><dd><p>Total number of links, forward and back, enabled and disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_backlinks</span></code></dt><dd><p>Number of backlinks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal_idx</span></code></dt><dd><p>An unique internal entity specific number. The numbers are
re-used if entities are unregistered or registered again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pads</span></code></dt><dd><p>Pads array with the size defined by <strong>num_pads</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt><dd><p>List of data links.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Entity operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_count</span></code></dt><dd><p>Stream count for the entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_count</span></code></dt><dd><p>Use count for the entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p>Pipeline this entity belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>Union with devnode information.  Kept just for backward
compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info.dev</span></code></dt><dd><p>Contains device major and minor info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info.dev.major</span></code></dt><dd><p>device node major, if the device is a devnode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info.dev.minor</span></code></dt><dd><p>device node minor, if the device is a devnode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>stream_count</strong> and <strong>use_count</strong> reference counts must never be
negative, but are signed integers on purpose: a simple <code class="docutils literal notranslate"><span class="pre">WARN_ON(&lt;0)</span></code>
check can be used to detect reference count bugs that would make them
negative.</p>
</div>
<dl class="c struct">
<dt id="c.media_interface">
<em class="property">struct </em><code class="sig-name descname">media_interface</code><a class="headerlink" href="#c.media_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A media interface graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_interface {
  struct media_gobj               graph_obj;
  struct list_head                links;
  u32 type;
  u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">graph_obj</span></code></dt><dd><p>embedded graph object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt><dd><p>List of links pointing to graph entities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the interface as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_INTF_T_*</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Interface flags as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_INTF_FL_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, no flags for <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_interface</span></code></a> is defined.</p>
</div>
<dl class="c struct">
<dt id="c.media_intf_devnode">
<em class="property">struct </em><code class="sig-name descname">media_intf_devnode</code><a class="headerlink" href="#c.media_intf_devnode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A media interface via a device node.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_intf_devnode {
  struct media_interface          intf;
  u32 major;
  u32 minor;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">intf</span></code></dt><dd><p>embedded interface object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">major</span></code></dt><dd><p>Major number of a device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>Minor number of a device node</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_entity_id">
u32 <code class="sig-name descname">media_entity_id</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the media entity graph object id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_type">
<em class="property">enum</em> <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a> <code class="sig-name descname">media_type</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the media object type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_id">
u32 <code class="sig-name descname">media_id</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the media object ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_gobj_gen_id">
u32 <code class="sig-name descname">media_gobj_gen_id</code><span class="sig-paren">(</span><em class="property">enum</em> <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a> <em>type</em>, u64 <em>local_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_gen_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>encapsulates type and ID on at the object ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">media_gobj_type</span> <span class="pre">type</span></code></dt><dd><p>object type as define at enum <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">local_id</span></code></dt><dd><p>next ID, from struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device.id</span></code></a>.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.is_media_entity_v4l2_video_device">
bool <code class="sig-name descname">is_media_entity_v4l2_video_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_media_entity_v4l2_video_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if the entity is a video_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to entity</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entity is an instance of a video_device object and can
safely be cast to a <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> using the <a class="reference internal" href="../basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal notranslate"><span class="pre">container_of()</span></code></a> macro, or
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.is_media_entity_v4l2_subdev">
bool <code class="sig-name descname">is_media_entity_v4l2_subdev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_media_entity_v4l2_subdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if the entity is a v4l2_subdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to entity</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entity is an instance of a <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> object and can
safely be cast to a struct <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> using the <a class="reference internal" href="../basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal notranslate"><span class="pre">container_of()</span></code></a> macro, or
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.__media_entity_enum_init">
int <code class="sig-name descname">__media_entity_enum_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, int <em>idx_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_entity_enum_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx_max</span></code></dt><dd><p>Maximum number of entities in the enumeration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns zero on success or a negative error code.</p>
<dl class="c function">
<dt id="c.media_entity_enum_cleanup">
void <code class="sig-name descname">media_entity_enum_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release resources of an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration to be released</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_entity_enum_zero">
void <code class="sig-name descname">media_entity_enum_zero</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_zero" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear the entire enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration to be cleared</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_entity_enum_set">
void <code class="sig-name descname">media_entity_enum_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a single entity in the enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Entity to be marked</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_entity_enum_clear">
void <code class="sig-name descname">media_entity_enum_clear</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_clear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unmark a single entity in the enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Entity to be unmarked</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_entity_enum_test">
bool <code class="sig-name descname">media_entity_enum_test</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_test" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the entity is marked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Entity to be tested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the entity was marked.</p>
<dl class="c function">
<dt id="c.media_entity_enum_test_and_set">
bool <code class="sig-name descname">media_entity_enum_test_and_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_test_and_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the entity is marked, and mark it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Entity to be tested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the entity was marked, and mark it before doing so.</p>
<dl class="c function">
<dt id="c.media_entity_enum_empty">
bool <code class="sig-name descname">media_entity_enum_empty</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the entire enum is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum</span></code></dt><dd><p>Entity enumeration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the entity was empty.</p>
<dl class="c function">
<dt id="c.media_entity_enum_intersects">
bool <code class="sig-name descname">media_entity_enum_intersects</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum1</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>ent_enum2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_intersects" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether two enums intersect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum1</span></code></dt><dd><p>First entity enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*ent_enum2</span></code></dt><dd><p>Second entity enumeration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if entity enumerations <strong>ent_enum1</strong> and <strong>ent_enum2</strong> intersect,
otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<dl class="c macro">
<dt id="c.gobj_to_entity">
<code class="sig-name descname">gobj_to_entity</code><a class="headerlink" href="#c.gobj_to_entity" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">gobj_to_entity</span> <span class="pre">(gobj)</span></code></p>
<blockquote>
<div><p>returns the struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.gobj_to_pad">
<code class="sig-name descname">gobj_to_pad</code><a class="headerlink" href="#c.gobj_to_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">gobj_to_pad</span> <span class="pre">(gobj)</span></code></p>
<blockquote>
<div><p>returns the struct <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_pad</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.gobj_to_link">
<code class="sig-name descname">gobj_to_link</code><a class="headerlink" href="#c.gobj_to_link" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">gobj_to_link</span> <span class="pre">(gobj)</span></code></p>
<blockquote>
<div><p>returns the struct <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_link</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.gobj_to_intf">
<code class="sig-name descname">gobj_to_intf</code><a class="headerlink" href="#c.gobj_to_intf" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">gobj_to_intf</span> <span class="pre">(gobj)</span></code></p>
<blockquote>
<div><p>returns the struct <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_interface</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.intf_to_devnode">
<code class="sig-name descname">intf_to_devnode</code><a class="headerlink" href="#c.intf_to_devnode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">intf_to_devnode</span> <span class="pre">(intf)</span></code></p>
<blockquote>
<div><p>returns the <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_intf_devnode</span></code></a> pointer from the <strong>intf</strong> contained on it.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">intf</span></code></dt><dd><p>Pointer to struct <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_intf_devnode</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_gobj_create">
void <code class="sig-name descname">media_gobj_create</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">enum</em> <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a> <em>type</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a graph object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>Pointer to the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> that contains the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">media_gobj_type</span> <span class="pre">type</span></code></dt><dd><p>Type of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine initializes the embedded struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> inside a
media graph object. It is called automatically if <code class="docutils literal notranslate"><span class="pre">media_*_create</span></code>
function calls are used. However, if the object (entity, link, pad,
interface) is embedded on some other object, this function should be
called before registering the object at the media controller.</p>
<dl class="c function">
<dt id="c.media_gobj_destroy">
void <code class="sig-name descname">media_gobj_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop using a graph object on a media device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*gobj</span></code></dt><dd><p>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_gobj</span></code></a> graph object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by all routines like <a class="reference internal" href="#c.media_device_unregister" title="media_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_unregister()</span></code></a>
that remove/destroy media graph objects.</p>
<dl class="c function">
<dt id="c.media_entity_pads_init">
int <code class="sig-name descname">media_entity_pads_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em>, u16 <em>num_pads</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>pads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_pads_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the entity pads</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>entity where the pads belong</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">num_pads</span></code></dt><dd><p>total number of sink and source pads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*pads</span></code></dt><dd><p>Array of <strong>num_pads</strong> pads.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The pads array is managed by the entity driver and passed to
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a> where its pointer will be stored in the
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> structure.</p>
<p>If no pads are needed, drivers could either directly fill
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity-&gt;num_pads</span></code></a> with 0 and <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity-&gt;pads</span></code></a> with <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or call
this function that will do the same.</p>
<p>As the number of pads is known in advance, the pads array is not allocated
dynamically but is managed by the entity driver. Most drivers will embed the
pads array in a driver-specific structure, avoiding dynamic allocation.</p>
<p>Drivers must set the direction of every pad in the pads array before calling
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a>. The function will initialize the other pads fields.</p>
<dl class="c function">
<dt id="c.media_entity_cleanup">
void <code class="sig-name descname">media_entity_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free resources associated with an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>entity where the pads belong</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called during the cleanup phase after unregistering
the entity (currently, it does nothing).</p>
<dl class="c function">
<dt id="c.media_get_pad_index">
int <code class="sig-name descname">media_get_pad_index</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em>, bool <em>is_sink</em>, <em class="property">enum</em> <a class="reference internal" href="#c.media_pad_signal_type" title="media_pad_signal_type">media_pad_signal_type</a> <em>sig_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_get_pad_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieves a pad index from an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>entity where the pads belong</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_sink</span></code></dt><dd><p>true if the pad is a sink, false if it is a source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">media_pad_signal_type</span> <span class="pre">sig_type</span></code></dt><dd><p>type of signal of the pad to be search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function finds the first pad index inside an entity that
satisfies both <strong>is_sink</strong> and <strong>sig_type</strong> conditions.</p>
<p>On success, return the pad number. If the pad was not found or the media
entity is a NULL pointer, return -EINVAL.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.media_create_pad_link">
int <code class="sig-name descname">media_create_pad_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>source</em>, u16 <em>source_pad</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>sink</em>, u16 <em>sink_pad</em>, u32 <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_create_pad_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a link between two entities.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*source</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> of the source pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">source_pad</span></code></dt><dd><p>number of the source pad in the pads array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*sink</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> of the sink pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">sink_pad</span></code></dt><dd><p>number of the sink pad in the pads array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link flags, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code></dt><dd><p>Indicates that the link is enabled and can be used to transfer media data.
When two or more links target a sink pad, only one of them can be
enabled at a time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code></dt><dd><p>Indicates that the link enabled state can’t be modified at runtime. If
<code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> is set, then <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> must also be
set, since an immutable link is always enabled.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before calling this function, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a> and
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a> should be called previously for both ends.</p>
</div>
<dl class="c function">
<dt id="c.media_create_pad_links">
int <code class="sig-name descname">media_create_pad_links</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">const</em> u32 <em>source_function</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>source</em>, <em class="property">const</em> u16 <em>source_pad</em>, <em class="property">const</em> u32 <em>sink_function</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>sink</em>, <em class="property">const</em> u16 <em>sink_pad</em>, u32 <em>flags</em>, <em class="property">const</em> bool <em>allow_both_undefined</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_create_pad_links" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a link between two entities.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>Pointer to the media_device that contains the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">source_function</span></code></dt><dd><p>Function of the source entities. Used only if <strong>source</strong> is
NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*source</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> of the source pad. If NULL, it will use
all entities that matches the <strong>sink_function</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">source_pad</span></code></dt><dd><p>number of the source pad in the pads array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">sink_function</span></code></dt><dd><p>Function of the sink entities. Used only if <strong>sink</strong> is NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*sink</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> of the sink pad. If NULL, it will use
all entities that matches the <strong>sink_function</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">sink_pad</span></code></dt><dd><p>number of the sink pad in the pads array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link flags, as defined in include/uapi/linux/media.h.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">bool</span> <span class="pre">allow_both_undefined</span></code></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">true</span></code>, then both <strong>source</strong> and <strong>sink</strong> can be NULL.
In such case, it will create a crossbar between all entities that
matches <strong>source_function</strong> to all entities that matches <strong>sink_function</strong>.
If <code class="docutils literal notranslate"><span class="pre">false</span></code>, it will return 0 and won’t create any link if both <strong>source</strong>
and <strong>sink</strong> are NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl class="simple">
<dt>A <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> flag indicates that the link is enabled and can be</dt><dd><p>used to transfer media data. If multiple links are created and this
flag is passed as an argument, only the first created link will have
this flag.</p>
</dd>
<dt>A <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> flag indicates that the link enabled state can’t</dt><dd><p>be modified at runtime. If <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> is set, then
<code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> must also be set since an immutable link is
always enabled.</p>
</dd>
</dl>
<p>It is common for some devices to have multiple source and/or sink entities
of the same type that should be linked. While <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_pad_link()</span></code></a>
creates link by link, this function is meant to allow 1:n, n:1 and even
cross-bar (n:n) links.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before calling this function, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a> and
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a> should be called previously for the
entities to be linked.</p>
</div>
<dl class="c function">
<dt id="c.media_entity_remove_links">
void <code class="sig-name descname">media_entity_remove_links</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_remove_links" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove all links associated with an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is called automatically when an entity is unregistered via
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a>.</p>
</div>
<dl class="c function">
<dt id="c.__media_entity_setup_link">
int <code class="sig-name descname">__media_entity_setup_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>link</em>, u32 <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_entity_setup_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Configure a media link without locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>The link being configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link configuration flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bulk of link setup is handled by the two entities connected through the
link. This function notifies both entities of the link configuration change.</p>
<p>If the link is immutable or if the current and new configuration are
identical, return immediately.</p>
<p>The user is expected to hold link-&gt;source-&gt;parent-&gt;mutex. If not,
<a class="reference internal" href="#c.media_entity_setup_link" title="media_entity_setup_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_setup_link()</span></code></a> should be used instead.</p>
<dl class="c function">
<dt id="c.media_entity_setup_link">
int <code class="sig-name descname">media_entity_setup_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>link</em>, u32 <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_setup_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>changes the link flags properties in runtime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_link</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>the requested new link flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The only configurable property is the <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> link flag
to enable/disable a link. Links marked with the
<code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> link flag can not be enabled or disabled.</p>
<p>When a link is enabled or disabled, the media framework calls the
link_setup operation for the two entities at the source and sink of the
link, in that order. If the second link_setup call fails, another
link_setup call is made on the first entity to restore the original link
flags.</p>
<p>Media device drivers can be notified of link setup operations by setting the
<a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device.link_notify</span></code></a> pointer to a callback function. If provided, the
notification callback will be called before enabling and after disabling
links.</p>
<p>Entity drivers must implement the link_setup operation if any of their links
is non-immutable. The operation must either configure the hardware or store
the configuration information to be applied later.</p>
<p>Link configuration must not have any side effect on other links. If an
enabled link at a sink pad prevents another link at the same pad from
being enabled, the link_setup operation must return <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> and can’t
implicitly disable the first enabled link.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The valid values of the flags for the link is the same as described
on <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_pad_link()</span></code></a>, for pad to pad links or the same as described
on <a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_create_intf_link()</span></code></a>, for interface to entity links.</p>
</div>
<dl class="c function">
<dt id="c.media_entity_find_link">
<em class="property">struct</em> <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<code class="sig-name descname">media_entity_find_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>source</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>sink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_find_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a link between two pads</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*source</span></code></dt><dd><p>Source pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*sink</span></code></dt><dd><p>Sink pad</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>returns a pointer to the link between the two entities. If no
such link exists, return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.media_entity_remote_pad">
<em class="property">struct</em> <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<code class="sig-name descname">media_entity_remote_pad</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_remote_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the pad at the remote end of a link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*pad</span></code></dt><dd><p>Pad at the local end of the link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a remote pad connected to the given pad by iterating over all
links originating or terminating at that pad until an enabled link is found.</p>
<p><strong>Return</strong></p>
<p>returns a pointer to the pad at the remote end of the first found
enabled link, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no enabled link has been found.</p>
<dl class="c function">
<dt id="c.media_entity_get_fwnode_pad">
int <code class="sig-name descname">media_entity_get_fwnode_pad</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em>, <em class="property">struct</em> fwnode_handle *<em>fwnode</em>, unsigned long <em>direction_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_get_fwnode_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get pad number from fwnode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>The entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>Pointer to the fwnode_handle which should be used to find the pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">direction_flags</span></code></dt><dd><p>Expected direction of the pad, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_PAD_FL_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to resolve the media pad number from
a fwnode. This is useful for devices which use more complex
mappings of media pads.</p>
<p>If the entity does not implement the get_fwnode_pad() operation
then this function searches the entity for the first pad that
matches the <strong>direction_flags</strong>.</p>
<p><strong>Return</strong></p>
<p>returns the pad number on success or a negative error code.</p>
<dl class="c function">
<dt id="c.media_graph_walk_init">
int <code class="sig-name descname">media_graph_walk_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>graph</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate resources used by graph walk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*graph</span></code></dt><dd><p>Media graph structure that will be used to walk the graph</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>Pointer to the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> that contains the object</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_graph_walk_cleanup">
void <code class="sig-name descname">media_graph_walk_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release resources used by graph walk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*graph</span></code></dt><dd><p>Media graph structure that will be used to walk the graph</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_graph_walk_start">
void <code class="sig-name descname">media_graph_walk_start</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>graph</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start walking the media graph at a given entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*graph</span></code></dt><dd><p>Media graph structure that will be used to walk the graph</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Starting entity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before using this function, <a class="reference internal" href="#c.media_graph_walk_init" title="media_graph_walk_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_graph_walk_init()</span></code></a> must be
used to allocate resources used for walking the graph. This
function initializes the graph traversal structure to walk the
entities graph starting at the given entity. The traversal
structure must not be modified by the caller during graph
traversal. After the graph walk, the resources must be released
using <a class="reference internal" href="#c.media_graph_walk_cleanup" title="media_graph_walk_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_graph_walk_cleanup()</span></code></a>.</p>
<dl class="c function">
<dt id="c.media_graph_walk_next">
<em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<code class="sig-name descname">media_graph_walk_next</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next entity in the graph</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*graph</span></code></dt><dd><p>Media graph structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a depth-first traversal of the given media entities graph.</p>
<p>The graph structure must have been previously initialized with a call to
<a class="reference internal" href="#c.media_graph_walk_start" title="media_graph_walk_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_graph_walk_start()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>returns the next entity in the graph or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the whole graph
have been traversed.</p>
<dl class="c function">
<dt id="c.media_pipeline_start">
int <code class="sig-name descname">media_pipeline_start</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_pipeline" title="media_pipeline">media_pipeline</a> *<em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_pipeline_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Starting entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*pipe</span></code></dt><dd><p>Media pipeline to be assigned to all entities in the pipeline.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given entity through enabled links, either
directly or indirectly, as streaming. The given pipeline object is assigned
to every entity in the pipeline and stored in the media_entity pipe field.</p>
<p>Calls to this function can be nested, in which case the same number of
<a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a> calls will be required to stop streaming. The
pipeline pointer must be identical for all nested calls to
<a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a>.</p>
<dl class="c function">
<dt id="c.__media_pipeline_start">
int <code class="sig-name descname">__media_pipeline_start</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_pipeline" title="media_pipeline">media_pipeline</a> *<em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_pipeline_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Starting entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*pipe</span></code></dt><dd><p>Media pipeline to be assigned to all entities in the pipeline.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: This is the non-locking version of <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a></p>
<dl class="c function">
<dt id="c.media_pipeline_stop">
void <code class="sig-name descname">media_pipeline_stop</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_pipeline_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Starting entity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given entity through enabled links, either
directly or indirectly, as not streaming. The media_entity pipe field is
reset to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>If multiple calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> have been made, the same
number of calls to this function are required to mark the pipeline as not
streaming.</p>
<dl class="c function">
<dt id="c.__media_pipeline_stop">
void <code class="sig-name descname">__media_pipeline_stop</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_pipeline_stop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Starting entity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the non-locking version of <a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a></p>
</div>
<dl class="c function">
<dt id="c.media_devnode_create">
<em class="property">struct</em> <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode">media_intf_devnode</a> *<code class="sig-name descname">media_devnode_create</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, u32 <em>type</em>, u32 <em>flags</em>, u32 <em>major</em>, u32 <em>minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates and initializes a device node interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>type of the interface, as given by
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_INTF_T_*</span></code>) macros.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Interface flags, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_INTF_FL_*</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">major</span></code></dt><dd><p>Device node major number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">minor</span></code></dt><dd><p>Device node minor number.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>if succeeded, returns a pointer to the newly allocated</dt><dd><p><a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_intf_devnode</span></code></a> pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, no flags for <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_interface</span></code></a> is defined.</p>
</div>
<dl class="c function">
<dt id="c.media_devnode_remove">
void <code class="sig-name descname">media_devnode_remove</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode">media_intf_devnode</a> *<em>devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>removes a device node interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_intf_devnode</span> <span class="pre">*devnode</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_intf_devnode</span></code></a> to be freed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device node interface is removed, all links to it are automatically
removed.</p>
<dl class="c macro">
<dt id="c.media_create_intf_link">
<code class="sig-name descname">media_create_intf_link</code><a class="headerlink" href="#c.media_create_intf_link" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">media_create_intf_link</span> <span class="pre">(struct</span> <span class="pre">media_entity</span> <span class="pre">*entity,</span> <span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*intf,</span> <span class="pre">u32</span> <span class="pre">flags)</span></code></p>
<blockquote>
<div><p>creates a link between an entity and an interface</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>pointer to <code class="docutils literal notranslate"><span class="pre">media_entity</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*intf</span></code></dt><dd><p>pointer to <code class="docutils literal notranslate"><span class="pre">media_interface</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link flags, as defined in
<a class="reference internal" href="../../userspace-api/media/mediactl/media-header.html#media-header"><span class="std std-ref">include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code></dt><dd><p>Indicates that the interface is connected to the entity hardware.
That’s the default value for interfaces. An interface may be disabled if
the hardware is busy due to the usage of some other interface that it is
currently controlling the hardware.</p>
<p>A typical example is an hybrid TV device that handle only one type of
stream on a given time. So, when the digital TV is streaming,
the V4L2 interfaces won’t be enabled, as such device is not able to
also stream analog TV or radio.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before calling this function, <a class="reference internal" href="#c.media_devnode_create" title="media_devnode_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_create()</span></code></a> should be called for
the interface and <a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a> should be called for the
interface that will be part of the link.</p>
</div>
<dl class="c function">
<dt id="c.__media_remove_intf_link">
void <code class="sig-name descname">__media_remove_intf_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_remove_intf_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a single interface link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_link</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an unlocked version of <a class="reference internal" href="#c.media_remove_intf_link" title="media_remove_intf_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_remove_intf_link()</span></code></a></p>
</div>
<dl class="c function">
<dt id="c.media_remove_intf_link">
void <code class="sig-name descname">media_remove_intf_link</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_remove_intf_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a single interface link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_link</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prefer to use this one, instead of <a class="reference internal" href="#c.__media_remove_intf_link" title="__media_remove_intf_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_remove_intf_link()</span></code></a></p>
</div>
<dl class="c function">
<dt id="c.__media_remove_intf_links">
void <code class="sig-name descname">__media_remove_intf_links</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_interface" title="media_interface">media_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_remove_intf_links" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove all links associated with an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*intf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_interface</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an unlocked version of <a class="reference internal" href="#c.media_remove_intf_links" title="media_remove_intf_links"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_remove_intf_links()</span></code></a>.</p>
</div>
<dl class="c function">
<dt id="c.media_remove_intf_links">
void <code class="sig-name descname">media_remove_intf_links</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_interface" title="media_interface">media_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_remove_intf_links" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove all links associated with an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*intf</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_interface</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>This is called automatically when an entity is unregistered via
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_register_entity()</span></code></a> and by <a class="reference internal" href="#c.media_devnode_remove" title="media_devnode_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_devnode_remove()</span></code></a>.</p></li>
<li><p>Prefer to use this one, instead of <a class="reference internal" href="#c.__media_remove_intf_links" title="__media_remove_intf_links"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_remove_intf_links()</span></code></a>.</p></li>
</ol>
</div>
<dl class="c macro">
<dt id="c.media_entity_call">
<code class="sig-name descname">media_entity_call</code><a class="headerlink" href="#c.media_entity_call" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">media_entity_call</span> <span class="pre">(entity,</span> <span class="pre">operation,</span> <span class="pre">args...)</span></code></p>
<blockquote>
<div><p>Calls a <a class="reference internal" href="#c.media_entity_operations" title="media_entity_operations"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity_operations</span></code></a> operation on an entity</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>entity where the <strong>operation</strong> will be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operation</span></code></dt><dd><p>type of the operation. Should be the name of a member of
struct <a class="reference internal" href="#c.media_entity_operations" title="media_entity_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity_operations</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function will check if <strong>operation</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. On such case,
it will issue a call to <strong>operation</strong>(<strong>entity</strong>, <strong>args</strong>).</p>
<dl class="c enum">
<dt id="c.media_request_state">
<em class="property">enum </em><code class="sig-name descname">media_request_state</code><a class="headerlink" href="#c.media_request_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>media request state</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_IDLE</span></code></dt><dd><p>Idle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_VALIDATING</span></code></dt><dd><p>Validating the request, no state changes
allowed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_QUEUED</span></code></dt><dd><p>Queued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_COMPLETE</span></code></dt><dd><p>Completed, the request is done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_CLEANING</span></code></dt><dd><p>Cleaning, the request is being re-inited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEDIA_REQUEST_STATE_UPDATING</span></code></dt><dd><p>The request is being updated, i.e.
request objects are being added,
modified or removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NR_OF_MEDIA_REQUEST_STATE</span></code></dt><dd><p>The number of media request states, used
internally for sanity check purposes</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_request">
<em class="property">struct </em><code class="sig-name descname">media_request</code><a class="headerlink" href="#c.media_request" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media device request</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_request {
  struct media_device *mdev;
  struct kref kref;
  char debug_str[TASK_COMM_LEN + 11];
  enum media_request_state state;
  unsigned int updating_count;
  unsigned int access_count;
  struct list_head objects;
  unsigned int num_incomplete_objects;
  wait_queue_head_t poll_wait;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>Media device this request belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Reference count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debug_str</span></code></dt><dd><p>Prefix for debug messages (process name:fd)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>The state of the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">updating_count</span></code></dt><dd><p>count the number of request updates that are in progress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access_count</span></code></dt><dd><p>count the number of request accesses that are in progress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">objects</span></code></dt><dd><p>List of <strong>struct</strong> media_request_object request objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_incomplete_objects</span></code></dt><dd><p>The number of incomplete objects in the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_wait</span></code></dt><dd><p>Wait queue for poll</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Serializes access to this struct</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.media_request_lock_for_access">
int <code class="sig-name descname">media_request_lock_for_access</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_lock_for_access" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock the request to access its objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use before accessing a completed request. A reference to the request must
be held during the access. This usually takes place automatically through
a file handle. Use <strong>media_request_unlock_for_access</strong> when done.</p>
<dl class="c function">
<dt id="c.media_request_unlock_for_access">
void <code class="sig-name descname">media_request_unlock_for_access</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_unlock_for_access" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock a request previously locked for access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a request that has previously been locked using
<strong>media_request_lock_for_access</strong>.</p>
<dl class="c function">
<dt id="c.media_request_lock_for_update">
int <code class="sig-name descname">media_request_lock_for_update</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_lock_for_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lock the request for updating its objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use before updating a request, i.e. adding, modifying or removing a request
object in it. A reference to the request must be held during the update. This
usually takes place automatically through a file handle. Use
<strong>media_request_unlock_for_update</strong> when done.</p>
<dl class="c function">
<dt id="c.media_request_unlock_for_update">
void <code class="sig-name descname">media_request_unlock_for_update</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_unlock_for_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlock a request previously locked for update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a request that has previously been locked using
<strong>media_request_lock_for_update</strong>.</p>
<dl class="c function">
<dt id="c.media_request_get">
void <code class="sig-name descname">media_request_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the media request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the media request.</p>
<dl class="c function">
<dt id="c.media_request_put">
void <code class="sig-name descname">media_request_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Put the media request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put the media request. The media request will be released
when the refcount reaches 0.</p>
<dl class="c function">
<dt id="c.media_request_get_by_fd">
<em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<code class="sig-name descname">media_request_get_by_fd</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, int <em>request_fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_get_by_fd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a media request by fd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>Media device this request belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">request_fd</span></code></dt><dd><p>The file descriptor of the request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the request represented by <strong>request_fd</strong> that is owned
by the media device.</p>
<p>Return a -EBADR error pointer if requests are not supported
by this driver. Return -EINVAL if the request was not found.
Return the pointer to the request if found: the caller will
have to call <strong>media_request_put</strong> when it finished using the
request.</p>
<dl class="c function">
<dt id="c.media_request_alloc">
int <code class="sig-name descname">media_request_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, int *<em>alloc_fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate the media request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>Media device this request belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*alloc_fd</span></code></dt><dd><p>Store the request’s file descriptor in this int</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocated the media request and put the fd in <strong>alloc_fd</strong>.</p>
<dl class="c struct">
<dt id="c.media_request_object_ops">
<em class="property">struct </em><code class="sig-name descname">media_request_object_ops</code><a class="headerlink" href="#c.media_request_object_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Media request object operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_request_object_ops {
  int (*prepare)(struct media_request_object *object);
  void (*unprepare)(struct media_request_object *object);
  void (*queue)(struct media_request_object *object);
  void (*unbind)(struct media_request_object *object);
  void (*release)(struct media_request_object *object);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>Validate and prepare the request object, optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare</span></code></dt><dd><p>Unprepare the request object, optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p>Queue the request object, optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Unbind the request object, optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Release the request object, required.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.media_request_object">
<em class="property">struct </em><code class="sig-name descname">media_request_object</code><a class="headerlink" href="#c.media_request_object" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An opaque object that belongs to a media request</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct media_request_object {
  const struct media_request_object_ops *ops;
  void *priv;
  struct media_request *req;
  struct list_head list;
  struct kref kref;
  bool completed;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>object’s operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>object’s priv pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req</span></code></dt><dd><p>the request this object belongs to (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List entry of the object for <strong>struct</strong> media_request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Reference count of the object, acquire before releasing req-&gt;lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">completed</span></code></dt><dd><p>If true, then this object was completed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An object related to the request. This struct is always embedded in
another struct that contains the actual data for this request object.</p>
<dl class="c function">
<dt id="c.media_request_object_get">
void <code class="sig-name descname">media_request_object_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a media request object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a media request object.</p>
<dl class="c function">
<dt id="c.media_request_object_put">
void <code class="sig-name descname">media_request_object_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Put a media request object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put a media request object. Once all references are gone, the
object’s memory is released.</p>
<dl class="c function">
<dt id="c.media_request_object_find">
<em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<code class="sig-name descname">media_request_object_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.media_request_object_ops" title="media_request_object_ops">media_request_object_ops</a> *<em>ops</em>, void *<em>priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find an object in a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_request_object_ops</span> <span class="pre">*ops</span></code></dt><dd><p>Find an object with this ops value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>Find an object with this priv value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Both <strong>ops</strong> and <strong>priv</strong> must be non-NULL.</p>
<p>Returns the object pointer or NULL if not found. The caller must
call <a class="reference internal" href="#c.media_request_object_put" title="media_request_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_request_object_put()</span></code></a> once it finished using the object.</p>
<p>Since this function needs to walk the list of objects it takes
the <strong>req-&gt;lock</strong> spin lock to make this safe.</p>
<dl class="c function">
<dt id="c.media_request_object_init">
void <code class="sig-name descname">media_request_object_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise a media request object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise a media request object. The object will be released using the
release callback of the ops once it has no references (this function
initialises references to one).</p>
<dl class="c function">
<dt id="c.media_request_object_bind">
int <code class="sig-name descname">media_request_object_bind</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request" title="media_request">media_request</a> *<em>req</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.media_request_object_ops" title="media_request_object_ops">media_request_object_ops</a> *<em>ops</em>, void *<em>priv</em>, bool <em>is_buffer</em>, <em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_bind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Bind a media request object to a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>The media request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_request_object_ops</span> <span class="pre">*ops</span></code></dt><dd><p>The object ops for this object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>A driver-specific priv pointer associated with this object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_buffer</span></code></dt><dd><p>Set to true if the object a buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Bind this object to the request and set the ops and priv values of
the object so it can be found later with <a class="reference internal" href="#c.media_request_object_find" title="media_request_object_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_request_object_find()</span></code></a>.</p>
<p>Every bound object must be unbound or completed by the kernel at some
point in time, otherwise the request will never complete. When the
request is released all completed objects will be unbound by the
request core code.</p>
<p>Buffer objects will be added to the end of the request’s object
list, non-buffer objects will be added to the front of the list.
This ensures that all buffer objects are at the end of the list
and that all non-buffer objects that they depend on are processed
first.</p>
<dl class="c function">
<dt id="c.media_request_object_unbind">
void <code class="sig-name descname">media_request_object_unbind</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_unbind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unbind a media request object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unbind the media request object from the request.</p>
<dl class="c function">
<dt id="c.media_request_object_complete">
void <code class="sig-name descname">media_request_object_complete</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_request_object" title="media_request_object">media_request_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_request_object_complete" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mark the media request object as complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>The object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark the media request object as complete. Only bound objects can
be completed.</p>
<dl class="c function">
<dt id="c.media_device_usb_allocate">
<em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<code class="sig-name descname">media_device_usb_allocate</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../usb/usb.html#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em>, <em class="property">const</em> char *<em>module_name</em>, <em class="property">struct</em> module *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_usb_allocate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and return struct <code class="xref c c-type docutils literal notranslate"><span class="pre">media</span></code> device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>struct <a class="reference internal" href="../usb/usb.html#c.usb_device" title="usb_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_device</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*module_name</span></code></dt><dd><p>should be filled with <code class="docutils literal notranslate"><span class="pre">KBUILD_MODNAME</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>struct module pointer <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> for the driver.
<code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> is null for a built-in driver.
It is safe even when <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> is null.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface should be called to allocate a Media Device when multiple
drivers share usb_device and the media device. This interface allocates
<a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> structure and calls <a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_device_usb_init()</span></code></a> to initialize
it.</p>
<dl class="c function">
<dt id="c.media_device_delete">
void <code class="sig-name descname">media_device_delete</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>mdev</em>, <em class="property">const</em> char *<em>module_name</em>, <em class="property">struct</em> module *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_delete" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release media device. Calls kref_put().</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_device</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*module_name</span></code></dt><dd><p>should be filled with <code class="docutils literal notranslate"><span class="pre">KBUILD_MODNAME</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>struct module pointer <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> for the driver.
<code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> is null for a built-in driver.
It is safe even when <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code> is null.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface should be called to put Media Device Instance kref.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="cec-core.html" class="btn btn-neutral float-right" title="5. CEC Kernel Support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="rc-core.html" class="btn btn-neutral float-left" title="3. Remote Controller devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>