

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cfg80211 subsystem &mdash; The Linux Kernel 4.10.0-rc8+ documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="The Linux Kernel 4.10.0-rc8+ documentation" href="../../index.html"/>
        <link rel="up" title="Linux 802.11 Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="mac80211 subsystem (basics)" href="mac80211.html"/>
        <link rel="prev" title="Introduction" href="introduction.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.10.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux 802.11 Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">cfg80211 subsystem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-registration">Device registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#actions-and-configuration">Actions and configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scanning-and-bss-list-handling">Scanning and BSS list handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-path-helpers">Data path helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regulatory-enforcement-infrastructure">Regulatory enforcement infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rfkill-integration">RFkill integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-mode">Test mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mac80211.html">mac80211 subsystem (basics)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mac80211-advanced.html">mac80211 subsystem (advanced)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
          <li><a href="index.html">Linux 802.11 Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>cfg80211 subsystem</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/80211/cfg80211.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cfg80211-subsystem">
<h1>cfg80211 subsystem<a class="headerlink" href="#cfg80211-subsystem" title="Permalink to this headline">¶</a></h1>
<div class="section" id="device-registration">
<h2>Device registration<a class="headerlink" href="#device-registration" title="Permalink to this headline">¶</a></h2>
<p>In order for a driver to use cfg80211, it must register the hardware device
with cfg80211. This happens through a number of hardware capability structs
described below.</p>
<p>The fundamental structure for each device is the &#8216;wiphy&#8217;, of which each
instance describes a physical wireless device connected to the system. Each
such wiphy can have zero, one, or many virtual interfaces associated with
it, which need to be identified as such by pointing the network interface&#8217;s
<strong>ieee80211_ptr</strong> pointer to a <a class="reference internal" href="#c.wireless_dev" title="wireless_dev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span></code></a> which further describes
the wireless part of the interface, normally this struct is embedded in the
network interface&#8217;s private data area. Drivers can optionally allow creating
or destroying virtual interfaces on the fly, but without at least one or the
ability to create some the wireless device isn&#8217;t useful.</p>
<p>Each wiphy structure contains device capability information, and also has
a pointer to the various operations the driver offers. The definitions and
structures here describe these capabilities in detail.</p>
<dl class="type">
<dt id="c.ieee80211_channel_flags">
enum <code class="descname">ieee80211_channel_flags</code><a class="headerlink" href="#c.ieee80211_channel_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>channel flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_DISABLED</span></code></dt>
<dd>This channel is disabled.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_IR</span></code></dt>
<dd>do not initiate radiation, this includes
sending probe requests or beaconing.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_RADAR</span></code></dt>
<dd>Radar detection is required on this channel.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_HT40PLUS</span></code></dt>
<dd>extension channel above this channel
is not permitted.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_HT40MINUS</span></code></dt>
<dd>extension channel below this channel
is not permitted.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_OFDM</span></code></dt>
<dd>OFDM is not allowed on this channel.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_80MHZ</span></code></dt>
<dd>If the driver supports 80 MHz on the band,
this flag indicates that an 80 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_160MHZ</span></code></dt>
<dd>If the driver supports 160 MHz on the band,
this flag indicates that an 160 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_INDOOR_ONLY</span></code></dt>
<dd>see <code class="docutils literal"><span class="pre">NL80211_FREQUENCY_ATTR_INDOOR_ONLY</span></code></dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_IR_CONCURRENT</span></code></dt>
<dd>see <code class="docutils literal"><span class="pre">NL80211_FREQUENCY_ATTR_IR_CONCURRENT</span></code></dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_20MHZ</span></code></dt>
<dd>20 MHz bandwidth is not permitted
on this channel.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_CHAN_NO_10MHZ</span></code></dt>
<dd>10 MHz bandwidth is not permitted
on this channel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Channel flags set by the regulatory control code.</p>
<dl class="type">
<dt id="c.ieee80211_channel">
struct <code class="descname">ieee80211_channel</code><a class="headerlink" href="#c.ieee80211_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>channel definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_channel {
  enum nl80211_band band;
  u16 center_freq;
  u16 hw_value;
  u32 flags;
  int max_antenna_gain;
  int max_power;
  int max_reg_power;
  bool beacon_found;
  u32 orig_flags;
  int orig_mag;
  int orig_mpwr;
  enum nl80211_dfs_state dfs_state;
  unsigned long dfs_state_entered;
  unsigned int dfs_cac_ms;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">band</span></code></dt>
<dd>band this channel belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">center_freq</span></code></dt>
<dd>center frequency in MHz</dd>
<dt><code class="docutils literal"><span class="pre">hw_value</span></code></dt>
<dd>hardware-specific value for the channel</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>channel flags from <a class="reference internal" href="#c.ieee80211_channel_flags" title="ieee80211_channel_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">ieee80211_channel_flags</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">max_antenna_gain</span></code></dt>
<dd>maximum antenna gain in dBi</dd>
<dt><code class="docutils literal"><span class="pre">max_power</span></code></dt>
<dd>maximum transmission power (in dBm)</dd>
<dt><code class="docutils literal"><span class="pre">max_reg_power</span></code></dt>
<dd>maximum regulatory transmission power (in dBm)</dd>
<dt><code class="docutils literal"><span class="pre">beacon_found</span></code></dt>
<dd>helper to regulatory code to indicate when a beacon
has been found on this channel. Use <code class="xref c c-func docutils literal"><span class="pre">regulatory_hint_found_beacon()</span></code>
to enable this, this is useful only on 5 GHz band.</dd>
<dt><code class="docutils literal"><span class="pre">orig_flags</span></code></dt>
<dd>channel flags at registration time, used by regulatory
code to support devices with additional restrictions</dd>
<dt><code class="docutils literal"><span class="pre">orig_mag</span></code></dt>
<dd>internal use</dd>
<dt><code class="docutils literal"><span class="pre">orig_mpwr</span></code></dt>
<dd>internal use</dd>
<dt><code class="docutils literal"><span class="pre">dfs_state</span></code></dt>
<dd>current state of this channel. Only relevant if radar is required
on this channel.</dd>
<dt><code class="docutils literal"><span class="pre">dfs_state_entered</span></code></dt>
<dd>timestamp (jiffies) when the dfs state was entered.</dd>
<dt><code class="docutils literal"><span class="pre">dfs_cac_ms</span></code></dt>
<dd>DFS CAC time in milliseconds, this is valid for DFS channels.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a single channel for use
with cfg80211.</p>
<dl class="type">
<dt id="c.ieee80211_rate_flags">
enum <code class="descname">ieee80211_rate_flags</code><a class="headerlink" href="#c.ieee80211_rate_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>rate flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_SHORT_PREAMBLE</span></code></dt>
<dd>Hardware can send with short
preamble on this bitrate; only relevant in 2.4GHz band and
with CCK rates.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_MANDATORY_A</span></code></dt>
<dd>This bitrate is a mandatory rate
when used with 802.11a (on the 5 GHz band); filled by the
core code when registering the wiphy.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_MANDATORY_B</span></code></dt>
<dd>This bitrate is a mandatory rate
when used with 802.11b (on the 2.4 GHz band); filled by the
core code when registering the wiphy.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_MANDATORY_G</span></code></dt>
<dd>This bitrate is a mandatory rate
when used with 802.11g (on the 2.4 GHz band); filled by the
core code when registering the wiphy.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_ERP_G</span></code></dt>
<dd>This is an ERP rate in 802.11g mode.</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_SUPPORTS_5MHZ</span></code></dt>
<dd>Rate can be used in 5 MHz mode</dd>
<dt><code class="docutils literal"><span class="pre">IEEE80211_RATE_SUPPORTS_10MHZ</span></code></dt>
<dd>Rate can be used in 10 MHz mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hardware/specification flags for rates. These are structured
in a way that allows using the same bitrate structure for
different bands/PHY modes.</p>
<dl class="type">
<dt id="c.ieee80211_rate">
struct <code class="descname">ieee80211_rate</code><a class="headerlink" href="#c.ieee80211_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_rate {
  u32 flags;
  u16 bitrate;
  u16 hw_value;
  u16 hw_value_short;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>rate-specific flags</dd>
<dt><code class="docutils literal"><span class="pre">bitrate</span></code></dt>
<dd>bitrate in units of 100 Kbps</dd>
<dt><code class="docutils literal"><span class="pre">hw_value</span></code></dt>
<dd>driver/hardware value for this rate</dd>
<dt><code class="docutils literal"><span class="pre">hw_value_short</span></code></dt>
<dd>driver/hardware value for this rate when
short preamble is used</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a bitrate that an 802.11 PHY can
operate with. The two values <strong>hw_value</strong> and <strong>hw_value_short</strong>
are only for driver use when pointers to this structure are
passed around.</p>
<dl class="type">
<dt id="c.ieee80211_sta_ht_cap">
struct <code class="descname">ieee80211_sta_ht_cap</code><a class="headerlink" href="#c.ieee80211_sta_ht_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>STA&#8217;s HT capabilities</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_sta_ht_cap {
  u16 cap;
  bool ht_supported;
  u8 ampdu_factor;
  u8 ampdu_density;
  struct ieee80211_mcs_info mcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cap</span></code></dt>
<dd>HT capabilities map as described in 802.11n spec</dd>
<dt><code class="docutils literal"><span class="pre">ht_supported</span></code></dt>
<dd>is HT supported by the STA</dd>
<dt><code class="docutils literal"><span class="pre">ampdu_factor</span></code></dt>
<dd>Maximum A-MPDU length factor</dd>
<dt><code class="docutils literal"><span class="pre">ampdu_density</span></code></dt>
<dd>Minimum A-MPDU spacing</dd>
<dt><code class="docutils literal"><span class="pre">mcs</span></code></dt>
<dd>Supported MCS rates</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes most essential parameters needed
to describe 802.11n HT capabilities for an STA.</p>
<dl class="type">
<dt id="c.ieee80211_supported_band">
struct <code class="descname">ieee80211_supported_band</code><a class="headerlink" href="#c.ieee80211_supported_band" title="Permalink to this definition">¶</a></dt>
<dd><p>frequency band definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_supported_band {
  struct ieee80211_channel * channels;
  struct ieee80211_rate * bitrates;
  enum nl80211_band band;
  int n_channels;
  int n_bitrates;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channels</span></code></dt>
<dd>Array of channels the hardware can operate in
in this band.</dd>
<dt><code class="docutils literal"><span class="pre">bitrates</span></code></dt>
<dd>Array of bitrates the hardware can operate with
in this band. Must be sorted to give a valid &#8220;supported
rates&#8221; IE, i.e. CCK rates first, then OFDM.</dd>
<dt><code class="docutils literal"><span class="pre">band</span></code></dt>
<dd>the band this structure represents</dd>
<dt><code class="docutils literal"><span class="pre">n_channels</span></code></dt>
<dd>Number of channels in <strong>channels</strong></dd>
<dt><code class="docutils literal"><span class="pre">n_bitrates</span></code></dt>
<dd>Number of bitrates in <strong>bitrates</strong></dd>
<dt><code class="docutils literal"><span class="pre">ht_cap</span></code></dt>
<dd>HT capabilities in this band</dd>
<dt><code class="docutils literal"><span class="pre">vht_cap</span></code></dt>
<dd>VHT capabilities in this band</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a frequency band a wiphy
is able to operate in.</p>
<dl class="type">
<dt id="c.cfg80211_signal_type">
enum <code class="descname">cfg80211_signal_type</code><a class="headerlink" href="#c.cfg80211_signal_type" title="Permalink to this definition">¶</a></dt>
<dd><p>signal type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">CFG80211_SIGNAL_TYPE_NONE</span></code></dt>
<dd>no signal strength information available</dd>
<dt><code class="docutils literal"><span class="pre">CFG80211_SIGNAL_TYPE_MBM</span></code></dt>
<dd>signal strength in mBm (100*dBm)</dd>
<dt><code class="docutils literal"><span class="pre">CFG80211_SIGNAL_TYPE_UNSPEC</span></code></dt>
<dd>signal strength, increasing from 0 through 100</dd>
</dl>
<dl class="type">
<dt id="c.wiphy_params_flags">
enum <code class="descname">wiphy_params_flags</code><a class="headerlink" href="#c.wiphy_params_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>set_wiphy_params bitfield values</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_RETRY_SHORT</span></code></dt>
<dd>wiphy-&gt;retry_short has changed</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_RETRY_LONG</span></code></dt>
<dd>wiphy-&gt;retry_long has changed</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_FRAG_THRESHOLD</span></code></dt>
<dd>wiphy-&gt;frag_threshold has changed</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_RTS_THRESHOLD</span></code></dt>
<dd>wiphy-&gt;rts_threshold has changed</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_COVERAGE_CLASS</span></code></dt>
<dd>coverage class changed</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_PARAM_DYN_ACK</span></code></dt>
<dd>dynack has been enabled</dd>
</dl>
<dl class="type">
<dt id="c.wiphy_flags">
enum <code class="descname">wiphy_flags</code><a class="headerlink" href="#c.wiphy_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>wiphy capability flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_NETNS_OK</span></code></dt>
<dd>if not set, do not allow changing the netns of this
wiphy at all</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_PS_ON_BY_DEFAULT</span></code></dt>
<dd>if set to true, powersave will be enabled
by default &#8211; this flag will be set depending on the kernel&#8217;s default
on <a class="reference internal" href="#c.wiphy_new" title="wiphy_new"><code class="xref c c-func docutils literal"><span class="pre">wiphy_new()</span></code></a>, but can be changed by the driver if it has a good
reason to override the default</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_4ADDR_AP</span></code></dt>
<dd>supports 4addr mode even on AP (with a single station
on a VLAN interface)</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_4ADDR_STATION</span></code></dt>
<dd>supports 4addr mode even as a station</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_CONTROL_PORT_PROTOCOL</span></code></dt>
<dd>This device supports setting the
control port protocol ethertype. The device also honours the
control_port_no_encrypt flag.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_IBSS_RSN</span></code></dt>
<dd>The device supports IBSS RSN.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_MESH_AUTH</span></code></dt>
<dd>The device supports mesh authentication by routing
auth frames to userspace. See <strong>NL80211_MESH_SETUP_USERSPACE_AUTH</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_SUPPORTS_SCHED_SCAN</span></code></dt>
<dd>The device supports scheduled scans.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_SUPPORTS_FW_ROAM</span></code></dt>
<dd>The device supports roaming feature in the
firmware.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_AP_UAPSD</span></code></dt>
<dd>The device supports uapsd on AP.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_SUPPORTS_TDLS</span></code></dt>
<dd>The device supports TDLS (802.11z) operation.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_TDLS_EXTERNAL_SETUP</span></code></dt>
<dd>The device does not handle TDLS (802.11z)
link setup/discovery operations internally. Setup, discovery and
teardown packets should be sent through the <strong>NL80211_CMD_TDLS_MGMT</strong>
command. When this flag is not set, <strong>NL80211_CMD_TDLS_OPER</strong> should be
used for asking the driver/firmware to perform a TDLS operation.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_HAVE_AP_SME</span></code></dt>
<dd>device integrates AP SME</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_REPORTS_OBSS</span></code></dt>
<dd>the device will report beacons from other BSSes
when there are virtual interfaces in AP mode by calling
<code class="xref c c-func docutils literal"><span class="pre">cfg80211_report_obss_beacon()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</span></code></dt>
<dd>When operating as an AP, the device
responds to probe-requests in hardware.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_OFFCHAN_TX</span></code></dt>
<dd>Device supports direct off-channel TX.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL</span></code></dt>
<dd>Device supports remain-on-channel call.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_SUPPORTS_5_10_MHZ</span></code></dt>
<dd>Device supports 5 MHz and 10 MHz channels.</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_HAS_CHANNEL_SWITCH</span></code></dt>
<dd>Device supports channel switch in
beaconing mode (AP, IBSS, Mesh, ...).</dd>
<dt><code class="docutils literal"><span class="pre">WIPHY_FLAG_HAS_STATIC_WEP</span></code></dt>
<dd>The device supports static WEP key installation
before connection.</dd>
</dl>
<dl class="type">
<dt id="c.wiphy">
struct <code class="descname">wiphy</code><a class="headerlink" href="#c.wiphy" title="Permalink to this definition">¶</a></dt>
<dd><p>wireless hardware description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct wiphy {
  u8 perm_addr[ETH_ALEN];
  u8 addr_mask[ETH_ALEN];
  struct mac_address * addresses;
  const struct ieee80211_txrx_stypes * mgmt_stypes;
  const struct ieee80211_iface_combination * iface_combinations;
  int n_iface_combinations;
  u16 software_iftypes;
  u16 n_addresses;
  u16 interface_modes;
  u16 max_acl_mac_addrs;
  u32 flags;
  u32 regulatory_flags;
  u32 features;
  u8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES# 8)];
  u32 ap_sme_capa;
  enum cfg80211_signal_type signal_type;
  int bss_priv_size;
  u8 max_scan_ssids;
  u8 max_sched_scan_ssids;
  u8 max_match_sets;
  u16 max_scan_ie_len;
  u16 max_sched_scan_ie_len;
  u32 max_sched_scan_plans;
  u32 max_sched_scan_plan_interval;
  u32 max_sched_scan_plan_iterations;
  int n_cipher_suites;
  const u32 * cipher_suites;
  u8 retry_short;
  u8 retry_long;
  u32 frag_threshold;
  u32 rts_threshold;
  u8 coverage_class;
  char fw_version[ETHTOOL_FWVERS_LEN];
  u32 hw_version;
#ifdef CONFIG_PM
  const struct wiphy_wowlan_support * wowlan;
  struct cfg80211_wowlan * wowlan_config;
#endif
  u16 max_remain_on_channel_duration;
  u8 max_num_pmkids;
  u32 available_antennas_tx;
  u32 available_antennas_rx;
  u32 probe_resp_offload;
  const u8 * extended_capabilities;
  const u8 * extended_capabilities_mask;
  u8 extended_capabilities_len;
  const struct wiphy_iftype_ext_capab * iftype_ext_capab;
  unsigned int num_iftype_ext_capab;
  const void * privid;
  struct ieee80211_supported_band * bands[NUM_NL80211_BANDS];
  void (* reg_notifier) (struct wiphy *wiphy,struct regulatory_request *request);
  const struct ieee80211_regdomain __rcu * regd;
  struct device dev;
  bool registered;
  struct dentry * debugfsdir;
  const struct ieee80211_ht_cap * ht_capa_mod_mask;
  const struct ieee80211_vht_cap * vht_capa_mod_mask;
  struct list_head wdev_list;
  possible_net_t _net;
#ifdef CONFIG_CFG80211_WEXT
  const struct iw_handler_def * wext;
#endif
  const struct wiphy_coalesce_support * coalesce;
  const struct wiphy_vendor_command * vendor_commands;
  const struct nl80211_vendor_cmd_info * vendor_events;
  int n_vendor_commands;
  int n_vendor_events;
  u16 max_ap_assoc_sta;
  u8 max_num_csa_counters;
  u8 max_adj_channel_rssi_comp;
  u32 bss_select_support;
  u64 cookie_counter;
  u8 nan_supported_bands;
  char priv[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">perm_addr[ETH_ALEN]</span></code></dt>
<dd>permanent MAC address of this device</dd>
<dt><code class="docutils literal"><span class="pre">addr_mask[ETH_ALEN]</span></code></dt>
<dd>If the device supports multiple MAC addresses by masking,
set this to a mask with variable bits set to 1, e.g. if the last
four bits are variable then set it to 00-00-00-00-00-0f. The actual
variable bits shall be determined by the interfaces added, with
interfaces not matching the mask being rejected to be brought up.</dd>
<dt><code class="docutils literal"><span class="pre">addresses</span></code></dt>
<dd>If the device has more than one address, set this pointer
to a list of addresses (6 bytes each). The first one will be used
by default for perm_addr. In this case, the mask should be set to
all-zeroes. In this case it is assumed that the device can handle
the same number of arbitrary MAC addresses.</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_stypes</span></code></dt>
<dd>bitmasks of frame subtypes that can be subscribed to or
transmitted through nl80211, points to an array indexed by interface
type</dd>
<dt><code class="docutils literal"><span class="pre">iface_combinations</span></code></dt>
<dd>Valid interface combinations array, should not
list single interface types.</dd>
<dt><code class="docutils literal"><span class="pre">n_iface_combinations</span></code></dt>
<dd>number of entries in <strong>iface_combinations</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">software_iftypes</span></code></dt>
<dd>bitmask of software interface types, these are not
subject to any restrictions since they are purely managed in SW.</dd>
<dt><code class="docutils literal"><span class="pre">n_addresses</span></code></dt>
<dd>number of addresses in <strong>addresses</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">interface_modes</span></code></dt>
<dd>bitmask of interfaces types valid for this wiphy,
must be set by driver</dd>
<dt><code class="docutils literal"><span class="pre">max_acl_mac_addrs</span></code></dt>
<dd>Maximum number of MAC addresses that the device
supports for ACL.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>wiphy flags, see <a class="reference internal" href="#c.wiphy_flags" title="wiphy_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">wiphy_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">regulatory_flags</span></code></dt>
<dd>wiphy regulatory flags, see
<code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">ieee80211_regulatory_flags</span></code></dd>
<dt><code class="docutils literal"><span class="pre">features</span></code></dt>
<dd>features advertised to nl80211, see <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_feature_flags</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES#</span> <span class="pre">8)]</span></code></dt>
<dd>extended features advertised to nl80211, see
<code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_ext_feature_index</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ap_sme_capa</span></code></dt>
<dd>AP SME capabilities, flags from <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_ap_sme_features</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">signal_type</span></code></dt>
<dd>signal type reported in <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">bss_priv_size</span></code></dt>
<dd>each BSS struct has private data allocated with it,
this variable determines its size</dd>
<dt><code class="docutils literal"><span class="pre">max_scan_ssids</span></code></dt>
<dd>maximum number of SSIDs the device can scan for in
any given scan</dd>
<dt><code class="docutils literal"><span class="pre">max_sched_scan_ssids</span></code></dt>
<dd>maximum number of SSIDs the device can scan
for in any given scheduled scan</dd>
<dt><code class="docutils literal"><span class="pre">max_match_sets</span></code></dt>
<dd>maximum number of match sets the device can handle
when performing a scheduled scan, 0 if filtering is not
supported.</dd>
<dt><code class="docutils literal"><span class="pre">max_scan_ie_len</span></code></dt>
<dd>maximum length of user-controlled IEs device can
add to probe request frames transmitted during a scan, must not
include fixed IEs like supported rates</dd>
<dt><code class="docutils literal"><span class="pre">max_sched_scan_ie_len</span></code></dt>
<dd>same as max_scan_ie_len, but for scheduled
scans</dd>
<dt><code class="docutils literal"><span class="pre">max_sched_scan_plans</span></code></dt>
<dd>maximum number of scan plans (scan interval and number
of iterations) for scheduled scan supported by the device.</dd>
<dt><code class="docutils literal"><span class="pre">max_sched_scan_plan_interval</span></code></dt>
<dd>maximum interval (in seconds) for a
single scan plan supported by the device.</dd>
<dt><code class="docutils literal"><span class="pre">max_sched_scan_plan_iterations</span></code></dt>
<dd>maximum number of iterations for a single
scan plan supported by the device.</dd>
<dt><code class="docutils literal"><span class="pre">n_cipher_suites</span></code></dt>
<dd>number of supported cipher suites</dd>
<dt><code class="docutils literal"><span class="pre">cipher_suites</span></code></dt>
<dd>supported cipher suites</dd>
<dt><code class="docutils literal"><span class="pre">retry_short</span></code></dt>
<dd>Retry limit for short frames (dot11ShortRetryLimit)</dd>
<dt><code class="docutils literal"><span class="pre">retry_long</span></code></dt>
<dd>Retry limit for long frames (dot11LongRetryLimit)</dd>
<dt><code class="docutils literal"><span class="pre">frag_threshold</span></code></dt>
<dd>Fragmentation threshold (dot11FragmentationThreshold);
-1 = fragmentation disabled, only odd values &gt;= 256 used</dd>
<dt><code class="docutils literal"><span class="pre">rts_threshold</span></code></dt>
<dd>RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled</dd>
<dt><code class="docutils literal"><span class="pre">coverage_class</span></code></dt>
<dd>current coverage class</dd>
<dt><code class="docutils literal"><span class="pre">fw_version[ETHTOOL_FWVERS_LEN]</span></code></dt>
<dd>firmware version for ethtool reporting</dd>
<dt><code class="docutils literal"><span class="pre">hw_version</span></code></dt>
<dd>hardware version for ethtool reporting</dd>
<dt><code class="docutils literal"><span class="pre">wowlan</span></code></dt>
<dd>WoWLAN support information</dd>
<dt><code class="docutils literal"><span class="pre">wowlan_config</span></code></dt>
<dd>current WoWLAN configuration; this should usually not be
used since access to it is necessarily racy, use the parameter passed
to the <code class="xref c c-func docutils literal"><span class="pre">suspend()</span></code> operation instead.</dd>
<dt><code class="docutils literal"><span class="pre">max_remain_on_channel_duration</span></code></dt>
<dd>Maximum time a remain-on-channel operation
may request, if implemented.</dd>
<dt><code class="docutils literal"><span class="pre">max_num_pmkids</span></code></dt>
<dd>maximum number of PMKIDs supported by device</dd>
<dt><code class="docutils literal"><span class="pre">available_antennas_tx</span></code></dt>
<dd>bitmap of antennas which are available to be
configured as TX antennas. Antenna configuration commands will be
rejected unless this or <strong>available_antennas_rx</strong> is set.</dd>
<dt><code class="docutils literal"><span class="pre">available_antennas_rx</span></code></dt>
<dd>bitmap of antennas which are available to be
configured as RX antennas. Antenna configuration commands will be
rejected unless this or <strong>available_antennas_tx</strong> is set.</dd>
<dt><code class="docutils literal"><span class="pre">probe_resp_offload</span></code></dt>
<dd>Bitmap of supported protocols for probe response offloading.
See <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_probe_resp_offload_support_attr</span></code>. Only valid
when the wiphy flag <strong>WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</strong> is set.</dd>
<dt><code class="docutils literal"><span class="pre">extended_capabilities</span></code></dt>
<dd>extended capabilities supported by the driver,
additional capabilities might be supported by userspace; these are
the 802.11 extended capabilities (&#8220;Extended Capabilities element&#8221;)
and are in the same format as in the information element. See
802.11-2012 8.4.2.29 for the defined fields. These are the default
extended capabilities to be used if the capabilities are not specified
for a specific interface type in iftype_ext_capab.</dd>
<dt><code class="docutils literal"><span class="pre">extended_capabilities_mask</span></code></dt>
<dd>mask of the valid values</dd>
<dt><code class="docutils literal"><span class="pre">extended_capabilities_len</span></code></dt>
<dd>length of the extended capabilities</dd>
<dt><code class="docutils literal"><span class="pre">iftype_ext_capab</span></code></dt>
<dd>array of extended capabilities per interface type</dd>
<dt><code class="docutils literal"><span class="pre">num_iftype_ext_capab</span></code></dt>
<dd>number of interface types for which extended
capabilities are specified separately.</dd>
<dt><code class="docutils literal"><span class="pre">privid</span></code></dt>
<dd>a pointer that drivers can use to identify if an arbitrary
wiphy is theirs, e.g. in global notifiers</dd>
<dt><code class="docutils literal"><span class="pre">bands[NUM_NL80211_BANDS]</span></code></dt>
<dd>information about bands/channels supported by this device</dd>
<dt><code class="docutils literal"><span class="pre">reg_notifier</span></code></dt>
<dd>the driver&#8217;s regulatory notification callback,
note that if your driver uses <a class="reference internal" href="#c.wiphy_apply_custom_regulatory" title="wiphy_apply_custom_regulatory"><code class="xref c c-func docutils literal"><span class="pre">wiphy_apply_custom_regulatory()</span></code></a>
the reg_notifier&#8217;s request can be passed as NULL</dd>
<dt><code class="docutils literal"><span class="pre">regd</span></code></dt>
<dd>the driver&#8217;s regulatory domain, if one was requested via
the <a class="reference internal" href="#c.regulatory_hint" title="regulatory_hint"><code class="xref c c-func docutils literal"><span class="pre">regulatory_hint()</span></code></a> API. This can be used by the driver
on the <code class="xref c c-func docutils literal"><span class="pre">reg_notifier()</span></code> if it chooses to ignore future
regulatory domain changes caused by other drivers.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>(virtual) struct device for this wiphy</dd>
<dt><code class="docutils literal"><span class="pre">registered</span></code></dt>
<dd>helps synchronize suspend/resume with wiphy unregister</dd>
<dt><code class="docutils literal"><span class="pre">debugfsdir</span></code></dt>
<dd>debugfs directory used for this wiphy, will be renamed
automatically on wiphy renames</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa_mod_mask</span></code></dt>
<dd>Specify what ht_cap values can be over-ridden.
If null, then none can be over-ridden.</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa_mod_mask</span></code></dt>
<dd>Specify what VHT capabilities can be over-ridden.
If null, then none can be over-ridden.</dd>
<dt><code class="docutils literal"><span class="pre">wdev_list</span></code></dt>
<dd>the list of associated (virtual) interfaces; this list must
not be modified by the driver, but can be read with RTNL/RCU protection.</dd>
<dt><code class="docutils literal"><span class="pre">_net</span></code></dt>
<dd>the network namespace this wiphy currently lives in</dd>
<dt><code class="docutils literal"><span class="pre">wext</span></code></dt>
<dd>wireless extension handlers</dd>
<dt><code class="docutils literal"><span class="pre">coalesce</span></code></dt>
<dd>packet coalescing support information</dd>
<dt><code class="docutils literal"><span class="pre">vendor_commands</span></code></dt>
<dd>array of vendor commands supported by the hardware</dd>
<dt><code class="docutils literal"><span class="pre">vendor_events</span></code></dt>
<dd>array of vendor events supported by the hardware</dd>
<dt><code class="docutils literal"><span class="pre">n_vendor_commands</span></code></dt>
<dd>number of vendor commands</dd>
<dt><code class="docutils literal"><span class="pre">n_vendor_events</span></code></dt>
<dd>number of vendor events</dd>
<dt><code class="docutils literal"><span class="pre">max_ap_assoc_sta</span></code></dt>
<dd>maximum number of associated stations supported in AP mode
(including P2P GO) or 0 to indicate no such limit is advertised. The
driver is allowed to advertise a theoretical limit that it can reach in
some cases, but may not always reach.</dd>
<dt><code class="docutils literal"><span class="pre">max_num_csa_counters</span></code></dt>
<dd>Number of supported csa_counters in beacons
and probe responses.  This value should be set if the driver
wishes to limit the number of csa counters. Default (0) means
infinite.</dd>
<dt><code class="docutils literal"><span class="pre">max_adj_channel_rssi_comp</span></code></dt>
<dd>max offset of between the channel on which the
frame was sent and the channel on which the frame was heard for which
the reported rssi is still valid. If a driver is able to compensate the
low rssi when a frame is heard on different channel, then it should set
this variable to the maximal offset for which it can compensate.
This value should be set in MHz.</dd>
<dt><code class="docutils literal"><span class="pre">bss_select_support</span></code></dt>
<dd>bitmask indicating the BSS selection criteria supported
by the driver in the .:c:func:<cite>connect()</cite> callback. The bit position maps to the
attribute indices defined in <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_bss_select_attr</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">cookie_counter</span></code></dt>
<dd>unique generic cookie counter, used to identify objects.</dd>
<dt><code class="docutils literal"><span class="pre">nan_supported_bands</span></code></dt>
<dd>bands supported by the device in NAN mode, a
bitmap of <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_band</span></code> values.  For instance, for
NL80211_BAND_2GHZ, bit 0 would be set
(i.e. BIT(NL80211_BAND_2GHZ)).</dd>
<dt><code class="docutils literal"><span class="pre">priv[0]</span></code></dt>
<dd>driver private data (sized according to <a class="reference internal" href="#c.wiphy_new" title="wiphy_new"><code class="xref c c-func docutils literal"><span class="pre">wiphy_new()</span></code></a> parameter)</dd>
</dl>
<dl class="type">
<dt id="c.wireless_dev">
struct <code class="descname">wireless_dev</code><a class="headerlink" href="#c.wireless_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>wireless device state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct wireless_dev {
  struct wiphy * wiphy;
  enum nl80211_iftype iftype;
  struct list_head list;
  struct net_device * netdev;
  u32 identifier;
  struct list_head mgmt_registrations;
  spinlock_t mgmt_registrations_lock;
  struct mutex mtx;
  bool use_4addr;
  bool is_running;
  u8 address[ETH_ALEN];
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
  u8 mesh_id_len;
  u8 mesh_id_up_len;
  struct cfg80211_conn * conn;
  struct cfg80211_cached_keys * connect_keys;
  enum ieee80211_bss_type conn_bss_type;
  u32 conn_owner_nlportid;
  struct work_struct disconnect_wk;
  u8 disconnect_bssid[ETH_ALEN];
  struct list_head event_list;
  spinlock_t event_lock;
  struct cfg80211_internal_bss * current_bss;
  struct cfg80211_chan_def preset_chandef;
  struct cfg80211_chan_def chandef;
  bool ibss_fixed;
  bool ibss_dfs_possible;
  bool ps;
  int ps_timeout;
  int beacon_interval;
  u32 ap_unexpected_nlportid;
  bool cac_started;
  unsigned long cac_start_time;
  unsigned int cac_time_ms;
  u32 owner_nlportid;
#ifdef CONFIG_CFG80211_WEXT
  struct wext;
#endif
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wiphy</span></code></dt>
<dd>pointer to hardware description</dd>
<dt><code class="docutils literal"><span class="pre">iftype</span></code></dt>
<dd>interface type</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>(private) Used to collect the interfaces</dd>
<dt><code class="docutils literal"><span class="pre">netdev</span></code></dt>
<dd>(private) Used to reference back to the netdev, may be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">identifier</span></code></dt>
<dd>(private) Identifier used in nl80211 to identify this
wireless device if it has no netdev</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_registrations</span></code></dt>
<dd>list of registrations for management frames</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_registrations_lock</span></code></dt>
<dd>lock for the list</dd>
<dt><code class="docutils literal"><span class="pre">mtx</span></code></dt>
<dd>mutex used to lock data in this struct, may be used by drivers
and some API functions require it held</dd>
<dt><code class="docutils literal"><span class="pre">use_4addr</span></code></dt>
<dd>indicates 4addr mode is used on this interface, must be
set by driver (if supported) on add_interface BEFORE registering the
netdev and may otherwise be used by driver read-only, will be update
by cfg80211 on change_interface</dd>
<dt><code class="docutils literal"><span class="pre">is_running</span></code></dt>
<dd>true if this is a non-netdev device that has been started, e.g.
the P2P Device.</dd>
<dt><code class="docutils literal"><span class="pre">address[ETH_ALEN]</span></code></dt>
<dd>The address for this device, valid only if <strong>netdev</strong> is <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ssid[IEEE80211_MAX_SSID_LEN]</span></code></dt>
<dd>(private) Used by the internal configuration code</dd>
<dt><code class="docutils literal"><span class="pre">ssid_len</span></code></dt>
<dd>(private) Used by the internal configuration code</dd>
<dt><code class="docutils literal"><span class="pre">mesh_id_len</span></code></dt>
<dd>(private) Used by the internal configuration code</dd>
<dt><code class="docutils literal"><span class="pre">mesh_id_up_len</span></code></dt>
<dd>(private) Used by the internal configuration code</dd>
<dt><code class="docutils literal"><span class="pre">conn</span></code></dt>
<dd>(private) cfg80211 software SME connection state machine data</dd>
<dt><code class="docutils literal"><span class="pre">connect_keys</span></code></dt>
<dd>(private) keys to set after connection is established</dd>
<dt><code class="docutils literal"><span class="pre">conn_bss_type</span></code></dt>
<dd>connecting/connected BSS type</dd>
<dt><code class="docutils literal"><span class="pre">conn_owner_nlportid</span></code></dt>
<dd>(private) connection owner socket port ID</dd>
<dt><code class="docutils literal"><span class="pre">disconnect_wk</span></code></dt>
<dd>(private) auto-disconnect work</dd>
<dt><code class="docutils literal"><span class="pre">disconnect_bssid[ETH_ALEN]</span></code></dt>
<dd>(private) the BSSID to use for auto-disconnect</dd>
<dt><code class="docutils literal"><span class="pre">event_list</span></code></dt>
<dd>(private) list for internal event processing</dd>
<dt><code class="docutils literal"><span class="pre">event_lock</span></code></dt>
<dd>(private) lock for event list</dd>
<dt><code class="docutils literal"><span class="pre">current_bss</span></code></dt>
<dd>(private) Used by the internal configuration code</dd>
<dt><code class="docutils literal"><span class="pre">preset_chandef</span></code></dt>
<dd>(private) Used by the internal configuration code to
track the channel to be used for AP later</dd>
<dt><code class="docutils literal"><span class="pre">chandef</span></code></dt>
<dd>(private) Used by the internal configuration code to track
the user-set channel definition.</dd>
<dt><code class="docutils literal"><span class="pre">ibss_fixed</span></code></dt>
<dd>(private) IBSS is using fixed BSSID</dd>
<dt><code class="docutils literal"><span class="pre">ibss_dfs_possible</span></code></dt>
<dd>(private) IBSS may change to a DFS channel</dd>
<dt><code class="docutils literal"><span class="pre">ps</span></code></dt>
<dd>powersave mode is enabled</dd>
<dt><code class="docutils literal"><span class="pre">ps_timeout</span></code></dt>
<dd>dynamic powersave timeout</dd>
<dt><code class="docutils literal"><span class="pre">beacon_interval</span></code></dt>
<dd>beacon interval used on this device for transmitting
beacons, 0 when not valid</dd>
<dt><code class="docutils literal"><span class="pre">ap_unexpected_nlportid</span></code></dt>
<dd>(private) netlink port ID of application
registered for unexpected class 3 frames (AP mode)</dd>
<dt><code class="docutils literal"><span class="pre">cac_started</span></code></dt>
<dd>true if DFS channel availability check has been started</dd>
<dt><code class="docutils literal"><span class="pre">cac_start_time</span></code></dt>
<dd>timestamp (jiffies) when the dfs state was entered.</dd>
<dt><code class="docutils literal"><span class="pre">cac_time_ms</span></code></dt>
<dd>CAC time in ms</dd>
<dt><code class="docutils literal"><span class="pre">owner_nlportid</span></code></dt>
<dd>(private) owner socket port ID</dd>
<dt><code class="docutils literal"><span class="pre">wext</span></code></dt>
<dd>(private) Used by the internal wireless extensions compat code</dd>
</dl>
<p><strong>Description</strong></p>
<p>For netdevs, this structure must be allocated by the driver
that uses the ieee80211_ptr field in struct net_device (this
is intentional so it can be allocated along with the netdev.)
It need not be registered then as netdev registration will
be intercepted by cfg80211 to see the new wireless device.</p>
<p>For non-netdev uses, it must also be allocated by the driver
in response to the cfg80211 callbacks that require it, as
there&#8217;s no netdev registration in that case it may not be
allocated outside of callback operations that return it.</p>
<dl class="function">
<dt id="c.wiphy_new">
struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> * <code class="descname">wiphy_new</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cfg80211_ops" title="cfg80211_ops">cfg80211_ops</a> *<em>&nbsp;ops</em>, int<em>&nbsp;sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new wiphy for use with cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cfg80211_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>The configuration operations for this device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt>
<dd>The size of the private area to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new wiphy and associate the given operations with it.
<strong>sizeof_priv</strong> bytes are allocated for private use.</p>
<p><strong>Return</strong></p>
<p>A pointer to the new wiphy. This pointer must be
assigned to each netdev&#8217;s ieee80211_ptr for proper operation.</p>
<dl class="function">
<dt id="c.wiphy_read_of_freq_limits">
void <code class="descname">wiphy_read_of_freq_limits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_read_of_freq_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>read frequency limits from device tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wireless device to get extra limits for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices may have extra limitations specified in DT. This may be useful
for chipsets that normally support more bands but are limited due to board
design (e.g. by antennas or external power amplifier).</p>
<p>This function reads info from DT and uses it to <em>modify</em> channels (disable
unavailable ones). It&#8217;s usually a <em>bad</em> idea to use it in drivers with
shared channel data as DT limitations are device specific. You should make
sure to call it only if channels in wiphy are copied and can be modified
without affecting other devices.</p>
<p>As this function access device node it has to be called after set_wiphy_dev.
It also modifies channels so they have to be set first.
If using this helper, call it before <a class="reference internal" href="#c.wiphy_register" title="wiphy_register"><code class="xref c c-func docutils literal"><span class="pre">wiphy_register()</span></code></a>.</p>
<dl class="function">
<dt id="c.wiphy_register">
int <code class="descname">wiphy_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a wiphy with cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy to register.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A non-negative wiphy index or a negative error code.</p>
<dl class="function">
<dt id="c.wiphy_unregister">
void <code class="descname">wiphy_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a wiphy from cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy to unregister.</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, no more requests can be made with this priv
pointer, but the call may sleep to wait for an outstanding
request that is being handled.</p>
<dl class="function">
<dt id="c.wiphy_free">
void <code class="descname">wiphy_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy to free</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_name">
const char * <code class="descname">wiphy_name</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get wiphy name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy whose name to return</dd>
</dl>
<p><strong>Return</strong></p>
<p>The name of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.wiphy_dev">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="descname">wiphy_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>get wiphy dev pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy whose device struct to look up</dd>
</dl>
<p><strong>Return</strong></p>
<p>The dev of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.wiphy_priv">
void * <code class="descname">wiphy_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return priv from wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy whose priv pointer to return</dd>
</dl>
<p><strong>Return</strong></p>
<p>The priv of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.priv_to_wiphy">
struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> * <code class="descname">priv_to_wiphy</code><span class="sig-paren">(</span>void *<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.priv_to_wiphy" title="Permalink to this definition">¶</a></dt>
<dd><p>return the wiphy containing the priv</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>a pointer previously returned by wiphy_priv</dd>
</dl>
<p><strong>Return</strong></p>
<p>The wiphy of <strong>priv</strong>.</p>
<dl class="function">
<dt id="c.set_wiphy_dev">
void <code class="descname">set_wiphy_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_wiphy_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>set device pointer for wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>The wiphy whose device to bind</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to parent it to</dd>
</dl>
<dl class="function">
<dt id="c.wdev_priv">
void * <code class="descname">wdev_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em>&nbsp;wdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wdev_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return wiphy priv from wireless_dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt>
<dd>The wireless device whose wiphy&#8217;s priv pointer to return</dd>
</dl>
<p><strong>Return</strong></p>
<p>The wiphy priv of <strong>wdev</strong>.</p>
<dl class="type">
<dt id="c.ieee80211_iface_limit">
struct <code class="descname">ieee80211_iface_limit</code><a class="headerlink" href="#c.ieee80211_iface_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>limit on certain interface types</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_iface_limit {
  u16 max;
  u16 types;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">max</span></code></dt>
<dd>maximum number of interfaces of these types</dd>
<dt><code class="docutils literal"><span class="pre">types</span></code></dt>
<dd>interface types (bits)</dd>
</dl>
<dl class="type">
<dt id="c.ieee80211_iface_combination">
struct <code class="descname">ieee80211_iface_combination</code><a class="headerlink" href="#c.ieee80211_iface_combination" title="Permalink to this definition">¶</a></dt>
<dd><p>possible interface combination</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_iface_combination {
  const struct ieee80211_iface_limit * limits;
  u32 num_different_channels;
  u16 max_interfaces;
  u8 n_limits;
  bool beacon_int_infra_match;
  u8 radar_detect_widths;
  u8 radar_detect_regions;
  u32 beacon_int_min_gcd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">limits</span></code></dt>
<dd>limits for the given interface types</dd>
<dt><code class="docutils literal"><span class="pre">num_different_channels</span></code></dt>
<dd>can use up to this many different channels</dd>
<dt><code class="docutils literal"><span class="pre">max_interfaces</span></code></dt>
<dd>maximum number of interfaces in total allowed in this group</dd>
<dt><code class="docutils literal"><span class="pre">n_limits</span></code></dt>
<dd>number of limitations</dd>
<dt><code class="docutils literal"><span class="pre">beacon_int_infra_match</span></code></dt>
<dd>In this combination, the beacon intervals between infrastructure
and AP types must match. This is required only in special cases.</dd>
<dt><code class="docutils literal"><span class="pre">radar_detect_widths</span></code></dt>
<dd>bitmap of channel widths supported for radar detection</dd>
<dt><code class="docutils literal"><span class="pre">radar_detect_regions</span></code></dt>
<dd>bitmap of regions supported for radar detection</dd>
<dt><code class="docutils literal"><span class="pre">beacon_int_min_gcd</span></code></dt>
<dd><p class="first">This interface combination supports different beacon intervals.</p>
<dl class="last docutils">
<dt>= 0</dt>
<dd>all beacon intervals for different interface must be same.</dd>
<dt>&gt; 0</dt>
<dd>any beacon interval for the interface part of this combination AND
GCD of all beacon intervals from beaconing interfaces of this
combination must be greater or equal to this value.</dd>
</dl>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>With this structure the driver can describe which interface
combinations it supports concurrently.</p>
<p><strong>Examples</strong></p>
<ol class="arabic">
<li><p class="first">Allow #STA &lt;= 1, #AP &lt;= 1, matching BI, channels = 1, 2 total:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_STATION</span><span class="p">),</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_AP</span><span class="p">},</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">beacon_int_infra_match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first">Allow #{AP, P2P-GO} &lt;= 8, channels = 1, 8 total:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_AP</span><span class="p">)</span> <span class="o">|</span>
                             <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_GO</span><span class="p">),</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits2</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="p">.</span><span class="n">num_different_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first">Allow #STA &lt;= 1, #{P2P-client,P2P-GO} &lt;= 3 on two channels, 4 total.</p>
<p>This allows for an infrastructure connection and three P2P connections.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_STATION</span><span class="p">),</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_GO</span><span class="p">)</span> <span class="o">|</span>
                             <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_CLIENT</span><span class="p">),</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination3</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits3</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits3</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">.</span><span class="n">num_different_channels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ol>
<dl class="function">
<dt id="c.cfg80211_check_combinations">
int <code class="descname">cfg80211_check_combinations</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, struct iface_combination_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_check_combinations" title="Permalink to this definition">¶</a></dt>
<dd><p>check interface combinations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iface_combination_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the interface combinations parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called by the driver to check whether a
combination of interfaces and their types are allowed according to
the interface combinations.</p>
</div>
<div class="section" id="actions-and-configuration">
<h2>Actions and configuration<a class="headerlink" href="#actions-and-configuration" title="Permalink to this headline">¶</a></h2>
<p>Each wireless device and each virtual interface offer a set of configuration
operations and other actions that are invoked by userspace. Each of these
actions is described in the operations structure, and the parameters these
operations use are described separately.</p>
<p>Additionally, some operations are asynchronous and expect to get status
information via some functions that drivers need to call.</p>
<p>Scanning and BSS list handling with its associated functionality is described
in a separate chapter.</p>
<dl class="type">
<dt id="c.cfg80211_ops">
struct <code class="descname">cfg80211_ops</code><a class="headerlink" href="#c.cfg80211_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>backend description for wireless configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_ops {
  int (* suspend) (struct wiphy *wiphy, struct cfg80211_wowlan *wow);
  int (* resume) (struct wiphy *wiphy);
  void (* set_wakeup) (struct wiphy *wiphy, bool enabled);
  struct wireless_dev * (* add_virtual_intf) (struct wiphy *wiphy,const char *name,unsigned char name_assign_type,enum nl80211_iftype type,u32 *flags,struct vif_params *params);
  int (* del_virtual_intf) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* change_virtual_intf) (struct wiphy *wiphy,struct net_device *dev,enum nl80211_iftype type, u32 *flags,struct vif_params *params);
  int (* add_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,struct key_params *params);
  int (* get_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void *cookie,void (*callback);
  int (* del_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr);
  int (* set_default_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index, bool unicast, bool multicast);
  int (* set_default_mgmt_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index);
  int (* start_ap) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ap_settings *settings);
  int (* change_beacon) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_beacon_data *info);
  int (* stop_ap) (struct wiphy *wiphy, struct net_device *dev);
  int (* add_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* del_station) (struct wiphy *wiphy, struct net_device *dev,struct station_del_parameters *params);
  int (* change_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac,struct station_parameters *params);
  int (* get_station) (struct wiphy *wiphy, struct net_device *dev,const u8 *mac, struct station_info *sinfo);
  int (* dump_station) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *mac, struct station_info *sinfo);
  int (* add_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* del_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst);
  int (* change_mpath) (struct wiphy *wiphy, struct net_device *dev,const u8 *dst, const u8 *next_hop);
  int (* get_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (* dump_mpath) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *next_hop,struct mpath_info *pinfo);
  int (* get_mpp) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *mpp, struct mpath_info *pinfo);
  int (* dump_mpp) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *mpp,struct mpath_info *pinfo);
  int (* get_mesh_config) (struct wiphy *wiphy,struct net_device *dev,struct mesh_config *conf);
  int (* update_mesh_config) (struct wiphy *wiphy,struct net_device *dev, u32 mask,const struct mesh_config *nconf);
  int (* join_mesh) (struct wiphy *wiphy, struct net_device *dev,const struct mesh_config *conf,const struct mesh_setup *setup);
  int (* leave_mesh) (struct wiphy *wiphy, struct net_device *dev);
  int (* join_ocb) (struct wiphy *wiphy, struct net_device *dev,struct ocb_setup *setup);
  int (* leave_ocb) (struct wiphy *wiphy, struct net_device *dev);
  int (* change_bss) (struct wiphy *wiphy, struct net_device *dev,struct bss_parameters *params);
  int (* set_txq_params) (struct wiphy *wiphy, struct net_device *dev,struct ieee80211_txq_params *params);
  int (* libertas_set_mesh_channel) (struct wiphy *wiphy,struct net_device *dev,struct ieee80211_channel *chan);
  int (* set_monitor_channel) (struct wiphy *wiphy,struct cfg80211_chan_def *chandef);
  int (* scan) (struct wiphy *wiphy,struct cfg80211_scan_request *request);
  void (* abort_scan) (struct wiphy *wiphy, struct wireless_dev *wdev);
  int (* auth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_auth_request *req);
  int (* assoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_assoc_request *req);
  int (* deauth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_deauth_request *req);
  int (* disassoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_disassoc_request *req);
  int (* connect) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_connect_params *sme);
  int (* update_connect_params) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_connect_params *sme,u32 changed);
  int (* disconnect) (struct wiphy *wiphy, struct net_device *dev,u16 reason_code);
  int (* join_ibss) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ibss_params *params);
  int (* leave_ibss) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_mcast_rate) (struct wiphy *wiphy, struct net_device *dev,int rate[NUM_NL80211_BANDS]);
  int (* set_wiphy_params) (struct wiphy *wiphy, u32 changed);
  int (* set_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,enum nl80211_tx_power_setting type, int mbm);
  int (* get_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,int *dbm);
  int (* set_wds_peer) (struct wiphy *wiphy, struct net_device *dev,const u8 *addr);
  void (* rfkill_poll) (struct wiphy *wiphy);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct wiphy *wiphy, struct wireless_dev *wdev,void *data, int len);
  int (* testmode_dump) (struct wiphy *wiphy, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  int (* set_bitrate_mask) (struct wiphy *wiphy,struct net_device *dev,const u8 *peer,const struct cfg80211_bitrate_mask *mask);
  int (* dump_survey) (struct wiphy *wiphy, struct net_device *netdev,int idx, struct survey_info *info);
  int (* set_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* del_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* flush_pmksa) (struct wiphy *wiphy, struct net_device *netdev);
  int (* remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct ieee80211_channel *chan,unsigned int duration,u64 *cookie);
  int (* cancel_remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* mgmt_tx) (struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_mgmt_tx_params *params,u64 *cookie);
  int (* mgmt_tx_cancel_wait) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* set_power_mgmt) (struct wiphy *wiphy, struct net_device *dev,bool enabled, int timeout);
  int (* set_cqm_rssi_config) (struct wiphy *wiphy,struct net_device *dev,s32 rssi_thold, u32 rssi_hyst);
  int (* set_cqm_txe_config) (struct wiphy *wiphy,struct net_device *dev,u32 rate, u32 pkts, u32 intvl);
  void (* mgmt_frame_register) (struct wiphy *wiphy,struct wireless_dev *wdev,u16 frame_type, bool reg);
  int (* set_antenna) (struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
  int (* sched_scan_start) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_sched_scan_request *request);
  int (* sched_scan_stop) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_rekey_data) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_gtk_rekey_data *data);
  int (* tdls_mgmt) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u8 action_code,  u8 dialog_token,u16 status_code, u32 peer_capability,bool initiator, const u8 *buf, size_t len);
  int (* tdls_oper) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, enum nl80211_tdls_operation oper);
  int (* probe_client) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u64 *cookie);
  int (* set_noack_map) (struct wiphy *wiphy,struct net_device *dev,u16 noack_map);
  int (* get_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_chan_def *chandef);
  int (* start_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  void (* stop_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_mac_acl) (struct wiphy *wiphy, struct net_device *dev,const struct cfg80211_acl_data *params);
  int (* start_radar_detection) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_chan_def *chandef,u32 cac_time_ms);
  int (* update_ft_ies) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_update_ft_ies_params *ftie);
  int (* crit_proto_start) (struct wiphy *wiphy,struct wireless_dev *wdev,enum nl80211_crit_proto_id protocol,u16 duration);
  void (* crit_proto_stop) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_coalesce) (struct wiphy *wiphy,struct cfg80211_coalesce *coalesce);
  int (* channel_switch) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_csa_settings *params);
  int (* set_qos_map) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_qos_map *qos_map);
  int (* set_ap_chanwidth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_chan_def *chandef);
  int (* add_tx_ts) (struct wiphy *wiphy, struct net_device *dev,u8 tsid, const u8 *peer, u8 user_prio,u16 admitted_time);
  int (* del_tx_ts) (struct wiphy *wiphy, struct net_device *dev,u8 tsid, const u8 *peer);
  int (* tdls_channel_switch) (struct wiphy *wiphy,struct net_device *dev,const u8 *addr, u8 oper_class,struct cfg80211_chan_def *chandef);
  void (* tdls_cancel_channel_switch) (struct wiphy *wiphy,struct net_device *dev,const u8 *addr);
  int (* start_nan) (struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_nan_conf *conf);
  void (* stop_nan) (struct wiphy *wiphy, struct wireless_dev *wdev);
  int (* add_nan_func) (struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_nan_func *nan_func);
  void (* del_nan_func) (struct wiphy *wiphy, struct wireless_dev *wdev,u64 cookie);
  int (* nan_change_conf) (struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_nan_conf *conf,u32 changes);
  int (* set_multicast_to_unicast) (struct wiphy *wiphy,struct net_device *dev,const bool enabled);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>wiphy device needs to be suspended. The variable <strong>wow</strong> will
be <code class="docutils literal"><span class="pre">NULL</span></code> or contain the enabled Wake-on-Wireless triggers that are
configured for the device.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>wiphy device needs to be resumed</dd>
<dt><code class="docutils literal"><span class="pre">set_wakeup</span></code></dt>
<dd>Called when WoWLAN is enabled/disabled, use this callback
to call <code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_enable()</span></code> to enable/disable wakeup from
the device.</dd>
<dt><code class="docutils literal"><span class="pre">add_virtual_intf</span></code></dt>
<dd>create a new virtual interface with the given name,
must set the struct wireless_dev&#8217;s iftype. Beware: You must create
the new netdev in the wiphy&#8217;s network namespace! Returns the struct
wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
also set the address member in the wdev.</dd>
<dt><code class="docutils literal"><span class="pre">del_virtual_intf</span></code></dt>
<dd>remove the virtual interface</dd>
<dt><code class="docutils literal"><span class="pre">change_virtual_intf</span></code></dt>
<dd>change type/configuration of virtual interface,
keep the struct wireless_dev&#8217;s iftype updated.</dd>
<dt><code class="docutils literal"><span class="pre">add_key</span></code></dt>
<dd>add a key with the given parameters. <strong>mac_addr</strong> will be <code class="docutils literal"><span class="pre">NULL</span></code>
when adding a group key.</dd>
<dt><code class="docutils literal"><span class="pre">get_key</span></code></dt>
<dd>get information about the key with the given parameters.
<strong>mac_addr</strong> will be <code class="docutils literal"><span class="pre">NULL</span></code> when requesting information for a group
key. All pointers given to the <strong>callback</strong> function need not be valid
after it returns. This function should return an error if it is
not possible to retrieve the key, -ENOENT if it doesn&#8217;t exist.</dd>
<dt><code class="docutils literal"><span class="pre">del_key</span></code></dt>
<dd>remove a key given the <strong>mac_addr</strong> (<code class="docutils literal"><span class="pre">NULL</span></code> for a group key)
and <strong>key_index</strong>, return -ENOENT if the key doesn&#8217;t exist.</dd>
<dt><code class="docutils literal"><span class="pre">set_default_key</span></code></dt>
<dd>set the default key on an interface</dd>
<dt><code class="docutils literal"><span class="pre">set_default_mgmt_key</span></code></dt>
<dd>set the default management frame key on an interface</dd>
<dt><code class="docutils literal"><span class="pre">start_ap</span></code></dt>
<dd>Start acting in AP mode defined by the parameters.</dd>
<dt><code class="docutils literal"><span class="pre">change_beacon</span></code></dt>
<dd>Change the beacon parameters for an access point mode
interface. This should reject the call when AP mode wasn&#8217;t started.</dd>
<dt><code class="docutils literal"><span class="pre">stop_ap</span></code></dt>
<dd>Stop being an AP, including stopping beaconing.</dd>
<dt><code class="docutils literal"><span class="pre">add_station</span></code></dt>
<dd>Add a new station.</dd>
<dt><code class="docutils literal"><span class="pre">del_station</span></code></dt>
<dd>Remove a station</dd>
<dt><code class="docutils literal"><span class="pre">change_station</span></code></dt>
<dd>Modify a given station. Note that flags changes are not much
validated in cfg80211, in particular the auth/assoc/authorized flags
might come to the driver in invalid combinations &#8211; make sure to check
them, also against the existing state! Drivers must call
<code class="xref c c-func docutils literal"><span class="pre">cfg80211_check_station_change()</span></code> to validate the information.</dd>
<dt><code class="docutils literal"><span class="pre">get_station</span></code></dt>
<dd>get station information for the station identified by <strong>mac</strong></dd>
<dt><code class="docutils literal"><span class="pre">dump_station</span></code></dt>
<dd>dump station callback &#8211; resume dump at index <strong>idx</strong></dd>
<dt><code class="docutils literal"><span class="pre">add_mpath</span></code></dt>
<dd>add a fixed mesh path</dd>
<dt><code class="docutils literal"><span class="pre">del_mpath</span></code></dt>
<dd>delete a given mesh path</dd>
<dt><code class="docutils literal"><span class="pre">change_mpath</span></code></dt>
<dd>change a given mesh path</dd>
<dt><code class="docutils literal"><span class="pre">get_mpath</span></code></dt>
<dd>get a mesh path for the given parameters</dd>
<dt><code class="docutils literal"><span class="pre">dump_mpath</span></code></dt>
<dd>dump mesh path callback &#8211; resume dump at index <strong>idx</strong></dd>
<dt><code class="docutils literal"><span class="pre">get_mpp</span></code></dt>
<dd>get a mesh proxy path for the given parameters</dd>
<dt><code class="docutils literal"><span class="pre">dump_mpp</span></code></dt>
<dd>dump mesh proxy path callback &#8211; resume dump at index <strong>idx</strong></dd>
<dt><code class="docutils literal"><span class="pre">get_mesh_config</span></code></dt>
<dd>Get the current mesh configuration</dd>
<dt><code class="docutils literal"><span class="pre">update_mesh_config</span></code></dt>
<dd>Update mesh parameters on a running mesh.
The mask is a bitfield which tells us which parameters to
set, and which to leave alone.</dd>
<dt><code class="docutils literal"><span class="pre">join_mesh</span></code></dt>
<dd>join the mesh network with the specified parameters
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">leave_mesh</span></code></dt>
<dd>leave the current mesh network
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">join_ocb</span></code></dt>
<dd>join the OCB network with the specified parameters
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">leave_ocb</span></code></dt>
<dd>leave the current OCB network
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">change_bss</span></code></dt>
<dd>Modify parameters for a given BSS.</dd>
<dt><code class="docutils literal"><span class="pre">set_txq_params</span></code></dt>
<dd>Set TX queue parameters</dd>
<dt><code class="docutils literal"><span class="pre">libertas_set_mesh_channel</span></code></dt>
<dd>Only for backward compatibility for libertas,
as it doesn&#8217;t implement join_mesh and needs to set the channel to
join the mesh instead.</dd>
<dt><code class="docutils literal"><span class="pre">set_monitor_channel</span></code></dt>
<dd>Set the monitor mode channel for the device. If other
interfaces are active this callback should reject the configuration.
If no interfaces are active or the device is down, the channel should
be stored for when a monitor interface becomes active.</dd>
<dt><code class="docutils literal"><span class="pre">scan</span></code></dt>
<dd>Request to do a scan. If returning zero, the scan request is given
the driver, and will be valid until passed to <a class="reference internal" href="#c.cfg80211_scan_done" title="cfg80211_scan_done"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_scan_done()</span></code></a>.
For scan results, call <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_inform_bss()</span></code></a>; you can call this outside
the scan/scan_done bracket too.</dd>
<dt><code class="docutils literal"><span class="pre">abort_scan</span></code></dt>
<dd>Tell the driver to abort an ongoing scan. The driver shall
indicate the status of the scan through <a class="reference internal" href="#c.cfg80211_scan_done" title="cfg80211_scan_done"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_scan_done()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">auth</span></code></dt>
<dd>Request to authenticate with the specified peer
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">assoc</span></code></dt>
<dd>Request to (re)associate with the specified peer
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">deauth</span></code></dt>
<dd>Request to deauthenticate from the specified peer
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">disassoc</span></code></dt>
<dd>Request to disassociate from the specified peer
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">connect</span></code></dt>
<dd>Connect to the ESS with the specified parameters. When connected,
call <a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_result()</span></code></a>/<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_bss()</span></code></a> with status code
<code class="docutils literal"><span class="pre">WLAN_STATUS_SUCCESS</span></code>. If the connection fails for some reason, call
<a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_result()</span></code></a>/<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_bss()</span></code></a> with the status code
from the AP or <a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_timeout()</span></code></a> if no frame with status code
was received.
The driver is allowed to roam to other BSSes within the ESS when the
other BSS matches the connect parameters. When such roaming is initiated
by the driver, the driver is expected to verify that the target matches
the configured security parameters and to use Reassociation Request
frame instead of Association Request frame.
The connect function can also be used to request the driver to perform a
specific roam when connected to an ESS. In that case, the prev_bssid
parameter is set to the BSSID of the currently associated BSS as an
indication of requesting reassociation.
In both the driver-initiated and new <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> call initiated roaming
cases, the result of roaming is indicated with a call to
<a class="reference internal" href="#c.cfg80211_roamed" title="cfg80211_roamed"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_roamed()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">cfg80211_roamed_bss()</span></code>.
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">update_connect_params</span></code></dt>
<dd>Update the connect parameters while connected to a
BSS. The updated parameters can be used by driver/firmware for
subsequent BSS selection (roaming) decisions and to form the
Authentication/(Re)Association Request frames. This call does not
request an immediate disassociation or reassociation with the current
BSS, i.e., this impacts only subsequent (re)associations. The bits in
changed are defined in <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">cfg80211_connect_params_changed</span></code>.
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">disconnect</span></code></dt>
<dd>Disconnect from the BSS/ESS or stop connection attempts if
connection is in progress. Once done, call <a class="reference internal" href="#c.cfg80211_disconnected" title="cfg80211_disconnected"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_disconnected()</span></code></a> in
case connection was already established (invoked with the
wireless_dev mutex held), otherwise call <a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_timeout()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">join_ibss</span></code></dt>
<dd>Join the specified IBSS (or create if necessary). Once done, call
<a class="reference internal" href="#c.cfg80211_ibss_joined" title="cfg80211_ibss_joined"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_ibss_joined()</span></code></a>, also call that function when changing BSSID due
to a merge.
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">leave_ibss</span></code></dt>
<dd>Leave the IBSS.
(invoked with the wireless_dev mutex held)</dd>
<dt><code class="docutils literal"><span class="pre">set_mcast_rate</span></code></dt>
<dd>Set the specified multicast rate (only if vif is in ADHOC or
MESH mode)</dd>
<dt><code class="docutils literal"><span class="pre">set_wiphy_params</span></code></dt>
<dd>Notify that wiphy parameters have changed;
<strong>changed</strong> bitfield (see <a class="reference internal" href="#c.wiphy_params_flags" title="wiphy_params_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">wiphy_params_flags</span></code></a>) describes which values
have changed. The actual parameter values are available in
struct wiphy. If returning an error, no value should be changed.</dd>
<dt><code class="docutils literal"><span class="pre">set_tx_power</span></code></dt>
<dd>set the transmit power according to the parameters,
the power passed is in mBm, to get dBm use <code class="xref c c-func docutils literal"><span class="pre">MBM_TO_DBM()</span></code>. The
wdev may be <code class="docutils literal"><span class="pre">NULL</span></code> if power was set for the wiphy, and will
always be <code class="docutils literal"><span class="pre">NULL</span></code> unless the driver supports per-vif TX power
(as advertised by the nl80211 feature flag.)</dd>
<dt><code class="docutils literal"><span class="pre">get_tx_power</span></code></dt>
<dd>store the current TX power into the dbm variable;
return 0 if successful</dd>
<dt><code class="docutils literal"><span class="pre">set_wds_peer</span></code></dt>
<dd>set the WDS peer for a WDS interface</dd>
<dt><code class="docutils literal"><span class="pre">rfkill_poll</span></code></dt>
<dd>polls the hw rfkill line, use cfg80211 reporting
functions to adjust rfkill hw state</dd>
<dt><code class="docutils literal"><span class="pre">testmode_cmd</span></code></dt>
<dd>run a test mode command; <strong>wdev</strong> may be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">testmode_dump</span></code></dt>
<dd>Implement a test mode dump. The cb-&gt;args[2] and up may be
used by the function, but 0 and 1 must not be touched. Additionally,
return error codes other than -ENOBUFS and -ENOENT will terminate the
dump and return to userspace with an error, so be careful. If any data
was passed in from userspace then the data/len arguments will be present
and point to the data contained in <code class="docutils literal"><span class="pre">NL80211_ATTR_TESTDATA</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">set_bitrate_mask</span></code></dt>
<dd>set the bitrate mask configuration</dd>
<dt><code class="docutils literal"><span class="pre">dump_survey</span></code></dt>
<dd>get site survey information.</dd>
<dt><code class="docutils literal"><span class="pre">set_pmksa</span></code></dt>
<dd>Cache a PMKID for a BSSID. This is mostly useful for fullmac
devices running firmwares capable of generating the (re) association
RSN IE. It allows for faster roaming between WPA2 BSSIDs.</dd>
<dt><code class="docutils literal"><span class="pre">del_pmksa</span></code></dt>
<dd>Delete a cached PMKID.</dd>
<dt><code class="docutils literal"><span class="pre">flush_pmksa</span></code></dt>
<dd>Flush all cached PMKIDs.</dd>
<dt><code class="docutils literal"><span class="pre">remain_on_channel</span></code></dt>
<dd>Request the driver to remain awake on the specified
channel for the specified duration to complete an off-channel
operation (e.g., public action frame exchange). When the driver is
ready on the requested channel, it must indicate this with an event
notification by calling <a class="reference internal" href="#c.cfg80211_ready_on_channel" title="cfg80211_ready_on_channel"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_ready_on_channel()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">cancel_remain_on_channel</span></code></dt>
<dd>Cancel an on-going remain-on-channel operation.
This allows the operation to be terminated prior to timeout based on
the duration value.</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_tx</span></code></dt>
<dd>Transmit a management frame.</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_tx_cancel_wait</span></code></dt>
<dd>Cancel the wait time from transmitting a management
frame on another channel</dd>
<dt><code class="docutils literal"><span class="pre">set_power_mgmt</span></code></dt>
<dd>Configure WLAN power management. A timeout value of -1
allows the driver to adjust the dynamic ps timeout value.</dd>
<dt><code class="docutils literal"><span class="pre">set_cqm_rssi_config</span></code></dt>
<dd>Configure connection quality monitor RSSI threshold.
After configuration, the driver should (soon) send an event indicating
the current level is above/below the configured threshold; this may
need some care when the configuration is changed (without first being
disabled.)</dd>
<dt><code class="docutils literal"><span class="pre">set_cqm_txe_config</span></code></dt>
<dd>Configure connection quality monitor TX error
thresholds.</dd>
<dt><code class="docutils literal"><span class="pre">mgmt_frame_register</span></code></dt>
<dd>Notify driver that a management frame type was
registered. The callback is allowed to sleep.</dd>
<dt><code class="docutils literal"><span class="pre">set_antenna</span></code></dt>
<dd>Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <strong>NL80211_ATTR_WIPHY_ANTENNA_TX</strong>).</dd>
<dt><code class="docutils literal"><span class="pre">get_antenna</span></code></dt>
<dd>Get current antenna configuration from device (tx_ant, rx_ant).</dd>
<dt><code class="docutils literal"><span class="pre">sched_scan_start</span></code></dt>
<dd>Tell the driver to start a scheduled scan.</dd>
<dt><code class="docutils literal"><span class="pre">sched_scan_stop</span></code></dt>
<dd>Tell the driver to stop an ongoing scheduled scan. This
call must stop the scheduled scan and be ready for starting a new one
before it returns, i.e. <strong>sched_scan_start</strong> may be called immediately
after that again and should not fail in that case. The driver should
not call <code class="xref c c-func docutils literal"><span class="pre">cfg80211_sched_scan_stopped()</span></code> for a requested stop (when this
method returns 0.)</dd>
<dt><code class="docutils literal"><span class="pre">set_rekey_data</span></code></dt>
<dd>give the data necessary for GTK rekeying to the driver</dd>
<dt><code class="docutils literal"><span class="pre">tdls_mgmt</span></code></dt>
<dd>Transmit a TDLS management frame.</dd>
<dt><code class="docutils literal"><span class="pre">tdls_oper</span></code></dt>
<dd>Perform a high-level TDLS operation (e.g. TDLS link setup).</dd>
<dt><code class="docutils literal"><span class="pre">probe_client</span></code></dt>
<dd>probe an associated client, must return a cookie that it
later passes to <code class="xref c c-func docutils literal"><span class="pre">cfg80211_probe_status()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">set_noack_map</span></code></dt>
<dd>Set the NoAck Map for the TIDs.</dd>
<dt><code class="docutils literal"><span class="pre">get_channel</span></code></dt>
<dd>Get the current operating channel for the virtual interface.
For monitor interfaces, it should return <code class="docutils literal"><span class="pre">NULL</span></code> unless there&#8217;s a single
current monitoring channel.</dd>
<dt><code class="docutils literal"><span class="pre">start_p2p_device</span></code></dt>
<dd>Start the given P2P device.</dd>
<dt><code class="docutils literal"><span class="pre">stop_p2p_device</span></code></dt>
<dd>Stop the given P2P device.</dd>
<dt><code class="docutils literal"><span class="pre">set_mac_acl</span></code></dt>
<dd>Sets MAC address control list in AP and P2P GO mode.
Parameters include ACL policy, an array of MAC address of stations
and the number of MAC addresses. If there is already a list in driver
this new list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers which
advertise the support for MAC based ACL have to implement this callback.</dd>
<dt><code class="docutils literal"><span class="pre">start_radar_detection</span></code></dt>
<dd>Start radar detection in the driver.</dd>
<dt><code class="docutils literal"><span class="pre">update_ft_ies</span></code></dt>
<dd>Provide updated Fast BSS Transition information to the
driver. If the SME is in the driver/firmware, this information can be
used in building Authentication and Reassociation Request frames.</dd>
<dt><code class="docutils literal"><span class="pre">crit_proto_start</span></code></dt>
<dd>Indicates a critical protocol needs more link reliability
for a given duration (milliseconds). The protocol is provided so the
driver can take the most appropriate actions.</dd>
<dt><code class="docutils literal"><span class="pre">crit_proto_stop</span></code></dt>
<dd>Indicates critical protocol no longer needs increased link
reliability. This operation can not fail.</dd>
<dt><code class="docutils literal"><span class="pre">set_coalesce</span></code></dt>
<dd>Set coalesce parameters.</dd>
<dt><code class="docutils literal"><span class="pre">channel_switch</span></code></dt>
<dd>initiate channel-switch procedure (with CSA). Driver is
responsible for veryfing if the switch is possible. Since this is
inherently tricky driver may decide to disconnect an interface later
with <code class="xref c c-func docutils literal"><span class="pre">cfg80211_stop_iface()</span></code>. This doesn&#8217;t mean driver can accept
everything. It should do it&#8217;s best to verify requests and reject them
as soon as possible.</dd>
<dt><code class="docutils literal"><span class="pre">set_qos_map</span></code></dt>
<dd>Set QoS mapping information to the driver</dd>
<dt><code class="docutils literal"><span class="pre">set_ap_chanwidth</span></code></dt>
<dd>Set the AP (including P2P GO) mode channel width for the
given interface This is used e.g. for dynamic HT 20/40 MHz channel width
changes during the lifetime of the BSS.</dd>
<dt><code class="docutils literal"><span class="pre">add_tx_ts</span></code></dt>
<dd>validate (if admitted_time is 0) or add a TX TS to the device
with the given parameters; action frame exchange has been handled by
userspace so this just has to modify the TX path to take the TS into
account.
If the admitted time is 0 just validate the parameters to make sure
the session can be created at all; it is valid to just always return
success for that but that may result in inefficient behaviour (handshake
with the peer followed by immediate teardown when the addition is later
rejected)</dd>
<dt><code class="docutils literal"><span class="pre">del_tx_ts</span></code></dt>
<dd>remove an existing TX TS</dd>
<dt><code class="docutils literal"><span class="pre">tdls_channel_switch</span></code></dt>
<dd>Start channel-switching with a TDLS peer. The driver
is responsible for continually initiating channel-switching operations
and returning to the base channel for communication with the AP.</dd>
<dt><code class="docutils literal"><span class="pre">tdls_cancel_channel_switch</span></code></dt>
<dd>Stop channel-switching with a TDLS peer. Both
peers must be on the base channel when the call completes.</dd>
<dt><code class="docutils literal"><span class="pre">start_nan</span></code></dt>
<dd>Start the NAN interface.</dd>
<dt><code class="docutils literal"><span class="pre">stop_nan</span></code></dt>
<dd>Stop the NAN interface.</dd>
<dt><code class="docutils literal"><span class="pre">add_nan_func</span></code></dt>
<dd>Add a NAN function. Returns negative value on failure.
On success <strong>nan_func</strong> ownership is transferred to the driver and
it may access it outside of the scope of this function. The driver
should free the <strong>nan_func</strong> when no longer needed by calling
<code class="xref c c-func docutils literal"><span class="pre">cfg80211_free_nan_func()</span></code>.
On success the driver should assign an instance_id in the
provided <strong>nan_func</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">del_nan_func</span></code></dt>
<dd>Delete a NAN function.</dd>
<dt><code class="docutils literal"><span class="pre">nan_change_conf</span></code></dt>
<dd>changes NAN configuration. The changed parameters must
be specified in <strong>changes</strong> (using <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">cfg80211_nan_conf_changes</span></code>);
All other parameters must be ignored.</dd>
<dt><code class="docutils literal"><span class="pre">set_multicast_to_unicast</span></code></dt>
<dd>configure multicast to unicast conversion for BSS</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct is registered by fullmac card drivers and/or wireless stacks
in order to handle configuration requests on their interfaces.</p>
<p>All callbacks except where otherwise noted should return 0
on success or a negative error code.</p>
<p>All operations are currently invoked under rtnl for consistency with the
wireless extensions but this is subject to reevaluation as soon as this
code is used more widely and we have a first user without wext.</p>
<dl class="type">
<dt id="c.vif_params">
struct <code class="descname">vif_params</code><a class="headerlink" href="#c.vif_params" title="Permalink to this definition">¶</a></dt>
<dd><p>describes virtual interface parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vif_params {
  int use_4addr;
  u8 macaddr[ETH_ALEN];
  u8 vht_mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">use_4addr</span></code></dt>
<dd>use 4-address frames</dd>
<dt><code class="docutils literal"><span class="pre">macaddr[ETH_ALEN]</span></code></dt>
<dd>address to use for this virtual interface.
If this parameter is set to zero address the driver may
determine the address as needed.
This feature is only fully supported by drivers that enable the
<code class="docutils literal"><span class="pre">NL80211_FEATURE_MAC_ON_CREATE</span></code> flag.  Others may support creating
*     only p2p devices with specified MAC.</dd>
<dt><code class="docutils literal"><span class="pre">vht_mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN]</span></code></dt>
<dd>MU-MIMO groupID. used for monitoring only
packets belonging to that MU-MIMO groupID.</dd>
</dl>
<dl class="type">
<dt id="c.key_params">
struct <code class="descname">key_params</code><a class="headerlink" href="#c.key_params" title="Permalink to this definition">¶</a></dt>
<dd><p>key information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct key_params {
  const u8 * key;
  const u8 * seq;
  int key_len;
  int seq_len;
  u32 cipher;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>key material</dd>
<dt><code class="docutils literal"><span class="pre">seq</span></code></dt>
<dd>sequence counter (IV/PN) for TKIP and CCMP keys, only used
with the <code class="xref c c-func docutils literal"><span class="pre">get_key()</span></code> callback, must be in little endian,
length given by <strong>seq_len</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">key_len</span></code></dt>
<dd>length of key material</dd>
<dt><code class="docutils literal"><span class="pre">seq_len</span></code></dt>
<dd>length of <strong>seq</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cipher</span></code></dt>
<dd>cipher suite selector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Information about a key</p>
<dl class="type">
<dt id="c.survey_info_flags">
enum <code class="descname">survey_info_flags</code><a class="headerlink" href="#c.survey_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>survey information flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_NOISE_DBM</span></code></dt>
<dd>noise (in dBm) was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_IN_USE</span></code></dt>
<dd>channel is currently being used</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME</span></code></dt>
<dd>active time (in ms) was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME_BUSY</span></code></dt>
<dd>busy time was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME_EXT_BUSY</span></code></dt>
<dd>extension channel busy time was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME_RX</span></code></dt>
<dd>receive time was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME_TX</span></code></dt>
<dd>transmit time was filled in</dd>
<dt><code class="docutils literal"><span class="pre">SURVEY_INFO_TIME_SCAN</span></code></dt>
<dd>scan time was filled in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate which info in <a class="reference internal" href="#c.survey_info" title="survey_info"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">survey_info</span></code></a>
it has filled in during the <code class="xref c c-func docutils literal"><span class="pre">get_survey()</span></code>.</p>
<dl class="type">
<dt id="c.survey_info">
struct <code class="descname">survey_info</code><a class="headerlink" href="#c.survey_info" title="Permalink to this definition">¶</a></dt>
<dd><p>channel survey response</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct survey_info {
  struct ieee80211_channel * channel;
  u64 time;
  u64 time_busy;
  u64 time_ext_busy;
  u64 time_rx;
  u64 time_tx;
  u64 time_scan;
  u32 filled;
  s8 noise;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>the channel this survey record reports, may be <code class="docutils literal"><span class="pre">NULL</span></code> for a single
record to report global statistics</dd>
<dt><code class="docutils literal"><span class="pre">time</span></code></dt>
<dd>amount of time in ms the radio was turn on (on the channel)</dd>
<dt><code class="docutils literal"><span class="pre">time_busy</span></code></dt>
<dd>amount of time the primary channel was sensed busy</dd>
<dt><code class="docutils literal"><span class="pre">time_ext_busy</span></code></dt>
<dd>amount of time the extension channel was sensed busy</dd>
<dt><code class="docutils literal"><span class="pre">time_rx</span></code></dt>
<dd>amount of time the radio spent receiving data</dd>
<dt><code class="docutils literal"><span class="pre">time_tx</span></code></dt>
<dd>amount of time the radio spent transmitting data</dd>
<dt><code class="docutils literal"><span class="pre">time_scan</span></code></dt>
<dd>amount of time the radio spent for scanning</dd>
<dt><code class="docutils literal"><span class="pre">filled</span></code></dt>
<dd>bitflag of flags from <a class="reference internal" href="#c.survey_info_flags" title="survey_info_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">survey_info_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">noise</span></code></dt>
<dd>channel noise in dBm. This and all following fields are
optional</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by <code class="xref c c-func docutils literal"><span class="pre">dump_survey()</span></code> to report back per-channel survey information.</p>
<p>This structure can later be expanded with things like
channel duty cycle etc.</p>
<dl class="type">
<dt id="c.cfg80211_beacon_data">
struct <code class="descname">cfg80211_beacon_data</code><a class="headerlink" href="#c.cfg80211_beacon_data" title="Permalink to this definition">¶</a></dt>
<dd><p>beacon data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_beacon_data {
  const u8 * head;
  const u8 * tail;
  const u8 * beacon_ies;
  const u8 * proberesp_ies;
  const u8 * assocresp_ies;
  const u8 * probe_resp;
  size_t head_len;
  size_t tail_len;
  size_t beacon_ies_len;
  size_t proberesp_ies_len;
  size_t assocresp_ies_len;
  size_t probe_resp_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>head portion of beacon (before TIM IE)
or <code class="docutils literal"><span class="pre">NULL</span></code> if not changed</dd>
<dt><code class="docutils literal"><span class="pre">tail</span></code></dt>
<dd>tail portion of beacon (after TIM IE)
or <code class="docutils literal"><span class="pre">NULL</span></code> if not changed</dd>
<dt><code class="docutils literal"><span class="pre">beacon_ies</span></code></dt>
<dd>extra information element(s) to add into Beacon frames or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">proberesp_ies</span></code></dt>
<dd>extra information element(s) to add into Probe Response
frames or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">assocresp_ies</span></code></dt>
<dd>extra information element(s) to add into (Re)Association
Response frames or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">probe_resp</span></code></dt>
<dd>probe response template (AP mode only)</dd>
<dt><code class="docutils literal"><span class="pre">head_len</span></code></dt>
<dd>length of <strong>head</strong></dd>
<dt><code class="docutils literal"><span class="pre">tail_len</span></code></dt>
<dd>length of <strong>tail</strong></dd>
<dt><code class="docutils literal"><span class="pre">beacon_ies_len</span></code></dt>
<dd>length of beacon_ies in octets</dd>
<dt><code class="docutils literal"><span class="pre">proberesp_ies_len</span></code></dt>
<dd>length of proberesp_ies in octets</dd>
<dt><code class="docutils literal"><span class="pre">assocresp_ies_len</span></code></dt>
<dd>length of assocresp_ies in octets</dd>
<dt><code class="docutils literal"><span class="pre">probe_resp_len</span></code></dt>
<dd>length of probe response template (<strong>probe_resp</strong>)</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_ap_settings">
struct <code class="descname">cfg80211_ap_settings</code><a class="headerlink" href="#c.cfg80211_ap_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>AP configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_ap_settings {
  struct cfg80211_chan_def chandef;
  struct cfg80211_beacon_data beacon;
  int beacon_interval;
  int dtim_period;
  const u8 * ssid;
  size_t ssid_len;
  enum nl80211_hidden_ssid hidden_ssid;
  struct cfg80211_crypto_settings crypto;
  bool privacy;
  enum nl80211_auth_type auth_type;
  enum nl80211_smps_mode smps_mode;
  int inactivity_timeout;
  u8 p2p_ctwindow;
  bool p2p_opp_ps;
  const struct cfg80211_acl_data * acl;
  bool pbss;
  struct cfg80211_bitrate_mask beacon_rate;
  const struct ieee80211_ht_cap * ht_cap;
  const struct ieee80211_vht_cap * vht_cap;
  bool ht_required;
  bool vht_required;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chandef</span></code></dt>
<dd>defines the channel to use</dd>
<dt><code class="docutils literal"><span class="pre">beacon</span></code></dt>
<dd>beacon data</dd>
<dt><code class="docutils literal"><span class="pre">beacon_interval</span></code></dt>
<dd>beacon interval</dd>
<dt><code class="docutils literal"><span class="pre">dtim_period</span></code></dt>
<dd>DTIM period</dd>
<dt><code class="docutils literal"><span class="pre">ssid</span></code></dt>
<dd>SSID to be used in the BSS (note: may be <code class="docutils literal"><span class="pre">NULL</span></code> if not provided from
user space)</dd>
<dt><code class="docutils literal"><span class="pre">ssid_len</span></code></dt>
<dd>length of <strong>ssid</strong></dd>
<dt><code class="docutils literal"><span class="pre">hidden_ssid</span></code></dt>
<dd>whether to hide the SSID in Beacon/Probe Response frames</dd>
<dt><code class="docutils literal"><span class="pre">crypto</span></code></dt>
<dd>crypto settings</dd>
<dt><code class="docutils literal"><span class="pre">privacy</span></code></dt>
<dd>the BSS uses privacy</dd>
<dt><code class="docutils literal"><span class="pre">auth_type</span></code></dt>
<dd>Authentication type (algorithm)</dd>
<dt><code class="docutils literal"><span class="pre">smps_mode</span></code></dt>
<dd>SMPS mode</dd>
<dt><code class="docutils literal"><span class="pre">inactivity_timeout</span></code></dt>
<dd>time in seconds to determine station&#8217;s inactivity.</dd>
<dt><code class="docutils literal"><span class="pre">p2p_ctwindow</span></code></dt>
<dd>P2P CT Window</dd>
<dt><code class="docutils literal"><span class="pre">p2p_opp_ps</span></code></dt>
<dd>P2P opportunistic PS</dd>
<dt><code class="docutils literal"><span class="pre">acl</span></code></dt>
<dd>ACL configuration used by the drivers which has support for
MAC address based access control</dd>
<dt><code class="docutils literal"><span class="pre">pbss</span></code></dt>
<dd>If set, start as a PCP instead of AP. Relevant for DMG
networks.</dd>
<dt><code class="docutils literal"><span class="pre">beacon_rate</span></code></dt>
<dd>bitrate to be used for beacons</dd>
<dt><code class="docutils literal"><span class="pre">ht_cap</span></code></dt>
<dd>HT capabilities (or <code class="docutils literal"><span class="pre">NULL</span></code> if HT isn&#8217;t enabled)</dd>
<dt><code class="docutils literal"><span class="pre">vht_cap</span></code></dt>
<dd>VHT capabilities (or <code class="docutils literal"><span class="pre">NULL</span></code> if VHT isn&#8217;t enabled)</dd>
<dt><code class="docutils literal"><span class="pre">ht_required</span></code></dt>
<dd>stations must support HT</dd>
<dt><code class="docutils literal"><span class="pre">vht_required</span></code></dt>
<dd>stations must support VHT</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to configure an AP interface.</p>
<dl class="type">
<dt id="c.station_parameters">
struct <code class="descname">station_parameters</code><a class="headerlink" href="#c.station_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>station parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct station_parameters {
  const u8 * supported_rates;
  struct net_device * vlan;
  u32 sta_flags_mask;
  u32 sta_flags_set;
  u32 sta_modify_mask;
  int listen_interval;
  u16 aid;
  u16 peer_aid;
  u8 supported_rates_len;
  u8 plink_action;
  u8 plink_state;
  const struct ieee80211_ht_cap * ht_capa;
  const struct ieee80211_vht_cap * vht_capa;
  u8 uapsd_queues;
  u8 max_sp;
  enum nl80211_mesh_power_mode local_pm;
  u16 capability;
  const u8 * ext_capab;
  u8 ext_capab_len;
  const u8 * supported_channels;
  u8 supported_channels_len;
  const u8 * supported_oper_classes;
  u8 supported_oper_classes_len;
  u8 opmode_notif;
  bool opmode_notif_used;
  int support_p2p_ps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">supported_rates</span></code></dt>
<dd>supported rates in IEEE 802.11 format
(or NULL for no change)</dd>
<dt><code class="docutils literal"><span class="pre">vlan</span></code></dt>
<dd>vlan interface station should belong to</dd>
<dt><code class="docutils literal"><span class="pre">sta_flags_mask</span></code></dt>
<dd>station flags that changed
(bitmask of BIT(<code class="docutils literal"><span class="pre">NL80211_STA_FLAG_</span></code>...))</dd>
<dt><code class="docutils literal"><span class="pre">sta_flags_set</span></code></dt>
<dd>station flags values
(bitmask of BIT(<code class="docutils literal"><span class="pre">NL80211_STA_FLAG_</span></code>...))</dd>
<dt><code class="docutils literal"><span class="pre">sta_modify_mask</span></code></dt>
<dd>bitmap indicating which parameters changed
(for those that don&#8217;t have a natural &#8220;no change&#8221; value),
see <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">station_parameters_apply_mask</span></code></dd>
<dt><code class="docutils literal"><span class="pre">listen_interval</span></code></dt>
<dd>listen interval or -1 for no change</dd>
<dt><code class="docutils literal"><span class="pre">aid</span></code></dt>
<dd>AID or zero for no change</dd>
<dt><code class="docutils literal"><span class="pre">peer_aid</span></code></dt>
<dd>mesh peer AID or zero for no change</dd>
<dt><code class="docutils literal"><span class="pre">supported_rates_len</span></code></dt>
<dd>number of supported rates</dd>
<dt><code class="docutils literal"><span class="pre">plink_action</span></code></dt>
<dd>plink action to take</dd>
<dt><code class="docutils literal"><span class="pre">plink_state</span></code></dt>
<dd>set the peer link state for a station</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa</span></code></dt>
<dd>HT capabilities of station</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa</span></code></dt>
<dd>VHT capabilities of station</dd>
<dt><code class="docutils literal"><span class="pre">uapsd_queues</span></code></dt>
<dd>bitmap of queues configured for uapsd. same format
as the AC bitmap in the QoS info field</dd>
<dt><code class="docutils literal"><span class="pre">max_sp</span></code></dt>
<dd>max Service Period. same format as the MAX_SP in the
QoS info field (but already shifted down)</dd>
<dt><code class="docutils literal"><span class="pre">local_pm</span></code></dt>
<dd>local link-specific mesh power save mode (no change when set
to unknown)</dd>
<dt><code class="docutils literal"><span class="pre">capability</span></code></dt>
<dd>station capability</dd>
<dt><code class="docutils literal"><span class="pre">ext_capab</span></code></dt>
<dd>extended capabilities of the station</dd>
<dt><code class="docutils literal"><span class="pre">ext_capab_len</span></code></dt>
<dd>number of extended capabilities</dd>
<dt><code class="docutils literal"><span class="pre">supported_channels</span></code></dt>
<dd>supported channels in IEEE 802.11 format</dd>
<dt><code class="docutils literal"><span class="pre">supported_channels_len</span></code></dt>
<dd>number of supported channels</dd>
<dt><code class="docutils literal"><span class="pre">supported_oper_classes</span></code></dt>
<dd>supported oper classes in IEEE 802.11 format</dd>
<dt><code class="docutils literal"><span class="pre">supported_oper_classes_len</span></code></dt>
<dd>number of supported operating classes</dd>
<dt><code class="docutils literal"><span class="pre">opmode_notif</span></code></dt>
<dd>operating mode field from Operating Mode Notification</dd>
<dt><code class="docutils literal"><span class="pre">opmode_notif_used</span></code></dt>
<dd>information if operating mode field is used</dd>
<dt><code class="docutils literal"><span class="pre">support_p2p_ps</span></code></dt>
<dd>information if station supports P2P PS mechanism</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to change and create a new station.</p>
<dl class="type">
<dt id="c.rate_info_flags">
enum <code class="descname">rate_info_flags</code><a class="headerlink" href="#c.rate_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate info flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">RATE_INFO_FLAGS_MCS</span></code></dt>
<dd>mcs field filled with HT MCS</dd>
<dt><code class="docutils literal"><span class="pre">RATE_INFO_FLAGS_VHT_MCS</span></code></dt>
<dd>mcs field filled with VHT MCS</dd>
<dt><code class="docutils literal"><span class="pre">RATE_INFO_FLAGS_SHORT_GI</span></code></dt>
<dd>400ns guard interval</dd>
<dt><code class="docutils literal"><span class="pre">RATE_INFO_FLAGS_60G</span></code></dt>
<dd>60GHz MCS</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate the specific rate transmission
type for 802.11n transmissions.</p>
<dl class="type">
<dt id="c.rate_info">
struct <code class="descname">rate_info</code><a class="headerlink" href="#c.rate_info" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct rate_info {
  u8 flags;
  u8 mcs;
  u16 legacy;
  u8 nss;
  u8 bw;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>bitflag of flags from <a class="reference internal" href="#c.rate_info_flags" title="rate_info_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">rate_info_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">mcs</span></code></dt>
<dd>mcs index if struct describes a 802.11n bitrate</dd>
<dt><code class="docutils literal"><span class="pre">legacy</span></code></dt>
<dd>bitrate in 100kbit/s for 802.11abg</dd>
<dt><code class="docutils literal"><span class="pre">nss</span></code></dt>
<dd>number of streams (VHT only)</dd>
<dt><code class="docutils literal"><span class="pre">bw</span></code></dt>
<dd>bandwidth (from <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">rate_info_bw</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Information about a receiving or transmitting bitrate</p>
<dl class="type">
<dt id="c.station_info">
struct <code class="descname">station_info</code><a class="headerlink" href="#c.station_info" title="Permalink to this definition">¶</a></dt>
<dd><p>station information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct station_info {
  u64 filled;
  u32 connected_time;
  u32 inactive_time;
  u64 rx_bytes;
  u64 tx_bytes;
  u16 llid;
  u16 plid;
  u8 plink_state;
  s8 signal;
  s8 signal_avg;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
  struct rate_info txrate;
  struct rate_info rxrate;
  u32 rx_packets;
  u32 tx_packets;
  u32 tx_retries;
  u32 tx_failed;
  u32 rx_dropped_misc;
  struct sta_bss_parameters bss_param;
  struct nl80211_sta_flag_update sta_flags;
  int generation;
  const u8 * assoc_req_ies;
  size_t assoc_req_ies_len;
  u32 beacon_loss_count;
  s64 t_offset;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
  u32 expected_throughput;
  u64 rx_beacon;
  u64 rx_duration;
  u8 rx_beacon_signal_avg;
  struct cfg80211_tid_stats pertid[IEEE80211_NUM_TIDS + 1];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">filled</span></code></dt>
<dd>bitflag of flags using the bits of <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_sta_info</span></code> to
indicate the relevant values in this struct for them</dd>
<dt><code class="docutils literal"><span class="pre">connected_time</span></code></dt>
<dd>time(in secs) since a station is last connected</dd>
<dt><code class="docutils literal"><span class="pre">inactive_time</span></code></dt>
<dd>time since last station activity (tx/rx) in milliseconds</dd>
<dt><code class="docutils literal"><span class="pre">rx_bytes</span></code></dt>
<dd>bytes (size of MPDUs) received from this station</dd>
<dt><code class="docutils literal"><span class="pre">tx_bytes</span></code></dt>
<dd>bytes (size of MPDUs) transmitted to this station</dd>
<dt><code class="docutils literal"><span class="pre">llid</span></code></dt>
<dd>mesh local link id</dd>
<dt><code class="docutils literal"><span class="pre">plid</span></code></dt>
<dd>mesh peer link id</dd>
<dt><code class="docutils literal"><span class="pre">plink_state</span></code></dt>
<dd>mesh peer link state</dd>
<dt><code class="docutils literal"><span class="pre">signal</span></code></dt>
<dd>The signal strength, type depends on the wiphy&#8217;s signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</dd>
<dt><code class="docutils literal"><span class="pre">signal_avg</span></code></dt>
<dd>Average signal strength, type depends on the wiphy&#8217;s signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</dd>
<dt><code class="docutils literal"><span class="pre">chains</span></code></dt>
<dd>bitmask for filled values in <strong>chain_signal</strong>, <strong>chain_signal_avg</strong></dd>
<dt><code class="docutils literal"><span class="pre">chain_signal[IEEE80211_MAX_CHAINS]</span></code></dt>
<dd>per-chain signal strength of last received packet in dBm</dd>
<dt><code class="docutils literal"><span class="pre">chain_signal_avg[IEEE80211_MAX_CHAINS]</span></code></dt>
<dd>per-chain signal strength average in dBm</dd>
<dt><code class="docutils literal"><span class="pre">txrate</span></code></dt>
<dd>current unicast bitrate from this station</dd>
<dt><code class="docutils literal"><span class="pre">rxrate</span></code></dt>
<dd>current unicast bitrate to this station</dd>
<dt><code class="docutils literal"><span class="pre">rx_packets</span></code></dt>
<dd>packets (MSDUs &amp; MMPDUs) received from this station</dd>
<dt><code class="docutils literal"><span class="pre">tx_packets</span></code></dt>
<dd>packets (MSDUs &amp; MMPDUs) transmitted to this station</dd>
<dt><code class="docutils literal"><span class="pre">tx_retries</span></code></dt>
<dd>cumulative retry counts (MPDUs)</dd>
<dt><code class="docutils literal"><span class="pre">tx_failed</span></code></dt>
<dd>number of failed transmissions (MPDUs) (retries exceeded, no ACK)</dd>
<dt><code class="docutils literal"><span class="pre">rx_dropped_misc</span></code></dt>
<dd>Dropped for un-specified reason.</dd>
<dt><code class="docutils literal"><span class="pre">bss_param</span></code></dt>
<dd>current BSS parameters</dd>
<dt><code class="docutils literal"><span class="pre">sta_flags</span></code></dt>
<dd>station flags mask &amp; values</dd>
<dt><code class="docutils literal"><span class="pre">generation</span></code></dt>
<dd>generation number for nl80211 dumps.
This number should increase every time the list of stations
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.</dd>
<dt><code class="docutils literal"><span class="pre">assoc_req_ies</span></code></dt>
<dd>IEs from (Re)Association Request.
This is used only when in AP mode with drivers that do not use
user space MLME/SME implementation. The information is provided for
the <a class="reference internal" href="#c.cfg80211_new_sta" title="cfg80211_new_sta"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_new_sta()</span></code></a> calls to notify user space of the IEs.</dd>
<dt><code class="docutils literal"><span class="pre">assoc_req_ies_len</span></code></dt>
<dd>Length of assoc_req_ies buffer in octets.</dd>
<dt><code class="docutils literal"><span class="pre">beacon_loss_count</span></code></dt>
<dd>Number of times beacon loss event has triggered.</dd>
<dt><code class="docutils literal"><span class="pre">t_offset</span></code></dt>
<dd>Time offset of the station relative to this host.</dd>
<dt><code class="docutils literal"><span class="pre">local_pm</span></code></dt>
<dd>local mesh STA power save mode</dd>
<dt><code class="docutils literal"><span class="pre">peer_pm</span></code></dt>
<dd>peer mesh STA power save mode</dd>
<dt><code class="docutils literal"><span class="pre">nonpeer_pm</span></code></dt>
<dd>non-peer mesh STA power save mode</dd>
<dt><code class="docutils literal"><span class="pre">expected_throughput</span></code></dt>
<dd>expected throughput in kbps (including 802.11 headers)
towards this station.</dd>
<dt><code class="docutils literal"><span class="pre">rx_beacon</span></code></dt>
<dd>number of beacons received from this peer</dd>
<dt><code class="docutils literal"><span class="pre">rx_duration</span></code></dt>
<dd>aggregate PPDU duration(usecs) for all the frames from a peer</dd>
<dt><code class="docutils literal"><span class="pre">rx_beacon_signal_avg</span></code></dt>
<dd>signal strength average (in dBm) for beacons received
from this peer</dd>
<dt><code class="docutils literal"><span class="pre">pertid[IEEE80211_NUM_TIDS</span> <span class="pre">+</span> <span class="pre">1]</span></code></dt>
<dd>per-TID statistics, see <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_tid_stats</span></code>, using the last
(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Station information filled by driver for <code class="xref c c-func docutils literal"><span class="pre">get_station()</span></code> and dump_station.</p>
<dl class="type">
<dt id="c.monitor_flags">
enum <code class="descname">monitor_flags</code><a class="headerlink" href="#c.monitor_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>monitor flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_FCSFAIL</span></code></dt>
<dd>pass frames with bad FCS</dd>
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_PLCPFAIL</span></code></dt>
<dd>pass frames with bad PLCP</dd>
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_CONTROL</span></code></dt>
<dd>pass control frames</dd>
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_OTHER_BSS</span></code></dt>
<dd>disable BSSID filtering</dd>
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_COOK_FRAMES</span></code></dt>
<dd>report frames after processing</dd>
<dt><code class="docutils literal"><span class="pre">MONITOR_FLAG_ACTIVE</span></code></dt>
<dd>active monitor, ACKs frames on its MAC address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Monitor interface configuration flags. Note that these must be the bits
according to the nl80211 flags.</p>
<dl class="type">
<dt id="c.mpath_info_flags">
enum <code class="descname">mpath_info_flags</code><a class="headerlink" href="#c.mpath_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>mesh path information flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_FRAME_QLEN</span></code></dt>
<dd><strong>frame_qlen</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_SN</span></code></dt>
<dd><strong>sn</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_METRIC</span></code></dt>
<dd><strong>metric</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_EXPTIME</span></code></dt>
<dd><strong>exptime</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_DISCOVERY_TIMEOUT</span></code></dt>
<dd><strong>discovery_timeout</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_DISCOVERY_RETRIES</span></code></dt>
<dd><strong>discovery_retries</strong> filled</dd>
<dt><code class="docutils literal"><span class="pre">MPATH_INFO_FLAGS</span></code></dt>
<dd><strong>flags</strong> filled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate which info in <a class="reference internal" href="#c.mpath_info" title="mpath_info"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mpath_info</span></code></a> it has filled
in during <code class="xref c c-func docutils literal"><span class="pre">get_station()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">dump_station()</span></code>.</p>
<dl class="type">
<dt id="c.mpath_info">
struct <code class="descname">mpath_info</code><a class="headerlink" href="#c.mpath_info" title="Permalink to this definition">¶</a></dt>
<dd><p>mesh path information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mpath_info {
  u32 filled;
  u32 frame_qlen;
  u32 sn;
  u32 metric;
  u32 exptime;
  u32 discovery_timeout;
  u8 discovery_retries;
  u8 flags;
  int generation;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">filled</span></code></dt>
<dd>bitfield of flags from <a class="reference internal" href="#c.mpath_info_flags" title="mpath_info_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">mpath_info_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">frame_qlen</span></code></dt>
<dd>number of queued frames for this destination</dd>
<dt><code class="docutils literal"><span class="pre">sn</span></code></dt>
<dd>target sequence number</dd>
<dt><code class="docutils literal"><span class="pre">metric</span></code></dt>
<dd>metric (cost) of this mesh path</dd>
<dt><code class="docutils literal"><span class="pre">exptime</span></code></dt>
<dd>expiration time for the mesh path from now, in msecs</dd>
<dt><code class="docutils literal"><span class="pre">discovery_timeout</span></code></dt>
<dd>total mesh path discovery timeout, in msecs</dd>
<dt><code class="docutils literal"><span class="pre">discovery_retries</span></code></dt>
<dd>mesh path discovery retries</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>mesh path flags</dd>
<dt><code class="docutils literal"><span class="pre">generation</span></code></dt>
<dd>generation number for nl80211 dumps.
This number should increase every time the list of mesh paths
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mesh path information filled by driver for <code class="xref c c-func docutils literal"><span class="pre">get_mpath()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">dump_mpath()</span></code>.</p>
<dl class="type">
<dt id="c.bss_parameters">
struct <code class="descname">bss_parameters</code><a class="headerlink" href="#c.bss_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct bss_parameters {
  int use_cts_prot;
  int use_short_preamble;
  int use_short_slot_time;
  const u8 * basic_rates;
  u8 basic_rates_len;
  int ap_isolate;
  int ht_opmode;
  s8 p2p_ctwindow;
  s8 p2p_opp_ps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">use_cts_prot</span></code></dt>
<dd>Whether to use CTS protection
(0 = no, 1 = yes, -1 = do not change)</dd>
<dt><code class="docutils literal"><span class="pre">use_short_preamble</span></code></dt>
<dd>Whether the use of short preambles is allowed
(0 = no, 1 = yes, -1 = do not change)</dd>
<dt><code class="docutils literal"><span class="pre">use_short_slot_time</span></code></dt>
<dd>Whether the use of short slot time is allowed
(0 = no, 1 = yes, -1 = do not change)</dd>
<dt><code class="docutils literal"><span class="pre">basic_rates</span></code></dt>
<dd>basic rates in IEEE 802.11 format
(or NULL for no change)</dd>
<dt><code class="docutils literal"><span class="pre">basic_rates_len</span></code></dt>
<dd>number of basic rates</dd>
<dt><code class="docutils literal"><span class="pre">ap_isolate</span></code></dt>
<dd>do not forward packets between connected stations</dd>
<dt><code class="docutils literal"><span class="pre">ht_opmode</span></code></dt>
<dd>HT Operation mode
(u16 = opmode, -1 = do not change)</dd>
<dt><code class="docutils literal"><span class="pre">p2p_ctwindow</span></code></dt>
<dd>P2P CT Window (-1 = no change)</dd>
<dt><code class="docutils literal"><span class="pre">p2p_opp_ps</span></code></dt>
<dd>P2P opportunistic PS (-1 = no change)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to change BSS parameters (mainly for AP mode).</p>
<dl class="type">
<dt id="c.ieee80211_txq_params">
struct <code class="descname">ieee80211_txq_params</code><a class="headerlink" href="#c.ieee80211_txq_params" title="Permalink to this definition">¶</a></dt>
<dd><p>TX queue parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_txq_params {
  enum nl80211_ac ac;
  u16 txop;
  u16 cwmin;
  u16 cwmax;
  u8 aifs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ac</span></code></dt>
<dd>AC identifier</dd>
<dt><code class="docutils literal"><span class="pre">txop</span></code></dt>
<dd>Maximum burst time in units of 32 usecs, 0 meaning disabled</dd>
<dt><code class="docutils literal"><span class="pre">cwmin</span></code></dt>
<dd>Minimum contention window [a value of the form 2^n-1 in the range
1..32767]</dd>
<dt><code class="docutils literal"><span class="pre">cwmax</span></code></dt>
<dd>Maximum contention window [a value of the form 2^n-1 in the range
1..32767]</dd>
<dt><code class="docutils literal"><span class="pre">aifs</span></code></dt>
<dd>Arbitration interframe space [0..255]</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_crypto_settings">
struct <code class="descname">cfg80211_crypto_settings</code><a class="headerlink" href="#c.cfg80211_crypto_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Crypto settings</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_crypto_settings {
  u32 wpa_versions;
  u32 cipher_group;
  int n_ciphers_pairwise;
  u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
  int n_akm_suites;
  u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
  bool control_port;
  __be16 control_port_ethertype;
  bool control_port_no_encrypt;
  struct key_params * wep_keys;
  int wep_tx_key;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wpa_versions</span></code></dt>
<dd>indicates which, if any, WPA versions are enabled
(from enum nl80211_wpa_versions)</dd>
<dt><code class="docutils literal"><span class="pre">cipher_group</span></code></dt>
<dd>group key cipher suite (or 0 if unset)</dd>
<dt><code class="docutils literal"><span class="pre">n_ciphers_pairwise</span></code></dt>
<dd>number of AP supported unicast ciphers</dd>
<dt><code class="docutils literal"><span class="pre">ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES]</span></code></dt>
<dd>unicast key cipher suites</dd>
<dt><code class="docutils literal"><span class="pre">n_akm_suites</span></code></dt>
<dd>number of AKM suites</dd>
<dt><code class="docutils literal"><span class="pre">akm_suites[NL80211_MAX_NR_AKM_SUITES]</span></code></dt>
<dd>AKM suites</dd>
<dt><code class="docutils literal"><span class="pre">control_port</span></code></dt>
<dd>Whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="docutils literal"><span class="pre">NL80211_STA_FLAG_AUTHORIZED</span></code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.</dd>
<dt><code class="docutils literal"><span class="pre">control_port_ethertype</span></code></dt>
<dd>the control port protocol that should be
allowed through even on unauthorized ports</dd>
<dt><code class="docutils literal"><span class="pre">control_port_no_encrypt</span></code></dt>
<dd>TRUE to prevent encryption of control port
protocol frames.</dd>
<dt><code class="docutils literal"><span class="pre">wep_keys</span></code></dt>
<dd>static WEP keys, if not NULL points to an array of
CFG80211_MAX_WEP_KEYS WEP keys</dd>
<dt><code class="docutils literal"><span class="pre">wep_tx_key</span></code></dt>
<dd>key index (0..3) of the default TX static WEP key</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_auth_request">
struct <code class="descname">cfg80211_auth_request</code><a class="headerlink" href="#c.cfg80211_auth_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Authentication request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_auth_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  enum nl80211_auth_type auth_type;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  const u8 * auth_data;
  size_t auth_data_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bss</span></code></dt>
<dd>The BSS to authenticate with, the callee must obtain a reference
to it if it needs to keep it.</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>Extra IEs to add to Authentication frame or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>Length of ie buffer in octets</dd>
<dt><code class="docutils literal"><span class="pre">auth_type</span></code></dt>
<dd>Authentication type (algorithm)</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">key_len</span></code></dt>
<dd>length of WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">key_idx</span></code></dt>
<dd>index of WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">auth_data</span></code></dt>
<dd>Fields and elements in Authentication frames. This contains
the authentication frame body (non-IE and IE data), excluding the
Authentication algorithm number, i.e., starting at the Authentication
transaction sequence number field.</dd>
<dt><code class="docutils literal"><span class="pre">auth_data_len</span></code></dt>
<dd>Length of auth_data buffer in octets</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
authentication.</p>
<dl class="type">
<dt id="c.cfg80211_assoc_request">
struct <code class="descname">cfg80211_assoc_request</code><a class="headerlink" href="#c.cfg80211_assoc_request" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)Association request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_assoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  const u8 * prev_bssid;
  size_t ie_len;
  struct cfg80211_crypto_settings crypto;
  bool use_mfp;
  u32 flags;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
  const u8 * fils_kek;
  size_t fils_kek_len;
  const u8 * fils_nonces;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bss</span></code></dt>
<dd>The BSS to associate with. If the call is successful the driver is
given a reference that it must give back to <code class="xref c c-func docutils literal"><span class="pre">cfg80211_send_rx_assoc()</span></code>
or to <a class="reference internal" href="#c.cfg80211_assoc_timeout" title="cfg80211_assoc_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_assoc_timeout()</span></code></a>. To ensure proper refcounting, new
association requests while already associating must be rejected.</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>Extra IEs to add to (Re)Association Request frame or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">prev_bssid</span></code></dt>
<dd>previous BSSID, if not <code class="docutils literal"><span class="pre">NULL</span></code> use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.</dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>Length of ie buffer in octets</dd>
<dt><code class="docutils literal"><span class="pre">crypto</span></code></dt>
<dd>crypto settings</dd>
<dt><code class="docutils literal"><span class="pre">use_mfp</span></code></dt>
<dd>Use management frame protection (IEEE 802.11w) in this association</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>See <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">cfg80211_assoc_req_flags</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ht_capa</span></code></dt>
<dd>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa_mask</span></code></dt>
<dd>The bits of ht_capa which are to be used.</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa</span></code></dt>
<dd>VHT capability override</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa_mask</span></code></dt>
<dd>VHT capability mask indicating which fields to use</dd>
<dt><code class="docutils literal"><span class="pre">fils_kek</span></code></dt>
<dd>FILS KEK for protecting (Re)Association Request/Response frame or
<code class="docutils literal"><span class="pre">NULL</span></code> if FILS is not used.</dd>
<dt><code class="docutils literal"><span class="pre">fils_kek_len</span></code></dt>
<dd>Length of fils_kek in octets</dd>
<dt><code class="docutils literal"><span class="pre">fils_nonces</span></code></dt>
<dd>FILS nonces (part of AAD) for protecting (Re)Association
Request/Response frame or <code class="docutils literal"><span class="pre">NULL</span></code> if FILS is not used. This field starts
with 16 octets of STA Nonce followed by 16 octets of AP Nonce.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
(re)association.</p>
<dl class="type">
<dt id="c.cfg80211_deauth_request">
struct <code class="descname">cfg80211_deauth_request</code><a class="headerlink" href="#c.cfg80211_deauth_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Deauthentication request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_deauth_request {
  const u8 * bssid;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bssid</span></code></dt>
<dd>the BSSID of the BSS to deauthenticate from</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>Extra IEs to add to Deauthentication frame or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>Length of ie buffer in octets</dd>
<dt><code class="docutils literal"><span class="pre">reason_code</span></code></dt>
<dd>The reason code for the deauthentication</dd>
<dt><code class="docutils literal"><span class="pre">local_state_change</span></code></dt>
<dd>if set, change local state only and
do not set a deauth frame</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
deauthentication.</p>
<dl class="type">
<dt id="c.cfg80211_disassoc_request">
struct <code class="descname">cfg80211_disassoc_request</code><a class="headerlink" href="#c.cfg80211_disassoc_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Disassociation request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_disassoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bss</span></code></dt>
<dd>the BSS to disassociate from</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>Extra IEs to add to Disassociation frame or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>Length of ie buffer in octets</dd>
<dt><code class="docutils literal"><span class="pre">reason_code</span></code></dt>
<dd>The reason code for the disassociation</dd>
<dt><code class="docutils literal"><span class="pre">local_state_change</span></code></dt>
<dd>This is a request for a local state only, i.e., no
Disassociation frame is to be transmitted.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
disassocation.</p>
<dl class="type">
<dt id="c.cfg80211_ibss_params">
struct <code class="descname">cfg80211_ibss_params</code><a class="headerlink" href="#c.cfg80211_ibss_params" title="Permalink to this definition">¶</a></dt>
<dd><p>IBSS parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_ibss_params {
  const u8 * ssid;
  const u8 * bssid;
  struct cfg80211_chan_def chandef;
  const u8 * ie;
  u8 ssid_len;
  u8 ie_len;
  u16 beacon_interval;
  u32 basic_rates;
  bool channel_fixed;
  bool privacy;
  bool control_port;
  bool userspace_handles_dfs;
  int mcast_rate[NUM_NL80211_BANDS];
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ssid</span></code></dt>
<dd>The SSID, will always be non-null.</dd>
<dt><code class="docutils literal"><span class="pre">bssid</span></code></dt>
<dd>Fixed BSSID requested, maybe be <code class="docutils literal"><span class="pre">NULL</span></code>, if set do not
search for IBSSs with a different BSSID.</dd>
<dt><code class="docutils literal"><span class="pre">chandef</span></code></dt>
<dd>defines the channel to use if no other IBSS to join can be found</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>information element(s) to include in the beacon</dd>
<dt><code class="docutils literal"><span class="pre">ssid_len</span></code></dt>
<dd>The length of the SSID, will always be non-zero.</dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>length of that</dd>
<dt><code class="docutils literal"><span class="pre">beacon_interval</span></code></dt>
<dd>beacon interval to use</dd>
<dt><code class="docutils literal"><span class="pre">basic_rates</span></code></dt>
<dd>bitmap of basic rates to use when creating the IBSS</dd>
<dt><code class="docutils literal"><span class="pre">channel_fixed</span></code></dt>
<dd>The channel should be fixed &#8211; do not search for
IBSSs to join on other channels.</dd>
<dt><code class="docutils literal"><span class="pre">privacy</span></code></dt>
<dd>this is a protected network, keys will be configured
after joining</dd>
<dt><code class="docutils literal"><span class="pre">control_port</span></code></dt>
<dd>whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="docutils literal"><span class="pre">NL80211_STA_FLAG_AUTHORIZED</span></code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.</dd>
<dt><code class="docutils literal"><span class="pre">userspace_handles_dfs</span></code></dt>
<dd>whether user space controls DFS operation, i.e.
changes the channel when a radar is detected. This is required
to operate on DFS channels.</dd>
<dt><code class="docutils literal"><span class="pre">mcast_rate[NUM_NL80211_BANDS]</span></code></dt>
<dd>per-band multicast rate index + 1 (0: disabled)</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa</span></code></dt>
<dd>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa_mask</span></code></dt>
<dd>The bits of ht_capa which are to be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines the IBSS parameters for the <code class="xref c c-func docutils literal"><span class="pre">join_ibss()</span></code>
method.</p>
<dl class="type">
<dt id="c.cfg80211_connect_params">
struct <code class="descname">cfg80211_connect_params</code><a class="headerlink" href="#c.cfg80211_connect_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_connect_params {
  struct ieee80211_channel * channel;
  struct ieee80211_channel * channel_hint;
  const u8 * bssid;
  const u8 * bssid_hint;
  const u8 * ssid;
  size_t ssid_len;
  enum nl80211_auth_type auth_type;
  const u8 * ie;
  size_t ie_len;
  bool privacy;
  enum nl80211_mfp mfp;
  struct cfg80211_crypto_settings crypto;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  u32 flags;
  int bg_scan_period;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
  bool pbss;
  struct cfg80211_bss_selection bss_select;
  const u8 * prev_bssid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>The channel to use or <code class="docutils literal"><span class="pre">NULL</span></code> if not specified (auto-select based
on scan results)</dd>
<dt><code class="docutils literal"><span class="pre">channel_hint</span></code></dt>
<dd>The channel of the recommended BSS for initial connection or
<code class="docutils literal"><span class="pre">NULL</span></code> if not specified</dd>
<dt><code class="docutils literal"><span class="pre">bssid</span></code></dt>
<dd>The AP BSSID or <code class="docutils literal"><span class="pre">NULL</span></code> if not specified (auto-select based on scan
results)</dd>
<dt><code class="docutils literal"><span class="pre">bssid_hint</span></code></dt>
<dd>The recommended AP BSSID for initial connection to the BSS or
<code class="docutils literal"><span class="pre">NULL</span></code> if not specified. Unlike the <strong>bssid</strong> parameter, the driver is
allowed to ignore this <strong>bssid_hint</strong> if it has knowledge of a better BSS
to use.</dd>
<dt><code class="docutils literal"><span class="pre">ssid</span></code></dt>
<dd>SSID</dd>
<dt><code class="docutils literal"><span class="pre">ssid_len</span></code></dt>
<dd>Length of ssid in octets</dd>
<dt><code class="docutils literal"><span class="pre">auth_type</span></code></dt>
<dd>Authentication type (algorithm)</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>IEs for association request</dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>Length of assoc_ie in octets</dd>
<dt><code class="docutils literal"><span class="pre">privacy</span></code></dt>
<dd>indicates whether privacy-enabled APs should be used</dd>
<dt><code class="docutils literal"><span class="pre">mfp</span></code></dt>
<dd>indicate whether management frame protection is used</dd>
<dt><code class="docutils literal"><span class="pre">crypto</span></code></dt>
<dd>crypto settings</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">key_len</span></code></dt>
<dd>length of WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">key_idx</span></code></dt>
<dd>index of WEP key for shared key authentication</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>See <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">cfg80211_assoc_req_flags</span></code></dd>
<dt><code class="docutils literal"><span class="pre">bg_scan_period</span></code></dt>
<dd>Background scan period in seconds
or -1 to indicate that default value is to be used.</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa</span></code></dt>
<dd>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</dd>
<dt><code class="docutils literal"><span class="pre">ht_capa_mask</span></code></dt>
<dd>The bits of ht_capa which are to be used.</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa</span></code></dt>
<dd>VHT Capability overrides</dd>
<dt><code class="docutils literal"><span class="pre">vht_capa_mask</span></code></dt>
<dd>The bits of vht_capa which are to be used.</dd>
<dt><code class="docutils literal"><span class="pre">pbss</span></code></dt>
<dd>if set, connect to a PCP instead of AP. Valid for DMG
networks.</dd>
<dt><code class="docutils literal"><span class="pre">bss_select</span></code></dt>
<dd>criteria to be used for BSS selection.</dd>
<dt><code class="docutils literal"><span class="pre">prev_bssid</span></code></dt>
<dd>previous BSSID, if not <code class="docutils literal"><span class="pre">NULL</span></code> use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
authentication and association.</p>
<dl class="type">
<dt id="c.cfg80211_pmksa">
struct <code class="descname">cfg80211_pmksa</code><a class="headerlink" href="#c.cfg80211_pmksa" title="Permalink to this definition">¶</a></dt>
<dd><p>PMK Security Association</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_pmksa {
  const u8 * bssid;
  const u8 * pmkid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bssid</span></code></dt>
<dd>The AP&#8217;s BSSID.</dd>
<dt><code class="docutils literal"><span class="pre">pmkid</span></code></dt>
<dd>The PMK material itself.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is passed to the set/<code class="xref c c-func docutils literal"><span class="pre">del_pmksa()</span></code> method for PMKSA
caching.</p>
<dl class="function">
<dt id="c.cfg80211_rx_mlme_mgmt">
void <code class="descname">cfg80211_rx_mlme_mgmt</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_mlme_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of processed MLME management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>authentication frame (header + body)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the frame data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever an authentication, disassociation or
deauthentication frame has been received and processed in station mode.
After being asked to authenticate via cfg80211_ops::<code class="xref c c-func docutils literal"><span class="pre">auth()</span></code> the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_auth_timeout()</span></code></a>.
After being asked to associate via cfg80211_ops::<code class="xref c c-func docutils literal"><span class="pre">assoc()</span></code> the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_auth_timeout()</span></code></a>.
While connected, the driver must calls this for received and processed
disassociation and deauthentication frames. If the frame couldn&#8217;t be used
because it was unprotected, the driver must call the function
<code class="xref c c-func docutils literal"><span class="pre">cfg80211_rx_unprot_mlme_mgmt()</span></code> instead.</p>
<p>This function may sleep. The caller must hold the corresponding wdev&#8217;s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_auth_timeout">
void <code class="descname">cfg80211_auth_timeout</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_auth_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of timed out authentication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The MAC address of the device with which the authentication timed out</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function may sleep. The caller must hold the corresponding wdev&#8217;s
mutex.</p>
<dl class="function">
<dt id="c.cfg80211_rx_assoc_resp">
void <code class="descname">cfg80211_rx_assoc_resp</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em>&nbsp;bss</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em>, int<em>&nbsp;uapsd_queues</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_assoc_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of processed association response</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt>
<dd>the BSS that association was requested with, ownership of the pointer
moves to cfg80211 in this call</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>authentication frame (header + body)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the frame data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">uapsd_queues</span></code></dt>
<dd>bitmap of queues configured for uapsd. Same format
as the AC bitmap in the QoS info field</dd>
</dl>
<p><strong>Description</strong></p>
<p>After being asked to associate via cfg80211_ops::<code class="xref c c-func docutils literal"><span class="pre">assoc()</span></code> the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_auth_timeout()</span></code></a>.</p>
<p>This function may sleep. The caller must hold the corresponding wdev&#8217;s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_assoc_timeout">
void <code class="descname">cfg80211_assoc_timeout</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em>&nbsp;bss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_assoc_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of timed out association</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt>
<dd>The BSS entry with which association timed out.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function may sleep. The caller must hold the corresponding wdev&#8217;s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_tx_mlme_mgmt">
void <code class="descname">cfg80211_tx_mlme_mgmt</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_tx_mlme_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of transmitted deauth/disassoc frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>802.11 frame (header + body)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the frame data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever deauthentication has been processed in
station mode. This includes both received deauthentication frames and
locally generated ones. This function may sleep. The caller must hold the
corresponding wdev&#8217;s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_ibss_joined">
void <code class="descname">cfg80211_ibss_joined</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;bssid</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em>&nbsp;channel</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_ibss_joined" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 that device joined an IBSS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the IBSS joined</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">channel</span></code></dt>
<dd>the channel of the IBSS joined</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function notifies cfg80211 that the device joined an IBSS or
switched to a different BSSID. Before this function can be called,
either a beacon has to have been received from the IBSS, or one of
the cfg80211_inform_bss{,_frame} functions must have been called
with the locally generated beacon &#8211; this guarantees that there is
always a scan result for this IBSS. cfg80211 will handle the rest.</p>
<dl class="function">
<dt id="c.cfg80211_connect_result">
void <code class="descname">cfg80211_connect_result</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;bssid</em>, const u8 *<em>&nbsp;req_ie</em>, size_t<em>&nbsp;req_ie_len</em>, const u8 *<em>&nbsp;resp_ie</em>, size_t<em>&nbsp;resp_ie_len</em>, u16<em>&nbsp;status</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_result" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the AP</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt>
<dd>association request IEs (maybe be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt>
<dd>association request IEs length</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">resp_ie</span></code></dt>
<dd>association response IEs (may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">resp_ie_len</span></code></dt>
<dd>assoc response IEs length</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">status</span></code></dt>
<dd>status code, <code class="docutils literal"><span class="pre">WLAN_STATUS_SUCCESS</span></code> for successful connection, use
<code class="docutils literal"><span class="pre">WLAN_STATUS_UNSPECIFIED_FAILURE</span></code> if your device cannot give you
the real status code for failures.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver once execution of the connection
request from <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> has been completed. This is similar to
<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_bss()</span></code></a> which allows the exact bss entry to be specified. Only
one of these functions should be called.</p>
<dl class="function">
<dt id="c.cfg80211_connect_bss">
void <code class="descname">cfg80211_connect_bss</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;bssid</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em>&nbsp;bss</em>, const u8 *<em>&nbsp;req_ie</em>, size_t<em>&nbsp;req_ie_len</em>, const u8 *<em>&nbsp;resp_ie</em>, size_t<em>&nbsp;resp_ie_len</em>, int<em>&nbsp;status</em>, gfp_t<em>&nbsp;gfp</em>, enum nl80211_timeout_reason<em>&nbsp;timeout_reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the AP</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt>
<dd>entry of bss to which STA got connected to, can be obtained
through cfg80211_get_bss (may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt>
<dd>association request IEs (maybe be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt>
<dd>association request IEs length</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">resp_ie</span></code></dt>
<dd>association response IEs (may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">resp_ie_len</span></code></dt>
<dd>assoc response IEs length</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>status code, <code class="docutils literal"><span class="pre">WLAN_STATUS_SUCCESS</span></code> for successful connection, use
<code class="docutils literal"><span class="pre">WLAN_STATUS_UNSPECIFIED_FAILURE</span></code> if your device cannot give you
the real status code for failures. If this call is used to report a
failure due to a timeout (e.g., not receiving an Authentication frame
from the AP) instead of an explicit rejection by the AP, -1 is used to
indicate that this is a failure, but without a status code.
<strong>timeout_reason</strong> is used to report the reason for the timeout in that
case.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_timeout_reason</span> <span class="pre">timeout_reason</span></code></dt>
<dd>reason for connection timeout. This is used when the
connection fails due to a timeout instead of an explicit rejection from
the AP. <code class="docutils literal"><span class="pre">NL80211_TIMEOUT_UNSPECIFIED</span></code> is used when the timeout reason is
not known. This value is used only if <strong>status</strong> &lt; 0 to indicate that the
failure is due to a timeout and not due to explicit rejection by the AP.
This value is ignored in other cases (<strong>status</strong> &gt;= 0).</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver once execution of the connection
request from <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> has been completed. This is similar to
<a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_connect_result()</span></code></a>, but with the option of identifying the exact bss
entry for the connection. Only one of these functions should be called.</p>
<dl class="function">
<dt id="c.cfg80211_connect_timeout">
void <code class="descname">cfg80211_connect_timeout</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;bssid</em>, const u8 *<em>&nbsp;req_ie</em>, size_t<em>&nbsp;req_ie_len</em>, gfp_t<em>&nbsp;gfp</em>, enum nl80211_timeout_reason<em>&nbsp;timeout_reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the AP</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt>
<dd>association request IEs (maybe be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt>
<dd>association request IEs length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_timeout_reason</span> <span class="pre">timeout_reason</span></code></dt>
<dd>reason for connection timeout.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver whenever <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> has failed
in a sequence where no explicit authentication/association rejection was
received from the AP. This could happen, e.g., due to not being able to send
out the Authentication or Association Request frame or timing out while
waiting for the response.</p>
<dl class="function">
<dt id="c.cfg80211_roamed">
void <code class="descname">cfg80211_roamed</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em>&nbsp;channel</em>, const u8 *<em>&nbsp;bssid</em>, const u8 *<em>&nbsp;req_ie</em>, size_t<em>&nbsp;req_ie_len</em>, const u8 *<em>&nbsp;resp_ie</em>, size_t<em>&nbsp;resp_ie_len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_roamed" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of roaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">channel</span></code></dt>
<dd>the channel of the new AP</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the new AP</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt>
<dd>association request IEs (maybe be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt>
<dd>association request IEs length</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">resp_ie</span></code></dt>
<dd>association response IEs (may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">resp_ie_len</span></code></dt>
<dd>assoc response IEs length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver whenever it roamed
from one AP to another while connected.</p>
<dl class="function">
<dt id="c.cfg80211_disconnected">
void <code class="descname">cfg80211_disconnected</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, u16<em>&nbsp;reason</em>, const u8 *<em>&nbsp;ie</em>, size_t<em>&nbsp;ie_len</em>, bool<em>&nbsp;locally_generated</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 that connection was dropped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">reason</span></code></dt>
<dd>reason code for the disconnection, set it to 0 if unknown</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ie</span></code></dt>
<dd>information elements of the deauth/disassoc frame (may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">ie_len</span></code></dt>
<dd>length of IEs</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">locally_generated</span></code></dt>
<dd>disconnection was requested locally</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>After it calls this function, the driver should enter an idle state
and not try to connect to any AP any more.</p>
<dl class="function">
<dt id="c.cfg80211_ready_on_channel">
void <code class="descname">cfg80211_ready_on_channel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em>&nbsp;wdev</em>, u64<em>&nbsp;cookie</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em>&nbsp;chan</em>, unsigned int<em>&nbsp;duration</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_ready_on_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of remain_on_channel start</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt>
<dd>wireless device</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt>
<dd>the request cookie</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>The current channel (from remain_on_channel request)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duration</span></code></dt>
<dd>Duration in milliseconds that the driver intents to remain on the
channel</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_remain_on_channel_expired">
void <code class="descname">cfg80211_remain_on_channel_expired</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em>&nbsp;wdev</em>, u64<em>&nbsp;cookie</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em>&nbsp;chan</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_remain_on_channel_expired" title="Permalink to this definition">¶</a></dt>
<dd><p>remain_on_channel duration expired</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt>
<dd>wireless device</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt>
<dd>the request cookie</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>The current channel (from remain_on_channel request)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_new_sta">
void <code class="descname">cfg80211_new_sta</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;mac_addr</em>, struct <a class="reference internal" href="#c.station_info" title="station_info">station_info</a> *<em>&nbsp;sinfo</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_new_sta" title="Permalink to this definition">¶</a></dt>
<dd><p>notify userspace about station</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the netdev</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mac_addr</span></code></dt>
<dd>the station&#8217;s address</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">station_info</span> <span class="pre">*</span> <span class="pre">sinfo</span></code></dt>
<dd>the station information</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_rx_mgmt">
bool <code class="descname">cfg80211_rx_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em>&nbsp;wdev</em>, int<em>&nbsp;freq</em>, int<em>&nbsp;sig_dbm</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of received, unprocessed management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt>
<dd>wireless device receiving the frame</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">freq</span></code></dt>
<dd>Frequency on which the frame was received in MHz</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig_dbm</span></code></dt>
<dd>signal strength in mBm, or 0 if unknown</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Management frame (header + body)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the frame data</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags, as defined in enum nl80211_rxmgmt_flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever an Action frame is received for a station
mode interface, but is not processed in kernel.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if a user space application has registered for this frame.
For action frames, that makes it responsible for rejecting unrecognized
action frames; <code class="docutils literal"><span class="pre">false</span></code> otherwise, in which case for action frames the
driver is responsible for rejecting the frame.</p>
<dl class="function">
<dt id="c.cfg80211_mgmt_tx_status">
void <code class="descname">cfg80211_mgmt_tx_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em>&nbsp;wdev</em>, u64<em>&nbsp;cookie</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em>, bool<em>&nbsp;ack</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_mgmt_tx_status" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of TX status for management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt>
<dd>wireless device receiving the frame</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt>
<dd>Cookie returned by cfg80211_ops::<code class="xref c c-func docutils literal"><span class="pre">mgmt_tx()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Management frame (header + body)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the frame data</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">ack</span></code></dt>
<dd>Whether frame was acknowledged</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>context flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever a management frame was requested to be
transmitted with cfg80211_ops::<code class="xref c c-func docutils literal"><span class="pre">mgmt_tx()</span></code> to report the TX status of the
transmission attempt.</p>
<dl class="function">
<dt id="c.cfg80211_cqm_rssi_notify">
void <code class="descname">cfg80211_cqm_rssi_notify</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, enum nl80211_cqm_rssi_threshold_event<em>&nbsp;rssi_event</em>, s32<em>&nbsp;rssi_level</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_cqm_rssi_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>connection quality monitoring rssi event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_cqm_rssi_threshold_event</span> <span class="pre">rssi_event</span></code></dt>
<dd>the triggered RSSI event</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">rssi_level</span></code></dt>
<dd>new RSSI level value or 0 if not available</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>context flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when a configured connection quality monitoring
rssi threshold reached event occurs.</p>
<dl class="function">
<dt id="c.cfg80211_cqm_pktloss_notify">
void <code class="descname">cfg80211_cqm_pktloss_notify</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;peer</em>, u32<em>&nbsp;num_packets</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_cqm_pktloss_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notify userspace about packetloss to peer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">peer</span></code></dt>
<dd>peer&#8217;s MAC address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">num_packets</span></code></dt>
<dd>how many packets were lost &#8211; should be a fixed threshold
but probably no less than maybe 50, or maybe a throughput dependent
threshold (to account for temporary interference)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>context flags</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_michael_mic_failure">
void <code class="descname">cfg80211_michael_mic_failure</code><span class="sig-paren">(</span>struct net_device *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;addr</em>, enum nl80211_key_type<em>&nbsp;key_type</em>, int<em>&nbsp;key_id</em>, const u8 *<em>&nbsp;tsc</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_michael_mic_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of Michael MIC failure (TKIP)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The source MAC address of the frame</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_key_type</span> <span class="pre">key_type</span></code></dt>
<dd>The key type that the received frame used</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">key_id</span></code></dt>
<dd>Key identifier (0..3). Can be -1 if missing.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">tsc</span></code></dt>
<dd>The TSC value of the frame that generated the MIC failure (6 octets)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever the local MAC detects a MIC failure in a
received frame. This matches with MLME-MICHAELMICFAILURE.:c:func:<cite>indication()</cite>
primitive.</p>
</div>
<div class="section" id="scanning-and-bss-list-handling">
<h2>Scanning and BSS list handling<a class="headerlink" href="#scanning-and-bss-list-handling" title="Permalink to this headline">¶</a></h2>
<p>The scanning process itself is fairly simple, but cfg80211 offers quite
a bit of helper functionality. To start a scan, the scan operation will
be invoked with a scan definition. This scan definition contains the
channels to scan, and the SSIDs to send probe requests for (including the
wildcard, if desired). A passive scan is indicated by having no SSIDs to
probe. Additionally, a scan request may contain extra information elements
that should be added to the probe request. The IEs are guaranteed to be
well-formed, and will not exceed the maximum length the driver advertised
in the wiphy structure.</p>
<p>When scanning finds a BSS, cfg80211 needs to be notified of that, because
it is responsible for maintaining the BSS list; the driver should not
maintain a list itself. For this notification, various functions exist.</p>
<p>Since drivers do not maintain a BSS list, there are also a number of
functions to search for a BSS and obtain information about it from the
BSS structure cfg80211 maintains. The BSS list is also made available
to userspace.</p>
<dl class="type">
<dt id="c.cfg80211_ssid">
struct <code class="descname">cfg80211_ssid</code><a class="headerlink" href="#c.cfg80211_ssid" title="Permalink to this definition">¶</a></dt>
<dd><p>SSID description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_ssid {
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ssid[IEEE80211_MAX_SSID_LEN]</span></code></dt>
<dd>the SSID</dd>
<dt><code class="docutils literal"><span class="pre">ssid_len</span></code></dt>
<dd>length of the ssid</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_scan_request">
struct <code class="descname">cfg80211_scan_request</code><a class="headerlink" href="#c.cfg80211_scan_request" title="Permalink to this definition">¶</a></dt>
<dd><p>scan request description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_scan_request {
  struct cfg80211_ssid * ssids;
  int n_ssids;
  u32 n_channels;
  enum nl80211_bss_scan_width scan_width;
  const u8 * ie;
  size_t ie_len;
  u16 duration;
  bool duration_mandatory;
  u32 flags;
  u32 rates[NUM_NL80211_BANDS];
  struct wireless_dev * wdev;
  u8 mac_addr[ETH_ALEN];
  u8 mac_addr_mask[ETH_ALEN];
  u8 bssid[ETH_ALEN];
  struct wiphy * wiphy;
  unsigned long scan_start;
  struct cfg80211_scan_info info;
  bool notified;
  bool no_cck;
  struct ieee80211_channel * channels[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ssids</span></code></dt>
<dd>SSIDs to scan for (active scan only)</dd>
<dt><code class="docutils literal"><span class="pre">n_ssids</span></code></dt>
<dd>number of SSIDs</dd>
<dt><code class="docutils literal"><span class="pre">n_channels</span></code></dt>
<dd>total number of channels to scan</dd>
<dt><code class="docutils literal"><span class="pre">scan_width</span></code></dt>
<dd>channel width for scanning</dd>
<dt><code class="docutils literal"><span class="pre">ie</span></code></dt>
<dd>optional information element(s) to add into Probe Request or <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ie_len</span></code></dt>
<dd>length of ie in octets</dd>
<dt><code class="docutils literal"><span class="pre">duration</span></code></dt>
<dd>how long to listen on each channel, in TUs. If
<code class="docutils literal"><span class="pre">duration_mandatory</span></code> is not set, this is the maximum dwell time and
the actual dwell time may be shorter.</dd>
<dt><code class="docutils literal"><span class="pre">duration_mandatory</span></code></dt>
<dd>if set, the scan duration must be as specified by the
<code class="docutils literal"><span class="pre">duration</span></code> field.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>bit field of flags controlling operation</dd>
<dt><code class="docutils literal"><span class="pre">rates[NUM_NL80211_BANDS]</span></code></dt>
<dd>bitmap of rates to advertise for each band</dd>
<dt><code class="docutils literal"><span class="pre">wdev</span></code></dt>
<dd>the wireless device to scan for</dd>
<dt><code class="docutils literal"><span class="pre">mac_addr[ETH_ALEN]</span></code></dt>
<dd>MAC address used with randomisation</dd>
<dt><code class="docutils literal"><span class="pre">mac_addr_mask[ETH_ALEN]</span></code></dt>
<dd>MAC address mask used with randomisation, bits that
are 0 in the mask should be randomised, bits that are 1 should
be taken from the <strong>mac_addr</strong></dd>
<dt><code class="docutils literal"><span class="pre">bssid[ETH_ALEN]</span></code></dt>
<dd>BSSID to scan for (most commonly, the wildcard BSSID)</dd>
<dt><code class="docutils literal"><span class="pre">wiphy</span></code></dt>
<dd>the wiphy this was for</dd>
<dt><code class="docutils literal"><span class="pre">scan_start</span></code></dt>
<dd>time (in jiffies) when the scan started</dd>
<dt><code class="docutils literal"><span class="pre">info</span></code></dt>
<dd>(internal) information about completed scan</dd>
<dt><code class="docutils literal"><span class="pre">notified</span></code></dt>
<dd>(internal) scan request was notified as done or aborted</dd>
<dt><code class="docutils literal"><span class="pre">no_cck</span></code></dt>
<dd>used to send probe requests at non CCK rate in 2GHz band</dd>
<dt><code class="docutils literal"><span class="pre">channels[0]</span></code></dt>
<dd>channels to scan on.</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_scan_done">
void <code class="descname">cfg80211_scan_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cfg80211_scan_request" title="cfg80211_scan_request">cfg80211_scan_request</a> *<em>&nbsp;request</em>, struct cfg80211_scan_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_scan_done" title="Permalink to this definition">¶</a></dt>
<dd><p>notify that scan finished</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_scan_request</span> <span class="pre">*</span> <span class="pre">request</span></code></dt>
<dd>the corresponding scan request</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_scan_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>information about the completed scan</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_bss">
struct <code class="descname">cfg80211_bss</code><a class="headerlink" href="#c.cfg80211_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_bss {
  struct ieee80211_channel * channel;
  enum nl80211_bss_scan_width scan_width;
  const struct cfg80211_bss_ies __rcu * ies;
  const struct cfg80211_bss_ies __rcu * beacon_ies;
  const struct cfg80211_bss_ies __rcu * proberesp_ies;
  struct cfg80211_bss * hidden_beacon_bss;
  s32 signal;
  u16 beacon_interval;
  u16 capability;
  u8 bssid[ETH_ALEN];
  u8 priv[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>channel this BSS is on</dd>
<dt><code class="docutils literal"><span class="pre">scan_width</span></code></dt>
<dd>width of the control channel</dd>
<dt><code class="docutils literal"><span class="pre">ies</span></code></dt>
<dd>the information elements (Note that there is no guarantee that these
are well-formed!); this is a pointer to either the beacon_ies or
proberesp_ies depending on whether Probe Response frame has been
received. It is always non-<code class="docutils literal"><span class="pre">NULL</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">beacon_ies</span></code></dt>
<dd>the information elements from the last Beacon frame
(implementation note: if <strong>hidden_beacon_bss</strong> is set this struct doesn&#8217;t
own the beacon_ies, but they&#8217;re just pointers to the ones from the
<strong>hidden_beacon_bss</strong> struct)</dd>
<dt><code class="docutils literal"><span class="pre">proberesp_ies</span></code></dt>
<dd>the information elements from the last Probe Response frame</dd>
<dt><code class="docutils literal"><span class="pre">hidden_beacon_bss</span></code></dt>
<dd>in case this BSS struct represents a probe response from
a BSS that hides the SSID in its beacon, this points to the BSS struct
that holds the beacon data. <strong>beacon_ies</strong> is still valid, of course, and
points to the same data as hidden_beacon_bss-&gt;beacon_ies in that case.</dd>
<dt><code class="docutils literal"><span class="pre">signal</span></code></dt>
<dd>signal strength value (type depends on the wiphy&#8217;s signal_type)</dd>
<dt><code class="docutils literal"><span class="pre">beacon_interval</span></code></dt>
<dd>the beacon interval as from the frame</dd>
<dt><code class="docutils literal"><span class="pre">capability</span></code></dt>
<dd>the capability field in host byte order</dd>
<dt><code class="docutils literal"><span class="pre">bssid[ETH_ALEN]</span></code></dt>
<dd>BSSID of the BSS</dd>
<dt><code class="docutils literal"><span class="pre">priv[0]</span></code></dt>
<dd>private area for driver use, has at least wiphy-&gt;bss_priv_size bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a BSS (which may also be a mesh network)
for use in scan results and similar.</p>
<dl class="type">
<dt id="c.cfg80211_inform_bss">
struct <code class="descname">cfg80211_inform_bss</code><a class="headerlink" href="#c.cfg80211_inform_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS inform data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cfg80211_inform_bss {
  struct ieee80211_channel * chan;
  enum nl80211_bss_scan_width scan_width;
  s32 signal;
  u64 boottime_ns;
  u64 parent_tsf;
  u8 parent_bssid[ETH_ALEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chan</span></code></dt>
<dd>channel the frame was received on</dd>
<dt><code class="docutils literal"><span class="pre">scan_width</span></code></dt>
<dd>scan width that was used</dd>
<dt><code class="docutils literal"><span class="pre">signal</span></code></dt>
<dd>signal strength value, according to the wiphy&#8217;s
signal type</dd>
<dt><code class="docutils literal"><span class="pre">boottime_ns</span></code></dt>
<dd>timestamp (CLOCK_BOOTTIME) when the information was
received; should match the time when the frame was actually
received by the device (not just by the host, in case it was
buffered on the device) and be accurate to about 10ms.
If the frame isn&#8217;t buffered, just passing the return value of
<code class="xref c c-func docutils literal"><span class="pre">ktime_get_boot_ns()</span></code> is likely appropriate.</dd>
<dt><code class="docutils literal"><span class="pre">parent_tsf</span></code></dt>
<dd>the time at the start of reception of the first octet of the
timestamp field of the frame. The time is the TSF of the BSS specified
by <code class="docutils literal"><span class="pre">parent_bssid</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">parent_bssid[ETH_ALEN]</span></code></dt>
<dd>the BSS according to which <code class="docutils literal"><span class="pre">parent_tsf</span></code> is set. This is set to
the BSS that requested the scan in which the beacon/probe was received.</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_inform_bss_frame_data">
struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> * <code class="descname">cfg80211_inform_bss_frame_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss">cfg80211_inform_bss</a> *<em>&nbsp;data</em>, struct ieee80211_mgmt *<em>&nbsp;mgmt</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_inform_bss_frame_data" title="Permalink to this definition">¶</a></dt>
<dd><p>inform cfg80211 of a received BSS frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy reporting the BSS</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_inform_bss</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>the BSS metadata</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_mgmt</span> <span class="pre">*</span> <span class="pre">mgmt</span></code></dt>
<dd>the management frame (probe response or beacon)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the management frame</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>context flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This informs cfg80211 that BSS information was found and
the BSS should be updated/added.</p>
<p><strong>Return</strong></p>
<p>A referenced struct, must be released with <code class="xref c c-func docutils literal"><span class="pre">cfg80211_put_bss()</span></code>!
Or <code class="docutils literal"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.cfg80211_inform_bss_data">
struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> * <code class="descname">cfg80211_inform_bss_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss">cfg80211_inform_bss</a> *<em>&nbsp;data</em>, enum cfg80211_bss_frame_type<em>&nbsp;ftype</em>, const u8 *<em>&nbsp;bssid</em>, u64<em>&nbsp;tsf</em>, u16<em>&nbsp;capability</em>, u16<em>&nbsp;beacon_interval</em>, const u8 *<em>&nbsp;ie</em>, size_t<em>&nbsp;ielen</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_inform_bss_data" title="Permalink to this definition">¶</a></dt>
<dd><p>inform cfg80211 of a new BSS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy reporting the BSS</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_inform_bss</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>the BSS metadata</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cfg80211_bss_frame_type</span> <span class="pre">ftype</span></code></dt>
<dd>frame type (if known)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the BSSID of the BSS</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">tsf</span></code></dt>
<dd>the TSF sent by the peer in the beacon/probe response (or 0)</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">capability</span></code></dt>
<dd>the capability field sent by the peer</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">beacon_interval</span></code></dt>
<dd>the beacon interval announced by the peer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ie</span></code></dt>
<dd>additional IEs sent by the peer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">ielen</span></code></dt>
<dd>length of the additional IEs</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>context flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This informs cfg80211 that BSS information was found and
the BSS should be updated/added.</p>
<p><strong>Return</strong></p>
<p>A referenced struct, must be released with <code class="xref c c-func docutils literal"><span class="pre">cfg80211_put_bss()</span></code>!
Or <code class="docutils literal"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.cfg80211_unlink_bss">
void <code class="descname">cfg80211_unlink_bss</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em>&nbsp;bss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_unlink_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink BSS from internal data structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt>
<dd>the bss to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes the given BSS from the internal data structures
thereby making it no longer show up in scan results etc. Use this
function when you detect a BSS is gone. Normally BSSes will also time
out, so it is not necessary to use this function at all.</p>
<dl class="function">
<dt id="c.cfg80211_find_ie">
const u8 * <code class="descname">cfg80211_find_ie</code><span class="sig-paren">(</span>u8<em>&nbsp;eid</em>, const u8 *<em>&nbsp;ies</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_find_ie" title="Permalink to this definition">¶</a></dt>
<dd><p>find information element in data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">eid</span></code></dt>
<dd>element ID</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ies</span></code></dt>
<dd>data consisting of IEs</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> if the element ID could not be found or if
the element is invalid (claims to be longer than the given
data), or a pointer to the first byte of the requested
element, that is the byte containing the element ID.</p>
<p><strong>Note</strong></p>
<p>There are no checks on the element length other than
having to fit into the given data.</p>
<dl class="function">
<dt id="c.ieee80211_bss_get_ie">
const u8 * <code class="descname">ieee80211_bss_get_ie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em>&nbsp;bss</em>, u8<em>&nbsp;ie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_bss_get_ie" title="Permalink to this definition">¶</a></dt>
<dd><p>find IE with given ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt>
<dd>the bss to search</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">ie</span></code></dt>
<dd>the IE ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the return value is an RCU-protected pointer, so
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code> must be held when calling this function.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> if not found.</p>
</div>
<div class="section" id="utility-functions">
<h2>Utility functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<p>cfg80211 offers a number of utility functions that can be useful.</p>
<dl class="function">
<dt id="c.ieee80211_channel_to_frequency">
int <code class="descname">ieee80211_channel_to_frequency</code><span class="sig-paren">(</span>int<em>&nbsp;chan</em>, enum nl80211_band<em>&nbsp;band</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_channel_to_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>convert channel number to frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chan</span></code></dt>
<dd>channel number</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_band</span> <span class="pre">band</span></code></dt>
<dd>band, necessary due to channel number overlap</dd>
</dl>
<p><strong>Return</strong></p>
<p>The corresponding frequency (in MHz), or 0 if the conversion failed.</p>
<dl class="function">
<dt id="c.ieee80211_frequency_to_channel">
int <code class="descname">ieee80211_frequency_to_channel</code><span class="sig-paren">(</span>int<em>&nbsp;freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_frequency_to_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>convert frequency to channel number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">freq</span></code></dt>
<dd>center frequency</dd>
</dl>
<p><strong>Return</strong></p>
<p>The corresponding channel, or 0 if the conversion failed.</p>
<dl class="function">
<dt id="c.ieee80211_get_channel">
struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> * <code class="descname">ieee80211_get_channel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, int<em>&nbsp;freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>get channel struct from wiphy for specified frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the struct wiphy to get the channel for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">freq</span></code></dt>
<dd>the center frequency of the channel</dd>
</dl>
<p><strong>Return</strong></p>
<p>The channel struct from <strong>wiphy</strong> at <strong>freq</strong>.</p>
<dl class="function">
<dt id="c.ieee80211_get_response_rate">
struct <a class="reference internal" href="#c.ieee80211_rate" title="ieee80211_rate">ieee80211_rate</a> * <code class="descname">ieee80211_get_response_rate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_supported_band" title="ieee80211_supported_band">ieee80211_supported_band</a> *<em>&nbsp;sband</em>, u32<em>&nbsp;basic_rates</em>, int<em>&nbsp;bitrate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_response_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get basic rate for a given rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ieee80211_supported_band</span> <span class="pre">*</span> <span class="pre">sband</span></code></dt>
<dd>the band to look for rates in</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">basic_rates</span></code></dt>
<dd>bitmap of basic rates</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bitrate</span></code></dt>
<dd>the bitrate for which to find the basic rate</dd>
</dl>
<p><strong>Return</strong></p>
<p>The basic rate corresponding to a given bitrate, that
is the next lower bitrate contained in the basic rate map,
which is, for this function, given as a bitmap of indices of
rates in the band&#8217;s bitrate table.</p>
<dl class="function">
<dt id="c.ieee80211_hdrlen">
unsigned int __attribute_const__ <code class="descname">ieee80211_hdrlen</code><span class="sig-paren">(</span>__le16<em>&nbsp;fc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_hdrlen" title="Permalink to this definition">¶</a></dt>
<dd><p>get header length in bytes from frame control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__le16</span> <span class="pre">fc</span></code></dt>
<dd>frame control field in little-endian format</dd>
</dl>
<p><strong>Return</strong></p>
<p>The header length in bytes.</p>
<dl class="function">
<dt id="c.ieee80211_get_hdrlen_from_skb">
unsigned int <code class="descname">ieee80211_get_hdrlen_from_skb</code><span class="sig-paren">(</span>const struct sk_buff *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_hdrlen_from_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>get header length from data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the frame</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an skb with a raw 802.11 header at the data pointer this function
returns the 802.11 header length.</p>
<p><strong>Return</strong></p>
<p>The 802.11 header length in bytes (not including encryption
headers). Or 0 if the data in the sk_buff is too short to contain a valid
802.11 header.</p>
<dl class="type">
<dt id="c.ieee80211_radiotap_iterator">
struct <code class="descname">ieee80211_radiotap_iterator</code><a class="headerlink" href="#c.ieee80211_radiotap_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>tracks walk thru present radiotap args</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ieee80211_radiotap_iterator {
  struct ieee80211_radiotap_header * _rtheader;
  const struct ieee80211_radiotap_vendor_namespaces * _vns;
  const struct ieee80211_radiotap_namespace * current_namespace;
  unsigned char * _arg;
  unsigned char * _next_ns_data;
  __le32 * _next_bitmap;
  unsigned char * this_arg;
  int this_arg_index;
  int this_arg_size;
  int is_radiotap_ns;
  int _max_length;
  int _arg_index;
  uint32_t _bitmap_shifter;
  int _reset_on_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">_rtheader</span></code></dt>
<dd>pointer to the radiotap header we are walking through</dd>
<dt><code class="docutils literal"><span class="pre">_vns</span></code></dt>
<dd>vendor namespace definitions</dd>
<dt><code class="docutils literal"><span class="pre">current_namespace</span></code></dt>
<dd>pointer to the current namespace definition
(or internally <code class="docutils literal"><span class="pre">NULL</span></code> if the current namespace is unknown)</dd>
<dt><code class="docutils literal"><span class="pre">_arg</span></code></dt>
<dd>next argument pointer</dd>
<dt><code class="docutils literal"><span class="pre">_next_ns_data</span></code></dt>
<dd>beginning of the next namespace&#8217;s data</dd>
<dt><code class="docutils literal"><span class="pre">_next_bitmap</span></code></dt>
<dd>internal pointer to next present u32</dd>
<dt><code class="docutils literal"><span class="pre">this_arg</span></code></dt>
<dd>pointer to current radiotap arg; it is valid after each
call to <code class="xref c c-func docutils literal"><span class="pre">ieee80211_radiotap_iterator_next()</span></code> but also after
<code class="xref c c-func docutils literal"><span class="pre">ieee80211_radiotap_iterator_init()</span></code> where it will point to
the beginning of the actual data portion</dd>
<dt><code class="docutils literal"><span class="pre">this_arg_index</span></code></dt>
<dd>index of current arg, valid after each successful call
to <code class="xref c c-func docutils literal"><span class="pre">ieee80211_radiotap_iterator_next()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">this_arg_size</span></code></dt>
<dd>length of the current arg, for convenience</dd>
<dt><code class="docutils literal"><span class="pre">is_radiotap_ns</span></code></dt>
<dd>indicates whether the current namespace is the default
radiotap namespace or not</dd>
<dt><code class="docutils literal"><span class="pre">_max_length</span></code></dt>
<dd>length of radiotap header in cpu byte ordering</dd>
<dt><code class="docutils literal"><span class="pre">_arg_index</span></code></dt>
<dd>next argument index</dd>
<dt><code class="docutils literal"><span class="pre">_bitmap_shifter</span></code></dt>
<dd>internal shifter for curr u32 bitmap, b0 set == arg present</dd>
<dt><code class="docutils literal"><span class="pre">_reset_on_ext</span></code></dt>
<dd>internal; reset the arg index to 0 when going to the
next bitmap word</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes the radiotap parser state. Fields prefixed with an underscore
must not be used by users of the parser, only by the parser internally.</p>
</div>
<div class="section" id="data-path-helpers">
<h2>Data path helpers<a class="headerlink" href="#data-path-helpers" title="Permalink to this headline">¶</a></h2>
<p>In addition to generic utilities, cfg80211 also offers
functions that help implement the data path for devices
that do not do the 802.11/802.3 conversion on the device.</p>
<dl class="function">
<dt id="c.ieee80211_data_to_8023">
int <code class="descname">ieee80211_data_to_8023</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em>, const u8 *<em>&nbsp;addr</em>, enum nl80211_iftype<em>&nbsp;iftype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_data_to_8023" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an 802.11 data frame to 802.3</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the 802.11 data frame</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the device MAC address</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_iftype</span> <span class="pre">iftype</span></code></dt>
<dd>the virtual interface type</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success. Non-zero on error.</p>
<dl class="function">
<dt id="c.ieee80211_data_from_8023">
int <code class="descname">ieee80211_data_from_8023</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em>, const u8 *<em>&nbsp;addr</em>, enum nl80211_iftype<em>&nbsp;iftype</em>, const u8 *<em>&nbsp;bssid</em>, bool<em>&nbsp;qos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_data_from_8023" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an 802.3 frame to 802.11</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the 802.3 frame</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the device MAC address</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_iftype</span> <span class="pre">iftype</span></code></dt>
<dd>the virtual interface type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt>
<dd>the network bssid (used only for iftype STATION and ADHOC)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">qos</span></code></dt>
<dd>build 802.11 QoS data frame</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error code.</p>
<dl class="function">
<dt id="c.ieee80211_amsdu_to_8023s">
void <code class="descname">ieee80211_amsdu_to_8023s</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em>, struct sk_buff_head *<em>&nbsp;list</em>, const u8 *<em>&nbsp;addr</em>, enum nl80211_iftype<em>&nbsp;iftype</em>, const unsigned int<em>&nbsp;extra_headroom</em>, const u8 *<em>&nbsp;check_da</em>, const u8 *<em>&nbsp;check_sa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_amsdu_to_8023s" title="Permalink to this definition">¶</a></dt>
<dd><p>decode an IEEE 802.11n A-MSDU frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The input A-MSDU frame without any headers.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>The output list of 802.3 frames. It must be allocated and
initialized by by the caller.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The device MAC address.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">nl80211_iftype</span> <span class="pre">iftype</span></code></dt>
<dd>The device interface type.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">extra_headroom</span></code></dt>
<dd>The hardware extra headroom for SKBs in the <strong>list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">check_da</span></code></dt>
<dd>DA to check in the inner ethernet header, or NULL</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">check_sa</span></code></dt>
<dd>SA to check in the inner ethernet header, or NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
The <strong>list</strong> will be empty if the decode fails. The <strong>skb</strong> must be fully
header-less before being passed in here; it is freed in this function.</p>
<dl class="function">
<dt id="c.cfg80211_classify8021d">
unsigned int <code class="descname">cfg80211_classify8021d</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em>, struct cfg80211_qos_map *<em>&nbsp;qos_map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_classify8021d" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the 802.1p/1d tag for a data frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the data frame</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfg80211_qos_map</span> <span class="pre">*</span> <span class="pre">qos_map</span></code></dt>
<dd>Interworking QoS mapping or <code class="docutils literal"><span class="pre">NULL</span></code> if not in use</dd>
</dl>
<p><strong>Return</strong></p>
<p>The 802.1p/1d tag.</p>
</div>
<div class="section" id="regulatory-enforcement-infrastructure">
<h2>Regulatory enforcement infrastructure<a class="headerlink" href="#regulatory-enforcement-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<dl class="function">
<dt id="c.regulatory_hint">
int <code class="descname">regulatory_hint</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, const char *<em>&nbsp;alpha2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulatory_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>driver hint to the wireless core a regulatory domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wireless device giving the hint (used only for reporting
conflicts)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alpha2</span></code></dt>
<dd>the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
should be in. If <strong>rd</strong> is set this should be NULL. Note that if you
set this to NULL you should still set rd-&gt;alpha2 to some accepted
alpha2.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wireless drivers can use this function to hint to the wireless core
what it believes should be the current regulatory domain by
giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
domain should be in or by providing a completely build regulatory domain.
If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
for a regulatory domain structure for the respective country.</p>
<p>The wiphy must have been registered to cfg80211 prior to this call.
For cfg80211 drivers this means you must first use <a class="reference internal" href="#c.wiphy_register" title="wiphy_register"><code class="xref c c-func docutils literal"><span class="pre">wiphy_register()</span></code></a>,
for mac80211 drivers you must first use <a class="reference internal" href="mac80211.html#c.ieee80211_register_hw" title="ieee80211_register_hw"><code class="xref c c-func docutils literal"><span class="pre">ieee80211_register_hw()</span></code></a>.</p>
<p>Drivers should check the return value, its possible you can get
an -ENOMEM.</p>
<p><strong>Return</strong></p>
<p>0 on success. -ENOMEM.</p>
<dl class="function">
<dt id="c.wiphy_apply_custom_regulatory">
void <code class="descname">wiphy_apply_custom_regulatory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, const struct ieee80211_regdomain *<em>&nbsp;regd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_apply_custom_regulatory" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a custom driver regulatory domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wireless device we want to process the regulatory domain on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_regdomain</span> <span class="pre">*</span> <span class="pre">regd</span></code></dt>
<dd>the custom regulatory domain to use for this wiphy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can sometimes have custom regulatory domains which do not apply
to a specific country. Drivers can use this to apply such custom regulatory
domains. This routine must be called prior to wiphy registration. The
custom regulatory domain will be trusted completely and as such previous
default channel settings will be disregarded. If no rule is found for a
channel on the regulatory domain the channel will be disabled.
Drivers using this for a wiphy should also set the wiphy flag
REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
that called this helper.</p>
<dl class="function">
<dt id="c.freq_reg_info">
const struct ieee80211_reg_rule * <code class="descname">freq_reg_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, u32<em>&nbsp;center_freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freq_reg_info" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulatory information for the given frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy for which we want to process this rule for</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">center_freq</span></code></dt>
<dd>Frequency in KHz for which we want regulatory information for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to get the regulatory rule for a specific frequency on
a given wireless device. If the device has a specific regulatory domain
it wants to follow we respect that unless a country IE has been received
and processed already.</p>
<p><strong>Return</strong></p>
<p>A valid pointer, or, when an error occurs, for example if no rule
can be found, the return value is encoded using <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>. Use <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> to
check and <code class="xref c c-func docutils literal"><span class="pre">PTR_ERR()</span></code> to obtain the numeric return value. The numeric return
value will be -ERANGE if we determine the given center_freq does not even
have a regulatory rule for a frequency range in the center_freq&#8217;s band.
See <code class="xref c c-func docutils literal"><span class="pre">freq_in_rule_band()</span></code> for our current definition of a band &#8211; this is
purely subjective and right now it&#8217;s 802.11 specific.</p>
</div>
<div class="section" id="rfkill-integration">
<h2>RFkill integration<a class="headerlink" href="#rfkill-integration" title="Permalink to this headline">¶</a></h2>
<p>RFkill integration in cfg80211 is almost invisible to drivers,
as cfg80211 automatically registers an rfkill instance for each
wireless device it knows about. Soft kill is also translated
into disconnecting and turning all interfaces off, drivers are
expected to turn off the device when all interfaces are down.</p>
<p>However, devices may have a hard RFkill line, in which case they
also need to interact with the rfkill subsystem, via cfg80211.
They can do this with a few helper functions documented here.</p>
<dl class="function">
<dt id="c.wiphy_rfkill_set_hw_state">
void <code class="descname">wiphy_rfkill_set_hw_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, bool<em>&nbsp;blocked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_set_hw_state" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 about hw block state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">blocked</span></code></dt>
<dd>block status</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_rfkill_start_polling">
void <code class="descname">wiphy_rfkill_start_polling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_start_polling" title="Permalink to this definition">¶</a></dt>
<dd><p>start polling rfkill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_rfkill_stop_polling">
void <code class="descname">wiphy_rfkill_stop_polling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_stop_polling" title="Permalink to this definition">¶</a></dt>
<dd><p>stop polling rfkill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
</dl>
</div>
<div class="section" id="test-mode">
<h2>Test mode<a class="headerlink" href="#test-mode" title="Permalink to this headline">¶</a></h2>
<p>Test mode is a set of utility functions to allow drivers to
interact with driver-specific tools to aid, for instance,
factory programming.</p>
<p>This chapter describes how drivers interact with it, for more
information see the nl80211 book&#8217;s chapter on it.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_alloc_reply_skb">
struct sk_buff * <code class="descname">cfg80211_testmode_alloc_reply_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, int<em>&nbsp;approxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_alloc_reply_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate testmode reply</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">approxlen</span></code></dt>
<dd>an upper bound of the length of the data that will
be put into the skb</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and pre-fills an skb for a reply to
the testmode command. Since it is intended for a reply, calling
it outside of the <strong>testmode_cmd</strong> operation is invalid.</p>
<p>The returned skb is pre-filled with the wiphy index and set up in
a way that any data that is put into the skb (with <code class="xref c c-func docutils literal"><span class="pre">skb_put()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">nla_put()</span></code> or similar) will end up being within the
<code class="docutils literal"><span class="pre">NL80211_ATTR_TESTDATA</span></code> attribute, so all that needs to be done
with the skb is adding data for the corresponding userspace tool
which can then read that data out of the testdata attribute. You
must not modify the skb in any other way.</p>
<p>When done, call <a class="reference internal" href="#c.cfg80211_testmode_reply" title="cfg80211_testmode_reply"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_reply()</span></code></a> with the skb and return
its error code as the result of the <strong>testmode_cmd</strong> operation.</p>
<p><strong>Return</strong></p>
<p>An allocated and pre-filled skb. <code class="docutils literal"><span class="pre">NULL</span></code> if any errors happen.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_reply">
int <code class="descname">cfg80211_testmode_reply</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_reply" title="Permalink to this definition">¶</a></dt>
<dd><p>send the reply skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The skb, must have been allocated with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_reply_skb" title="cfg80211_testmode_alloc_reply_skb"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_alloc_reply_skb()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Since calling this function will usually be the last thing
before returning from the <strong>testmode_cmd</strong> you should return
the error code.  Note that this function consumes the skb
regardless of the return value.</p>
<p><strong>Return</strong></p>
<p>An error code or 0 on success.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_alloc_event_skb">
struct sk_buff * <code class="descname">cfg80211_testmode_alloc_event_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em>&nbsp;wiphy</em>, int<em>&nbsp;approxlen</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_alloc_event_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate testmode event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt>
<dd>the wiphy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">approxlen</span></code></dt>
<dd>an upper bound of the length of the data that will
be put into the skb</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and pre-fills an skb for an event on the
testmode multicast group.</p>
<p>The returned skb is set up in the same way as with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_reply_skb" title="cfg80211_testmode_alloc_reply_skb"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_alloc_reply_skb()</span></code></a> but prepared for an event. As
there, you should simply add data to it that will then end up in the
<code class="docutils literal"><span class="pre">NL80211_ATTR_TESTDATA</span></code> attribute. Again, you must not modify the skb
in any other way.</p>
<p>When done filling the skb, call <a class="reference internal" href="#c.cfg80211_testmode_event" title="cfg80211_testmode_event"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_event()</span></code></a> with the
skb to send the event.</p>
<p><strong>Return</strong></p>
<p>An allocated and pre-filled skb. <code class="docutils literal"><span class="pre">NULL</span></code> if any errors happen.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_event">
void <code class="descname">cfg80211_testmode_event</code><span class="sig-paren">(</span>struct sk_buff *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send the event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The skb, must have been allocated with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_event_skb" title="cfg80211_testmode_alloc_event_skb"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_alloc_event_skb()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends the given <strong>skb</strong>, which must have been allocated
by <a class="reference internal" href="#c.cfg80211_testmode_alloc_event_skb" title="cfg80211_testmode_alloc_event_skb"><code class="xref c c-func docutils literal"><span class="pre">cfg80211_testmode_alloc_event_skb()</span></code></a>, as an event. It always
consumes it.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mac80211.html" class="btn btn-neutral float-right" title="mac80211 subsystem (basics)" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral" title="Introduction" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.10.0-rc8+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>