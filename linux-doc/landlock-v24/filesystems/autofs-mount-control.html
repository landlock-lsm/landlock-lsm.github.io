

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Miscellaneous Device control operations for the autofs kernel module &mdash; The Linux Kernel 5.10.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="BeOS filesystem for Linux" href="befs.html" />
    <link rel="prev" title="autofs - how it works" href="autofs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystems">Filesystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="9p.html">v9fs: Plan 9 Resource Sharing for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="adfs.html">Acorn Disc Filing System - ADFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="affs.html">Overview of Amiga Filesystems</a></li>
<li class="toctree-l3"><a class="reference internal" href="afs.html">kAFS: AFS FILESYSTEM</a></li>
<li class="toctree-l3"><a class="reference internal" href="autofs.html">autofs - how it works</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Miscellaneous Device control operations for the autofs kernel module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-problem">The problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-solution">The Solution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#autofs-miscellaneous-device-mount-control-interface">autofs Miscellaneous Device mount control interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-ioctls">The ioctls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="befs.html">BeOS filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="bfs.html">BFS Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="btrfs.html">BTRFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="cifs/cifsroot.html">Mounting root file system via SMB (cifs.ko)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ceph.html">Ceph Distributed File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="coda.html">Coda Kernel-Venus Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="configfs.html">Configfs - Userspace-driven Kernel Object Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="cramfs.html">Cramfs - cram a filesystem onto a small ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugfs.html">DebugFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="dlmfs.html">DLMFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ecryptfs.html">eCryptfs: A stacked cryptographic filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="efivarfs.html">efivarfs - a (U)EFI variable filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="erofs.html">Enhanced Read-Only File System - EROFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext2.html">The Second Extended Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext2.html#options">Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext2.html#specification">Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext2.html#references">References</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext3.html">Ext3 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="f2fs.html">WHAT IS Flash-Friendly File System (F2FS)?</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2.html">Global File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2-uevents.html">uevents and GFS2</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2-glocks.html">Glock internal locking rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hfs.html">Macintosh HFS Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="hfsplus.html">Macintosh HFSPlus Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="hpfs.html">Read/Write HPFS 2.09</a></li>
<li class="toctree-l3"><a class="reference internal" href="fuse.html">FUSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="fuse-io.html">Fuse I/O Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="inotify.html">Inotify - A Powerful yet Simple File Change Notification System</a></li>
<li class="toctree-l3"><a class="reference internal" href="isofs.html">ISO9660 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="nilfs2.html">NILFS2</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfs/index.html">NFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntfs.html">The Linux NTFS filesystem driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="ocfs2.html">OCFS2 filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ocfs2-online-filecheck.html">OCFS2 file system - online file check</a></li>
<li class="toctree-l3"><a class="reference internal" href="omfs.html">Optimized MPEG Filesystem (OMFS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="orangefs.html">ORANGEFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="overlayfs.html">Overlay Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="proc.html">The /proc Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="qnx6.html">The QNX6 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ramfs-rootfs-initramfs.html">Ramfs, rootfs and initramfs</a></li>
<li class="toctree-l3"><a class="reference internal" href="relay.html">relay interface (formerly relayfs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="romfs.html">ROMFS - ROM File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="spufs/index.html">SPU Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="squashfs.html">Squashfs 4.0 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="sysfs.html">sysfs - _The_ filesystem for exporting kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="sysv-fs.html">SystemV Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="tmpfs.html">Tmpfs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ubifs.html">UBI File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="ubifs-authentication.html">UBIFS Authentication Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="udf.html">UDF file system</a></li>
<li class="toctree-l3"><a class="reference internal" href="virtiofs.html">virtiofs: virtio-fs host&lt;-&gt;guest shared file system</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfat.html">VFAT</a></li>
<li class="toctree-l3"><a class="reference internal" href="xfs-delayed-logging-design.html">XFS Delayed Logging Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="xfs-self-describing-metadata.html">XFS Self Describing Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="zonefs.html">ZoneFS - Zone filesystem for Zoned block devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>Miscellaneous Device control operations for the autofs kernel module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/autofs-mount-control.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="miscellaneous-device-control-operations-for-the-autofs-kernel-module">
<h1>Miscellaneous Device control operations for the autofs kernel module<a class="headerlink" href="#miscellaneous-device-control-operations-for-the-autofs-kernel-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-problem">
<h2>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h2>
<p>There is a problem with active restarts in autofs (that is to say
restarting autofs when there are busy mounts).</p>
<p>During normal operation autofs uses a file descriptor opened on the
directory that is being managed in order to be able to issue control
operations. Using a file descriptor gives ioctl operations access to
autofs specific information stored in the super block. The operations
are things such as setting an autofs mount catatonic, setting the
expire timeout and requesting expire checks. As is explained below,
certain types of autofs triggered mounts can end up covering an autofs
mount itself which prevents us being able to use open(2) to obtain a
file descriptor for these operations if we don’t already have one open.</p>
<p>Currently autofs uses “umount -l” (lazy umount) to clear active mounts
at restart. While using lazy umount works for most cases, anything that
needs to walk back up the mount tree to construct a path, such as
getcwd(2) and the proc file system /proc/&lt;pid&gt;/cwd, no longer works
because the point from which the path is constructed has been detached
from the mount tree.</p>
<p>The actual problem with autofs is that it can’t reconnect to existing
mounts. Immediately one thinks of just adding the ability to remount
autofs file systems would solve it, but alas, that can’t work. This is
because autofs direct mounts and the implementation of “on demand mount
and expire” of nested mount trees have the file system mounted directly
on top of the mount trigger directory dentry.</p>
<p>For example, there are two types of automount maps, direct (in the kernel
module source you will see a third type called an offset, which is just
a direct mount in disguise) and indirect.</p>
<p>Here is a master map with direct and indirect map entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/-      /etc/auto.direct
/test   /etc/auto.indirect
</pre></div>
</div>
<p>and the corresponding map files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/etc/auto.direct:

/automount/dparse/g6  budgie:/autofs/export1
/automount/dparse/g1  shark:/autofs/export1
and so on.
</pre></div>
</div>
<p>/etc/auto.indirect:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>g1    shark:/autofs/export1
g6    budgie:/autofs/export1
and so on.
</pre></div>
</div>
<p>For the above indirect map an autofs file system is mounted on /test and
mounts are triggered for each sub-directory key by the inode lookup
operation. So we see a mount of shark:/autofs/export1 on /test/g1, for
example.</p>
<p>The way that direct mounts are handled is by making an autofs mount on
each full path, such as /automount/dparse/g1, and using it as a mount
trigger. So when we walk on the path we mount shark:/autofs/export1 “on
top of this mount point”. Since these are always directories we can
use the follow_link inode operation to trigger the mount.</p>
<p>But, each entry in direct and indirect maps can have offsets (making
them multi-mount map entries).</p>
<p>For example, an indirect mount map entry could also be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>g1  \
/        shark:/autofs/export5/testing/test \
/s1      shark:/autofs/export/testing/test/s1 \
/s2      shark:/autofs/export5/testing/test/s2 \
/s1/ss1  shark:/autofs/export1 \
/s2/ss2  shark:/autofs/export2
</pre></div>
</div>
<p>and a similarly a direct mount map entry could also be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/automount/dparse/g1 \
    /       shark:/autofs/export5/testing/test \
    /s1     shark:/autofs/export/testing/test/s1 \
    /s2     shark:/autofs/export5/testing/test/s2 \
    /s1/ss1 shark:/autofs/export2 \
    /s2/ss2 shark:/autofs/export2
</pre></div>
</div>
<p>One of the issues with version 4 of autofs was that, when mounting an
entry with a large number of offsets, possibly with nesting, we needed
to mount and umount all of the offsets as a single unit. Not really a
problem, except for people with a large number of offsets in map entries.
This mechanism is used for the well known “hosts” map and we have seen
cases (in 2.4) where the available number of mounts are exhausted or
where the number of privileged ports available is exhausted.</p>
<p>In version 5 we mount only as we go down the tree of offsets and
similarly for expiring them which resolves the above problem. There is
somewhat more detail to the implementation but it isn’t needed for the
sake of the problem explanation. The one important detail is that these
offsets are implemented using the same mechanism as the direct mounts
above and so the mount points can be covered by a mount.</p>
<p>The current autofs implementation uses an ioctl file descriptor opened
on the mount point for control operations. The references held by the
descriptor are accounted for in checks made to determine if a mount is
in use and is also used to access autofs file system information held
in the mount super block. So the use of a file handle needs to be
retained.</p>
</div>
<div class="section" id="the-solution">
<h2>The Solution<a class="headerlink" href="#the-solution" title="Permalink to this headline">¶</a></h2>
<p>To be able to restart autofs leaving existing direct, indirect and
offset mounts in place we need to be able to obtain a file handle
for these potentially covered autofs mount points. Rather than just
implement an isolated operation it was decided to re-implement the
existing ioctl interface and add new operations to provide this
functionality.</p>
<p>In addition, to be able to reconstruct a mount tree that has busy mounts,
the uid and gid of the last user that triggered the mount needs to be
available because these can be used as macro substitution variables in
autofs maps. They are recorded at mount request time and an operation
has been added to retrieve them.</p>
<p>Since we’re re-implementing the control interface, a couple of other
problems with the existing interface have been addressed. First, when
a mount or expire operation completes a status is returned to the
kernel by either a “send ready” or a “send fail” operation. The
“send fail” operation of the ioctl interface could only ever send
ENOENT so the re-implementation allows user space to send an actual
status. Another expensive operation in user space, for those using
very large maps, is discovering if a mount is present. Usually this
involves scanning /proc/mounts and since it needs to be done quite
often it can introduce significant overhead when there are many entries
in the mount table. An operation to lookup the mount status of a mount
point dentry (covered or not) has also been added.</p>
<p>Current kernel development policy recommends avoiding the use of the
ioctl mechanism in favor of systems such as Netlink. An implementation
using this system was attempted to evaluate its suitability and it was
found to be inadequate, in this case. The Generic Netlink system was
used for this as raw Netlink would lead to a significant increase in
complexity. There’s no question that the Generic Netlink system is an
elegant solution for common case ioctl functions but it’s not a complete
replacement probably because its primary purpose in life is to be a
message bus implementation rather than specifically an ioctl replacement.
While it would be possible to work around this there is one concern
that lead to the decision to not use it. This is that the autofs
expire in the daemon has become far to complex because umount
candidates are enumerated, almost for no other reason than to “count”
the number of times to call the expire ioctl. This involves scanning
the mount table which has proved to be a big overhead for users with
large maps. The best way to improve this is try and get back to the
way the expire was done long ago. That is, when an expire request is
issued for a mount (file handle) we should continually call back to
the daemon until we can’t umount any more mounts, then return the
appropriate status to the daemon. At the moment we just expire one
mount at a time. A Generic Netlink implementation would exclude this
possibility for future development due to the requirements of the
message bus architecture.</p>
</div>
<div class="section" id="autofs-miscellaneous-device-mount-control-interface">
<h2>autofs Miscellaneous Device mount control interface<a class="headerlink" href="#autofs-miscellaneous-device-mount-control-interface" title="Permalink to this headline">¶</a></h2>
<p>The control interface is opening a device node, typically /dev/autofs.</p>
<p>All the ioctls use a common structure to pass the needed parameter
information and return operation results:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct autofs_dev_ioctl {
        __u32 ver_major;
        __u32 ver_minor;
        __u32 size;             /* total size of data passed in
                                * including this struct */
        __s32 ioctlfd;          /* automount command fd */

        /* Command parameters */
        union {
                struct args_protover                protover;
                struct args_protosubver             protosubver;
                struct args_openmount               openmount;
                struct args_ready           ready;
                struct args_fail            fail;
                struct args_setpipefd               setpipefd;
                struct args_timeout         timeout;
                struct args_requester               requester;
                struct args_expire          expire;
                struct args_askumount               askumount;
                struct args_ismountpoint    ismountpoint;
        };

        char path[0];
};
</pre></div>
</div>
<p>The ioctlfd field is a mount point file descriptor of an autofs mount
point. It is returned by the open call and is used by all calls except
the check for whether a given path is a mount point, where it may
optionally be used to check a specific mount corresponding to a given
mount point file descriptor, and when requesting the uid and gid of the
last successful mount on a directory within the autofs file system.</p>
<p>The union is used to communicate parameters and results of calls made
as described below.</p>
<p>The path field is used to pass a path where it is needed and the size field
is used account for the increased structure length when translating the
structure sent from user space.</p>
<p>This structure can be initialized before setting specific fields by using
the void function call init_autofs_dev_ioctl(<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">autofs_dev_ioctl</span> <span class="pre">*</span></code>).</p>
<p>All of the ioctls perform a copy of this structure from user space to
kernel space and return -EINVAL if the size parameter is smaller than
the structure size itself, -ENOMEM if the kernel memory allocation fails
or -EFAULT if the copy itself fails. Other checks include a version check
of the compiled in user space version against the module version and a
mismatch results in a -EINVAL return. If the size field is greater than
the structure size then a path is assumed to be present and is checked to
ensure it begins with a “/” and is NULL terminated, otherwise -EINVAL is
returned. Following these checks, for all ioctl commands except
AUTOFS_DEV_IOCTL_VERSION_CMD, AUTOFS_DEV_IOCTL_OPENMOUNT_CMD and
AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD the ioctlfd is validated and if it is
not a valid descriptor or doesn’t correspond to an autofs mount point
an error of -EBADF, -ENOTTY or -EINVAL (not an autofs descriptor) is
returned.</p>
</div>
<div class="section" id="the-ioctls">
<h2>The ioctls<a class="headerlink" href="#the-ioctls" title="Permalink to this headline">¶</a></h2>
<p>An example of an implementation which uses this interface can be seen
in autofs version 5.0.4 and later in file lib/dev-ioctl-lib.c of the
distribution tar available for download from kernel.org in directory
/pub/linux/daemons/autofs/v5.</p>
<p>The device node ioctl operations implemented by this interface are:</p>
<div class="section" id="autofs-dev-ioctl-version">
<h3>AUTOFS_DEV_IOCTL_VERSION<a class="headerlink" href="#autofs-dev-ioctl-version" title="Permalink to this headline">¶</a></h3>
<p>Get the major and minor version of the autofs device ioctl kernel module
implementation. It requires an initialized struct autofs_dev_ioctl as an
input parameter and sets the version information in the passed in structure.
It returns 0 on success or the error -EINVAL if a version mismatch is
detected.</p>
</div>
<div class="section" id="autofs-dev-ioctl-protover-cmd-and-autofs-dev-ioctl-protosubver-cmd">
<h3>AUTOFS_DEV_IOCTL_PROTOVER_CMD and AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD<a class="headerlink" href="#autofs-dev-ioctl-protover-cmd-and-autofs-dev-ioctl-protosubver-cmd" title="Permalink to this headline">¶</a></h3>
<p>Get the major and minor version of the autofs protocol version understood
by loaded module. This call requires an initialized struct autofs_dev_ioctl
with the ioctlfd field set to a valid autofs mount point descriptor
and sets the requested version number in version field of struct args_protover
or sub_version field of struct args_protosubver. These commands return
0 on success or one of the negative error codes if validation fails.</p>
</div>
<div class="section" id="autofs-dev-ioctl-openmount-and-autofs-dev-ioctl-closemount">
<h3>AUTOFS_DEV_IOCTL_OPENMOUNT and AUTOFS_DEV_IOCTL_CLOSEMOUNT<a class="headerlink" href="#autofs-dev-ioctl-openmount-and-autofs-dev-ioctl-closemount" title="Permalink to this headline">¶</a></h3>
<p>Obtain and release a file descriptor for an autofs managed mount point
path. The open call requires an initialized struct autofs_dev_ioctl with
the path field set and the size field adjusted appropriately as well
as the devid field of struct args_openmount set to the device number of
the autofs mount. The device number can be obtained from the mount options
shown in /proc/mounts. The close call requires an initialized struct
autofs_dev_ioct with the ioctlfd field set to the descriptor obtained
from the open call. The release of the file descriptor can also be done
with close(2) so any open descriptors will also be closed at process exit.
The close call is included in the implemented operations largely for
completeness and to provide for a consistent user space implementation.</p>
</div>
<div class="section" id="autofs-dev-ioctl-ready-cmd-and-autofs-dev-ioctl-fail-cmd">
<h3>AUTOFS_DEV_IOCTL_READY_CMD and AUTOFS_DEV_IOCTL_FAIL_CMD<a class="headerlink" href="#autofs-dev-ioctl-ready-cmd-and-autofs-dev-ioctl-fail-cmd" title="Permalink to this headline">¶</a></h3>
<p>Return mount and expire result status from user space to the kernel.
Both of these calls require an initialized struct autofs_dev_ioctl
with the ioctlfd field set to the descriptor obtained from the open
call and the token field of struct args_ready or struct args_fail set
to the wait queue token number, received by user space in the foregoing
mount or expire request. The status field of struct args_fail is set to
the errno of the operation. It is set to 0 on success.</p>
</div>
<div class="section" id="autofs-dev-ioctl-setpipefd-cmd">
<h3>AUTOFS_DEV_IOCTL_SETPIPEFD_CMD<a class="headerlink" href="#autofs-dev-ioctl-setpipefd-cmd" title="Permalink to this headline">¶</a></h3>
<p>Set the pipe file descriptor used for kernel communication to the daemon.
Normally this is set at mount time using an option but when reconnecting
to a existing mount we need to use this to tell the autofs mount about
the new kernel pipe descriptor. In order to protect mounts against
incorrectly setting the pipe descriptor we also require that the autofs
mount be catatonic (see next call).</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the
ioctlfd field set to the descriptor obtained from the open call and
the pipefd field of struct args_setpipefd set to descriptor of the pipe.
On success the call also sets the process group id used to identify the
controlling process (eg. the owning automount(8) daemon) to the process
group of the caller.</p>
</div>
<div class="section" id="autofs-dev-ioctl-catatonic-cmd">
<h3>AUTOFS_DEV_IOCTL_CATATONIC_CMD<a class="headerlink" href="#autofs-dev-ioctl-catatonic-cmd" title="Permalink to this headline">¶</a></h3>
<p>Make the autofs mount point catatonic. The autofs mount will no longer
issue mount requests, the kernel communication pipe descriptor is released
and any remaining waits in the queue released.</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the
ioctlfd field set to the descriptor obtained from the open call.</p>
</div>
<div class="section" id="autofs-dev-ioctl-timeout-cmd">
<h3>AUTOFS_DEV_IOCTL_TIMEOUT_CMD<a class="headerlink" href="#autofs-dev-ioctl-timeout-cmd" title="Permalink to this headline">¶</a></h3>
<p>Set the expire timeout for mounts within an autofs mount point.</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the
ioctlfd field set to the descriptor obtained from the open call.</p>
</div>
<div class="section" id="autofs-dev-ioctl-requester-cmd">
<h3>AUTOFS_DEV_IOCTL_REQUESTER_CMD<a class="headerlink" href="#autofs-dev-ioctl-requester-cmd" title="Permalink to this headline">¶</a></h3>
<p>Return the uid and gid of the last process to successfully trigger a the
mount on the given path dentry.</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the path
field set to the mount point in question and the size field adjusted
appropriately. Upon return the uid field of struct args_requester contains
the uid and gid field the gid.</p>
<p>When reconstructing an autofs mount tree with active mounts we need to
re-connect to mounts that may have used the original process uid and
gid (or string variations of them) for mount lookups within the map entry.
This call provides the ability to obtain this uid and gid so they may be
used by user space for the mount map lookups.</p>
</div>
<div class="section" id="autofs-dev-ioctl-expire-cmd">
<h3>AUTOFS_DEV_IOCTL_EXPIRE_CMD<a class="headerlink" href="#autofs-dev-ioctl-expire-cmd" title="Permalink to this headline">¶</a></h3>
<p>Issue an expire request to the kernel for an autofs mount. Typically
this ioctl is called until no further expire candidates are found.</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the
ioctlfd field set to the descriptor obtained from the open call. In
addition an immediate expire that’s independent of the mount timeout,
and a forced expire that’s independent of whether the mount is busy,
can be requested by setting the how field of struct args_expire to
AUTOFS_EXP_IMMEDIATE or AUTOFS_EXP_FORCED, respectively . If no
expire candidates can be found the ioctl returns -1 with errno set to
EAGAIN.</p>
<p>This call causes the kernel module to check the mount corresponding
to the given ioctlfd for mounts that can be expired, issues an expire
request back to the daemon and waits for completion.</p>
</div>
<div class="section" id="autofs-dev-ioctl-askumount-cmd">
<h3>AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD<a class="headerlink" href="#autofs-dev-ioctl-askumount-cmd" title="Permalink to this headline">¶</a></h3>
<p>Checks if an autofs mount point is in use.</p>
<p>The call requires an initialized struct autofs_dev_ioctl with the
ioctlfd field set to the descriptor obtained from the open call and
it returns the result in the may_umount field of struct args_askumount,
1 for busy and 0 otherwise.</p>
</div>
<div class="section" id="autofs-dev-ioctl-ismountpoint-cmd">
<h3>AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD<a class="headerlink" href="#autofs-dev-ioctl-ismountpoint-cmd" title="Permalink to this headline">¶</a></h3>
<p>Check if the given path is a mountpoint.</p>
<p>The call requires an initialized struct autofs_dev_ioctl. There are two
possible variations. Both use the path field set to the path of the mount
point to check and the size field adjusted appropriately. One uses the
ioctlfd field to identify a specific mount point to check while the other
variation uses the path and optionally in.type field of struct args_ismountpoint
set to an autofs mount type. The call returns 1 if this is a mount point
and sets out.devid field to the device number of the mount and out.magic
field to the relevant super block magic number (described below) or 0 if
it isn’t a mountpoint. In both cases the device number (as returned
by new_encode_dev()) is returned in out.devid field.</p>
<p>If supplied with a file descriptor we’re looking for a specific mount,
not necessarily at the top of the mounted stack. In this case the path
the descriptor corresponds to is considered a mountpoint if it is itself
a mountpoint or contains a mount, such as a multi-mount without a root
mount. In this case we return 1 if the descriptor corresponds to a mount
point and also returns the super magic of the covering mount if there
is one or 0 if it isn’t a mountpoint.</p>
<p>If a path is supplied (and the ioctlfd field is set to -1) then the path
is looked up and is checked to see if it is the root of a mount. If a
type is also given we are looking for a particular autofs mount and if
a match isn’t found a fail is returned. If the located path is the
root of a mount 1 is returned along with the super magic of the mount
or 0 otherwise.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="befs.html" class="btn btn-neutral float-right" title="BeOS filesystem for Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="autofs.html" class="btn btn-neutral float-left" title="autofs - how it works" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>