

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.5.1. Memory-to-Memory Stateful Video Decoder Interface &mdash; The Linux Kernel 5.10.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="4.5.2. Memory-to-Memory Stateful Video Encoder Interface" href="dev-encoder.html" />
    <link rel="prev" title="4.5. Video Memory-To-Memory Interface" href="dev-mem2mem.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">The Linux kernel user-space API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../no_new_privs.html">No New Privileges Flag</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../seccomp_filter.html">Seccomp BPF (SECure COMPuting with filters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../landlock.html">Landlock: unprivileged access control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../unshare.html">unshare system call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../spec_ctrl.html">Speculation Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../accelerators/ocxl.html">OpenCAPI (Open Coherent Accelerator Processor Interface)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ioctl/index.html">IOCTLs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iommu.html">IOMMU Userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Linux Media Infrastructure userspace API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="v4l2.html">Part I - Video for Linux API</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="common.html">1. Common API Elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="pixfmt.html">2. Image Formats</a></li>
<li class="toctree-l4"><a class="reference internal" href="io.html">3. Input/Output</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="devices.html">4. Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="libv4l.html">5. Libv4l Userspace Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="compat.html">6. Changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="user-func.html">7. Function Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="common-defs.html">8. Common definitions for V4L2 and V4L2 subdev interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="videodev.html">9. Video For Linux Two Header File</a></li>
<li class="toctree-l4"><a class="reference internal" href="capture-example.html">10. Video Capture Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2grab-example.html">11. Video Grabber example using libv4l</a></li>
<li class="toctree-l4"><a class="reference internal" href="biblio.html">12. References</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-and-copyright">Revision and Copyright</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-history">Revision History</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dvb/dvbapi.html">Part II - Digital TV API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rc/remote_controllers.html">Part III - Remote Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mediactl/media-controller.html">Part IV - Media Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cec/cec-api.html">Part V - Consumer Electronics Control API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gen-errors.html">Generic Error Codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fdl-appendix.html">GNU Free Documentation License</a></li>
<li class="toctree-l3"><a class="reference internal" href="../drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">The Linux kernel user-space API guide</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Infrastructure userspace API</a> &raquo;</li>
        
          <li><a href="v4l2.html">Part I - Video for Linux API</a> &raquo;</li>
        
          <li><a href="devices.html"><span class="section-number">4. </span>Interfaces</a> &raquo;</li>
        
          <li><a href="dev-mem2mem.html"><span class="section-number">4.5. </span>Video Memory-To-Memory Interface</a> &raquo;</li>
        
      <li><span class="section-number">4.5.1. </span>Memory-to-Memory Stateful Video Decoder Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/userspace-api/media/v4l/dev-decoder.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-to-memory-stateful-video-decoder-interface">
<span id="decoder"></span><h1><span class="section-number">4.5.1. </span>Memory-to-Memory Stateful Video Decoder Interface<a class="headerlink" href="#memory-to-memory-stateful-video-decoder-interface" title="Permalink to this headline">¶</a></h1>
<p>A stateful video decoder takes complete chunks of the bytestream (e.g. Annex-B
H.264/HEVC stream, raw VP8/9 stream) and decodes them into raw video frames in
display order. The decoder is expected not to require any additional information
from the client to process these buffers.</p>
<p>Performing software parsing, processing etc. of the stream in the driver in
order to support this interface is strongly discouraged. In case such
operations are needed, use of the Stateless Video Decoder Interface (in
development) is strongly advised.</p>
<div class="section" id="conventions-and-notations-used-in-this-document">
<h2><span class="section-number">4.5.1.1. </span>Conventions and Notations Used in This Document<a class="headerlink" href="#conventions-and-notations-used-in-this-document" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>The general V4L2 API rules apply if not specified in this document
otherwise.</p></li>
<li><p>The meaning of words “must”, “may”, “should”, etc. is as per <a class="reference external" href="https://tools.ietf.org/html/rfc2119">RFC
2119</a>.</p></li>
<li><p>All steps not marked “optional” are required.</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_EXT_CTRLS()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_EXT_CTRLS()</span></code> may be used
interchangeably with <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_CTRL()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_CTRL()</span></code>,
unless specified otherwise.</p></li>
<li><p>Single-planar API (see <a class="reference internal" href="planar-apis.html#planar-apis"><span class="std std-ref">Single- and multi-planar APIs</span></a>) and applicable structures may be
used interchangeably with multi-planar API, unless specified otherwise,
depending on decoder capabilities and following the general V4L2 guidelines.</p></li>
<li><p>i = [a..b]: sequence of integers from a to b, inclusive, i.e. i =
[0..2]: i = 0, 1, 2.</p></li>
<li><p>Given an <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer A, then A’ represents a buffer on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queue containing data that resulted from processing buffer A.</p></li>
</ol>
</div>
<div class="section" id="glossary">
<span id="decoder-glossary"></span><h2><span class="section-number">4.5.1.2. </span>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>CAPTURE</dt><dd><p>the destination buffer queue; for decoders, the queue of buffers containing
decoded frames; for encoders, the queue of buffers containing an encoded
bytestream; <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code> or
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span></code>; data is captured from the hardware
into <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers.</p>
</dd>
<dt>client</dt><dd><p>the application communicating with the decoder or encoder implementing
this interface.</p>
</dd>
<dt>coded format</dt><dd><p>encoded/compressed video bytestream format (e.g. H.264, VP8, etc.); see
also: raw format.</p>
</dd>
<dt>coded height</dt><dd><p>height for given coded resolution.</p>
</dd>
<dt>coded resolution</dt><dd><p>stream resolution in pixels aligned to codec and hardware requirements;
typically visible resolution rounded up to full macroblocks;
see also: visible resolution.</p>
</dd>
<dt>coded width</dt><dd><p>width for given coded resolution.</p>
</dd>
<dt>decode order</dt><dd><p>the order in which frames are decoded; may differ from display order if the
coded format includes a feature of frame reordering; for decoders,
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers must be queued by the client in decode order; for
encoders <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers must be returned by the encoder in decode order.</p>
</dd>
<dt>destination</dt><dd><p>data resulting from the decode process; see <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt>display order</dt><dd><p>the order in which frames must be displayed; for encoders, <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
buffers must be queued by the client in display order; for decoders,
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers must be returned by the decoder in display order.</p>
</dd>
<dt>DPB</dt><dd><p>Decoded Picture Buffer; an H.264/HEVC term for a buffer that stores a decoded
raw frame available for reference in further decoding steps.</p>
</dd>
<dt>EOS</dt><dd><p>end of stream.</p>
</dd>
<dt>IDR</dt><dd><p>Instantaneous Decoder Refresh; a type of a keyframe in an H.264/HEVC-encoded
stream, which clears the list of earlier reference frames (DPBs).</p>
</dd>
<dt>keyframe</dt><dd><p>an encoded frame that does not reference frames decoded earlier, i.e.
can be decoded fully on its own.</p>
</dd>
<dt>macroblock</dt><dd><p>a processing unit in image and video compression formats based on linear
block transforms (e.g. H.264, VP8, VP9); codec-specific, but for most of
popular codecs the size is 16x16 samples (pixels).</p>
</dd>
<dt>OUTPUT</dt><dd><p>the source buffer queue; for decoders, the queue of buffers containing
an encoded bytestream; for encoders, the queue of buffers containing raw
frames; <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT</span></code> or
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span></code>; the hardware is fed with data
from <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers.</p>
</dd>
<dt>PPS</dt><dd><p>Picture Parameter Set; a type of metadata entity in an H.264/HEVC bytestream.</p>
</dd>
<dt>raw format</dt><dd><p>uncompressed format containing raw pixel data (e.g. YUV, RGB formats).</p>
</dd>
<dt>resume point</dt><dd><p>a point in the bytestream from which decoding may start/continue, without
any previous state/data present, e.g.: a keyframe (VP8/VP9) or
SPS/PPS/IDR sequence (H.264/HEVC); a resume point is required to start decode
of a new stream, or to resume decoding after a seek.</p>
</dd>
<dt>source</dt><dd><p>data fed to the decoder or encoder; see <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt>source height</dt><dd><p>height in pixels for given source resolution; relevant to encoders only.</p>
</dd>
<dt>source resolution</dt><dd><p>resolution in pixels of source frames being source to the encoder and
subject to further cropping to the bounds of visible resolution; relevant to
encoders only.</p>
</dd>
<dt>source width</dt><dd><p>width in pixels for given source resolution; relevant to encoders only.</p>
</dd>
<dt>SPS</dt><dd><p>Sequence Parameter Set; a type of metadata entity in an H.264/HEVC bytestream.</p>
</dd>
<dt>stream metadata</dt><dd><p>additional (non-visual) information contained inside encoded bytestream;
for example: coded resolution, visible resolution, codec profile.</p>
</dd>
<dt>visible height</dt><dd><p>height for given visible resolution; display height.</p>
</dd>
<dt>visible resolution</dt><dd><p>stream resolution of the visible picture, in pixels, to be used for
display purposes; must be smaller or equal to coded resolution;
display resolution.</p>
</dd>
<dt>visible width</dt><dd><p>width for given visible resolution; display width.</p>
</dd>
</dl>
</div>
<div class="section" id="state-machine">
<h2><span class="section-number">4.5.1.3. </span>State Machine<a class="headerlink" href="#state-machine" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id1">
<img alt="DOT digraph of decoder state machine" src="../../../_images/DOT-9dfb8f675068225f506cf3516ade69755c77b031.svg" /><p class="caption"><span class="caption-text">Decoder State Machine</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="querying-capabilities">
<h2><span class="section-number">4.5.1.4. </span>Querying Capabilities<a class="headerlink" href="#querying-capabilities" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>To enumerate the set of coded formats supported by the decoder, the
client may call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
<ul class="simple">
<li><p>The full set of supported formats will be returned, regardless of the
format set on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p></li>
<li><p>Check the flags field of <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_fmtdesc</span></code> for more information
about the decoder’s capabilities with respect to each coded format.
In particular whether or not the decoder has a full-fledged bytestream
parser and if the decoder supports dynamic resolution changes.</p></li>
</ul>
</li>
<li><p>To enumerate the set of supported raw formats, the client may call
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
<ul class="simple">
<li><p>Only the formats supported for the format currently active on <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
will be returned.</p></li>
<li><p>In order to enumerate raw formats supported by a given coded format,
the client must first set that coded format on <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> and then
enumerate formats on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p></li>
</ul>
</li>
<li><p>The client may use <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FRAMESIZES()</span></code> to detect supported
resolutions for a given format, passing desired pixel format in
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_frmsizeenum</span></code> <code class="docutils literal notranslate"><span class="pre">pixel_format</span></code>.</p>
<ul class="simple">
<li><p>Values returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FRAMESIZES()</span></code> for a coded pixel
format will include all possible coded resolutions supported by the
decoder for given coded pixel format.</p></li>
<li><p>Values returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FRAMESIZES()</span></code> for a raw pixel format
will include all possible frame buffer resolutions supported by the
decoder for given raw pixel format and the coded format currently set on
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p></li>
</ul>
</li>
<li><p>Supported profiles and levels for the coded format currently set on
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>, if applicable, may be queried using their respective controls
via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_QUERYCTRL()</span></code>.</p></li>
</ol>
</div>
<div class="section" id="initialization">
<h2><span class="section-number">4.5.1.5. </span>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p>Set the coded format on <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>a coded pixel format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>coded resolution of the stream; required only if it cannot be parsed
from the stream for the given coded format; otherwise the decoder will
use this resolution as a placeholder resolution that will likely change
as soon as it can parse the actual coded resolution from the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sizeimage</span></code></dt><dd><p>desired size of <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers; the decoder may adjust it to
match hardware requirements.</p>
</dd>
<dt>other fields</dt><dd><p>follow standard semantics.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sizeimage</span></code></dt><dd><p>adjusted size of <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers.</p>
</dd>
</dl>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format will be updated with an appropriate frame buffer
resolution instantly based on the width and height returned by
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>.
However, for coded formats that include stream resolution information,
after the decoder is done parsing the information from the stream, it will
update the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format with new values and signal a source change
event, regardless of whether they match the values set by the client or
not.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Changing the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format may change the currently set <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
format. How the new <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format is determined is up to the decoder
and the client must ensure it matches its needs afterwards.</p>
</div>
</li>
<li><p>Allocate source (bytestream) buffers via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>the actual number of buffers allocated.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The actual number of allocated buffers may differ from the <code class="docutils literal notranslate"><span class="pre">count</span></code>
given. The client must check the updated value of <code class="docutils literal notranslate"><span class="pre">count</span></code> after the
call returns.</p>
</div>
<p>Alternatively, <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_CREATE_BUFS()</span></code> on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue can be
used to have more control over buffer allocation.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>adjusted to the number of allocated buffers.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The actual number of allocated buffers may differ from the <code class="docutils literal notranslate"><span class="pre">count</span></code>
given. The client must check the updated value of <code class="docutils literal notranslate"><span class="pre">count</span></code> after the
call returns.</p>
</div>
</li>
<li><p>Start streaming on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code>.</p></li>
<li><p><strong>This step only applies to coded formats that contain resolution information
in the stream.</strong> Continue queuing/dequeuing bytestream buffers to/from the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_QBUF()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DQBUF()</span></code>. The
buffers will be processed and returned to the client in order, until
required metadata to configure the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue are found. This is
indicated by the decoder sending a <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SOURCE_CHANGE</span></code> event with
<code class="docutils literal notranslate"><span class="pre">changes</span></code> set to <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SRC_CH_RESOLUTION</span></code>.</p>
<ul class="simple">
<li><p>It is not an error if the first buffer does not contain enough data for
this to occur. Processing of the buffers will continue as long as more
data is needed.</p></li>
<li><p>If data in a buffer that triggers the event is required to decode the
first frame, it will not be returned to the client, until the
initialization sequence completes and the frame is decoded.</p></li>
<li><p>If the client has not set the coded resolution of the stream on its own,
calling <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_TRY_FMT()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queue will not return the real values for the stream until a
<code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SOURCE_CHANGE</span></code> event with <code class="docutils literal notranslate"><span class="pre">changes</span></code> set to
<code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SRC_CH_RESOLUTION</span></code> is signaled.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Any client query issued after the decoder queues the event will return
values applying to the just parsed stream, including queue formats,
selection rectangles and controls.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A client capable of acquiring stream parameters from the bytestream on
its own may attempt to set the width and height of the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format
to non-zero values matching the coded size of the stream, skip this step
and continue with the <cite>Capture Setup</cite> sequence. However, it must not
rely on any driver queries regarding stream parameters, such as
selection rectangles and controls, since the decoder has not parsed them
from the stream yet. If the values configured by the client do not match
those parsed by the decoder, a <cite>Dynamic Resolution Change</cite> will be
triggered to reconfigure them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No decoded frames are produced during this phase.</p>
</div>
</li>
<li><p>Continue with the <cite>Capture Setup</cite> sequence.</p></li>
</ol>
</div>
<div class="section" id="capture-setup">
<h2><span class="section-number">4.5.1.6. </span>Capture Setup<a class="headerlink" href="#capture-setup" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code> on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue to get format for the
destination buffers parsed/decoded from the bytestream.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>frame buffer resolution for the decoded frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>pixel format for decoded frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_planes</span></code> (for _MPLANE <code class="docutils literal notranslate"><span class="pre">type</span></code> only)</dt><dd><p>number of planes for pixelformat.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sizeimage</span></code>, <code class="docutils literal notranslate"><span class="pre">bytesperline</span></code></dt><dd><p>as per standard semantics; matching frame buffer format.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">pixelformat</span></code> may be any pixel format supported by the
decoder for the current stream. The decoder should choose a
preferred/optimal format for the default configuration. For example, a
YUV format may be preferred over an RGB format if an additional
conversion step would be required for the latter.</p>
</div>
</li>
<li><p><strong>Optional.</strong> Acquire the visible resolution via
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_SELECTION()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target</span></code></dt><dd><p>set to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE</span></code>.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r.left</span></code>, <code class="docutils literal notranslate"><span class="pre">r.top</span></code>, <code class="docutils literal notranslate"><span class="pre">r.width</span></code>, <code class="docutils literal notranslate"><span class="pre">r.height</span></code></dt><dd><p>the visible rectangle; it must fit within the frame buffer resolution
returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code> on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
</dl>
</li>
<li><p>The following selection targets are supported on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP_BOUNDS</span></code></dt><dd><p>corresponds to the coded resolution of the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP_DEFAULT</span></code></dt><dd><p>the rectangle covering the part of the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer that
contains meaningful picture data (visible area); width and height
will be equal to the visible resolution of the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP</span></code></dt><dd><p>the rectangle within the coded resolution to be output to
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>; defaults to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP_DEFAULT</span></code>; read-only on
hardware without additional compose/scaling capabilities.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE_BOUNDS</span></code></dt><dd><p>the maximum rectangle within a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer, which the cropped
frame can be composed into; equal to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP</span></code> if the
hardware does not support compose/scaling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE_DEFAULT</span></code></dt><dd><p>equal to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_CROP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE</span></code></dt><dd><p>the rectangle inside a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer into which the cropped
frame is written; defaults to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE_DEFAULT</span></code>;
read-only on hardware without additional compose/scaling capabilities.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE_PADDED</span></code></dt><dd><p>the rectangle inside a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer which is overwritten by the
hardware; equal to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE</span></code> if the hardware does not
write padding pixels.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The values are guaranteed to be meaningful only after the decoder
successfully parses the stream metadata. The client must not rely on the
query before that happens.</p>
</div>
</li>
<li><p><strong>Optional.</strong> Enumerate <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> formats via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> on
the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. Once the stream information is parsed and known, the
client may use this ioctl to discover which raw formats are supported for
given stream and select one of them via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The decoder will return only formats supported for the currently
established coded format, as per the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format and/or stream
metadata parsed in this initialization sequence, even if more formats
may be supported by the decoder in general. In other words, the set
returned will be a subset of the initial query mentioned in the
<cite>Querying Capabilities</cite> section.</p>
<p>For example, a decoder may support YUV and RGB formats for resolutions
1920x1088 and lower, but only YUV for higher resolutions (due to
hardware limitations). After parsing a resolution of 1920x1088 or lower,
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> may return a set of YUV and RGB pixel formats,
but after parsing resolution higher than 1920x1088, the decoder will not
return RGB, unsupported for this resolution.</p>
<p>However, subsequent resolution change event triggered after
discovering a resolution change within the same stream may switch
the stream into a lower resolution and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code>
would return RGB formats again in that case.</p>
</div>
</li>
<li><p><strong>Optional.</strong> Set the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_FMT()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. The client may choose a different format than
selected/suggested by the decoder in <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>a raw pixel format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>frame buffer resolution of the decoded stream; typically unchanged from
what was returned with <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code>, but it may be different
if the hardware supports composition and/or scaling.</p>
</dd>
</dl>
</li>
</ul>
</li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Setting the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format will reset the compose selection rectangles
to their default values, based on the new resolution, as described in the
previous step.</p></li>
</ul>
</div></blockquote>
<ol class="arabic" start="5">
<li><p><strong>Optional.</strong> Set the compose rectangle via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_SELECTION()</span></code> on
the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue if it is desired and if the decoder has compose and/or
scaling capabilities.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target</span></code></dt><dd><p>set to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r.left</span></code>, <code class="docutils literal notranslate"><span class="pre">r.top</span></code>, <code class="docutils literal notranslate"><span class="pre">r.width</span></code>, <code class="docutils literal notranslate"><span class="pre">r.height</span></code></dt><dd><p>the rectangle inside a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer into which the cropped
frame is written; defaults to <code class="docutils literal notranslate"><span class="pre">V4L2_SEL_TGT_COMPOSE_DEFAULT</span></code>;
read-only on hardware without additional compose/scaling capabilities.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r.left</span></code>, <code class="docutils literal notranslate"><span class="pre">r.top</span></code>, <code class="docutils literal notranslate"><span class="pre">r.width</span></code>, <code class="docutils literal notranslate"><span class="pre">r.height</span></code></dt><dd><p>the visible rectangle; it must fit within the frame buffer resolution
returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code> on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The decoder may adjust the compose rectangle to the nearest
supported one to meet codec and hardware requirements. The client needs
to check the adjusted rectangle returned by <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_S_SELECTION()</span></code>.</p>
</div>
</li>
<li><p>If all the following conditions are met, the client may resume the decoding
instantly:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sizeimage</span></code> of the new format (determined in previous steps) is less
than or equal to the size of currently allocated buffers,</p></li>
<li><p>the number of buffers currently allocated is greater than or equal to the
minimum number of buffers acquired in previous steps. To fulfill this
requirement, the client may use <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_CREATE_BUFS()</span></code> to add new
buffers.</p></li>
</ul>
<p>In that case, the remaining steps do not apply and the client may resume
the decoding by one of the following actions:</p>
<ul class="simple">
<li><p>if the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue is streaming, call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code>
with the <code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_START</span></code> command,</p></li>
<li><p>if the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue is not streaming, call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code>
on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p></li>
</ul>
<p>However, if the client intends to change the buffer set, to lower
memory usage or for any other reasons, it may be achieved by following
the steps below.</p>
</li>
<li><p><strong>If the</strong> <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> <strong>queue is streaming,</strong> keep queuing and dequeuing
buffers on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue until a buffer marked with the
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> flag is dequeued.</p></li>
<li><p><strong>If the</strong> <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> <strong>queue is streaming,</strong> call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code>
on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue to stop streaming.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue must remain streaming. Calling
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> on it would abort the sequence and trigger a
seek.</p>
</div>
</li>
<li><p><strong>If the</strong> <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> <strong>queue has buffers allocated,</strong> free the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
buffers using <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>set to 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p>Allocate <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>actual number of buffers allocated.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The actual number of allocated buffers may differ from the <code class="docutils literal notranslate"><span class="pre">count</span></code>
given. The client must check the updated value of <code class="docutils literal notranslate"><span class="pre">count</span></code> after the
call returns.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To allocate more than the minimum number of buffers (for pipeline
depth), the client may query the <code class="docutils literal notranslate"><span class="pre">V4L2_CID_MIN_BUFFERS_FOR_CAPTURE</span></code>
control to get the minimum number of buffers required, and pass the
obtained value plus the number of additional buffers needed in the
<code class="docutils literal notranslate"><span class="pre">count</span></code> field to <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS()</span></code>.</p>
</div>
<p>Alternatively, <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_CREATE_BUFS()</span></code> on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue can be
used to have more control over buffer allocation. For example, by
allocating buffers larger than the current <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format, future
resolution changes can be accommodated.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>requested number of buffers to allocate; greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>follows standard semantics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>a format representing the maximum framebuffer resolution to be
accommodated by newly allocated buffers.</p>
</dd>
</dl>
</li>
<li><p><strong>Return fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>adjusted to the number of allocated buffers.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The actual number of allocated buffers may differ from the <code class="docutils literal notranslate"><span class="pre">count</span></code>
given. The client must check the updated value of <code class="docutils literal notranslate"><span class="pre">count</span></code> after the
call returns.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To allocate buffers for a format different than parsed from the stream
metadata, the client must proceed as follows, before the metadata
parsing is initiated:</p>
<ul class="simple">
<li><p>set width and height of the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format to desired coded resolution to
let the decoder configure the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format appropriately,</p></li>
<li><p>query the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format using <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_G_FMT()</span></code> and save it
until this step.</p></li>
</ul>
<p>The format obtained in the query may be then used with
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_CREATE_BUFS()</span></code> in this step to allocate the buffers.</p>
</div>
</li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code> on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue to start decoding
frames.</p></li>
</ol>
</div>
<div class="section" id="decoding">
<h2><span class="section-number">4.5.1.7. </span>Decoding<a class="headerlink" href="#decoding" title="Permalink to this headline">¶</a></h2>
<p>This state is reached after the <cite>Capture Setup</cite> sequence finishes successfully.
In this state, the client queues and dequeues buffers to both queues via
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_QBUF()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DQBUF()</span></code>, following the standard
semantics.</p>
<p>The content of the source <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers depends on the active coded pixel
format and may be affected by codec-specific extended controls, as stated in
the documentation of each format.</p>
<p>Both queues operate independently, following the standard behavior of V4L2
buffer queues and memory-to-memory devices. In addition, the order of decoded
frames dequeued from the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue may differ from the order of queuing
coded frames to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue, due to properties of the selected coded
format, e.g. frame reordering.</p>
<p>The client must not assume any direct relationship between <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
and <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers and any specific timing of buffers becoming
available to dequeue. Specifically:</p>
<ul class="simple">
<li><p>a buffer queued to <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> may result in no buffers being produced
on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> (e.g. if it does not contain encoded data, or if only
metadata syntax structures are present in it),</p></li>
<li><p>a buffer queued to <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> may result in more than one buffer produced
on <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> (if the encoded data contained more than one frame, or if
returning a decoded frame allowed the decoder to return a frame that
preceded it in decode, but succeeded it in the display order),</p></li>
<li><p>a buffer queued to <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> may result in a buffer being produced on
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> later into decode process, and/or after processing further
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers, or be returned out of order, e.g. if display
reordering is used,</p></li>
<li><p>buffers may become available on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue without additional
buffers queued to <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> (e.g. during drain or <code class="docutils literal notranslate"><span class="pre">EOS</span></code>), because of the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued in the past whose decoding results are only
available at later time, due to specifics of the decoding process.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To allow matching decoded <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers with <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers they
originated from, the client can set the <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> field of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code> struct when queuing an <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer. The
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer(s), which resulted from decoding that <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer
will have their <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> field set to the same value when dequeued.</p>
<p>In addition to the straightforward case of one <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer producing
one <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer, the following cases are defined:</p>
<ul class="simple">
<li><p>one <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer generates multiple <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers: the same
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> timestamp will be copied to multiple <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers.</p></li>
<li><p>multiple <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers generate one <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer: timestamp of
the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffer queued first will be copied.</p></li>
<li><p>the decoding order differs from the display order (i.e. the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
buffers are out-of-order compared to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers): <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
timestamps will not retain the order of <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> timestamps.</p></li>
</ul>
</div>
<p>During the decoding, the decoder may initiate one of the special sequences, as
listed below. The sequences will result in the decoder returning all the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers that originated from all the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers processed
before the sequence started. Last of the buffers will have the
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> flag set. To determine the sequence to follow, the client
must check if there is any pending event and:</p>
<ul class="simple">
<li><p>if a <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SOURCE_CHANGE</span></code> event with <code class="docutils literal notranslate"><span class="pre">changes</span></code> set to
<code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SRC_CH_RESOLUTION</span></code> is pending, the <cite>Dynamic Resolution
Change</cite> sequence needs to be followed,</p></li>
<li><p>if a <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_EOS</span></code> event is pending, the <cite>End of Stream</cite> sequence needs
to be followed.</p></li>
</ul>
<p>Some of the sequences can be intermixed with each other and need to be handled
as they happen. The exact operation is documented for each sequence.</p>
<p>Should a decoding error occur, it will be reported to the client with the level
of details depending on the decoder capabilities. Specifically:</p>
<ul class="simple">
<li><p>the CAPTURE buffer that contains the results of the failed decode operation
will be returned with the V4L2_BUF_FLAG_ERROR flag set,</p></li>
<li><p>if the decoder is able to precisely report the OUTPUT buffer that triggered
the error, such buffer will be returned with the V4L2_BUF_FLAG_ERROR flag
set.</p></li>
</ul>
<p>In case of a fatal failure that does not allow the decoding to continue, any
further operations on corresponding decoder file handle will return the -EIO
error code. The client may close the file handle and open a new one, or
alternatively reinitialize the instance by stopping streaming on both queues,
releasing all buffers and performing the Initialization sequence again.</p>
</div>
<div class="section" id="seek">
<h2><span class="section-number">4.5.1.8. </span>Seek<a class="headerlink" href="#seek" title="Permalink to this headline">¶</a></h2>
<p>Seek is controlled by the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue, as it is the source of coded data.
The seek does not require any specific operation on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue, but
it may be affected as per normal decoder operation.</p>
<ol class="arabic">
<li><p>Stop the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue to begin the seek sequence via
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
</dl>
</li>
<li><p>The decoder will drop all the pending <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers and they must be
treated as returned to the client (following standard semantics).</p></li>
</ul>
</li>
<li><p>Restart the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue via <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_TYPE_*</span></code> enum appropriate for <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>.</p>
</dd>
</dl>
</li>
<li><p>The decoder will start accepting new source bytestream buffers after the
call returns.</p></li>
</ul>
</li>
<li><p>Start queuing buffers containing coded data after the seek to the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
queue until a suitable resume point is found.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no requirement to begin queuing coded data starting exactly
from a resume point (e.g. SPS or a keyframe). Any queued <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
buffers will be processed and returned to the client until a suitable
resume point is found.  While looking for a resume point, the decoder
should not produce any decoded frames into <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers.</p>
<p>Some hardware is known to mishandle seeks to a non-resume point. Such an
operation may result in an unspecified number of corrupted decoded frames
being made available on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. Drivers must ensure that
no fatal decoding errors or crashes occur, and implement any necessary
handling and workarounds for hardware issues related to seek operations.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In case of the H.264/HEVC codec, the client must take care not to seek
over a change of SPS/PPS. Even though the target frame could be a
keyframe, the stale SPS/PPS inside decoder state would lead to undefined
results when decoding. Although the decoder must handle that case without
a crash or a fatal decode error, the client must not expect a sensible
decode output.</p>
<p>If the hardware can detect such corrupted decoded frames, then
corresponding buffers will be returned to the client with the
V4L2_BUF_FLAG_ERROR set. See the <cite>Decoding</cite> section for further
description of decode error reporting.</p>
</div>
</li>
<li><p>After a resume point is found, the decoder will start returning <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
buffers containing decoded frames.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>A seek may result in the <cite>Dynamic Resolution Change</cite> sequence being
initiated, due to the seek target having decoding parameters different from
the part of the stream decoded before the seek. The sequence must be handled
as per normal decoder operation.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not specified when the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue starts producing buffers
containing decoded data from the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued after the seek,
as it operates independently from the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue.</p>
<p>The decoder may return a number of remaining <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers containing
decoded frames originating from the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued before the
seek sequence is performed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF</span></code> operation discards any remaining queued
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers, which means that not all of the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers
queued before the seek sequence may have matching <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers
produced.  For example, given the sequence of operations on the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue:</p>
<blockquote>
<div><p>QBUF(A), QBUF(B), STREAMOFF(), STREAMON(), QBUF(G), QBUF(H),</p>
</div></blockquote>
<p>any of the following results on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue is allowed:</p>
<blockquote>
<div><p>{A’, B’, G’, H’}, {A’, G’, H’}, {G’, H’}.</p>
</div></blockquote>
<p>To determine the CAPTURE buffer containing the first decoded frame after the
seek, the client may observe the timestamps to match the CAPTURE and OUTPUT
buffers or use V4L2_DEC_CMD_STOP and V4L2_DEC_CMD_START to drain the
decoder.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To achieve instantaneous seek, the client may restart streaming on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue too to discard decoded, but not yet dequeued buffers.</p>
</div>
</div>
<div class="section" id="dynamic-resolution-change">
<h2><span class="section-number">4.5.1.9. </span>Dynamic Resolution Change<a class="headerlink" href="#dynamic-resolution-change" title="Permalink to this headline">¶</a></h2>
<p>Streams that include resolution metadata in the bytestream may require switching
to a different resolution during the decoding.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all decoders can detect resolution changes. Those that do set the
<code class="docutils literal notranslate"><span class="pre">V4L2_FMT_FLAG_DYN_RESOLUTION</span></code> flag for the coded format when
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_ENUM_FMT()</span></code> is called.</p>
</div>
<p>The sequence starts when the decoder detects a coded frame with one or more of
the following parameters different from those previously established (and
reflected by corresponding queries):</p>
<ul class="simple">
<li><p>coded resolution (<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> width and height),</p></li>
<li><p>visible resolution (selection rectangles),</p></li>
<li><p>the minimum number of buffers needed for decoding,</p></li>
<li><p>bit-depth of the bitstream has been changed.</p></li>
</ul>
<p>Whenever that happens, the decoder must proceed as follows:</p>
<ol class="arabic">
<li><p>After encountering a resolution change in the stream, the decoder sends a
<code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SOURCE_CHANGE</span></code> event with <code class="docutils literal notranslate"><span class="pre">changes</span></code> set to
<code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_SRC_CH_RESOLUTION</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Any client query issued after the decoder queues the event will return
values applying to the stream after the resolution change, including
queue formats, selection rectangles and controls.</p>
</div>
</li>
<li><p>The decoder will then process and decode all remaining buffers from before
the resolution change point.</p>
<ul class="simple">
<li><p>The last buffer from before the change must be marked with the
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> flag, similarly to the <cite>Drain</cite> sequence above.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The last buffer may be empty (with <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code> <code class="docutils literal notranslate"><span class="pre">bytesused</span></code>
= 0) and in that case it must be ignored by the client, as it does not
contain a decoded frame.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any attempt to dequeue more <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers beyond the buffer marked
with <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> will result in a -EPIPE error from
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DQBUF()</span></code>.</p>
</div>
</li>
</ol>
<p>The client must continue the sequence as described below to continue the
decoding process.</p>
<ol class="arabic">
<li><p>Dequeue the source change event.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>A source change triggers an implicit decoder drain, similar to the
explicit <cite>Drain</cite> sequence. The decoder is stopped after it completes.
The decoding process must be resumed with either a pair of calls to
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue, or a call to <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code> with the
<code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_START</span></code> command.</p>
</div>
</li>
<li><p>Continue with the <cite>Capture Setup</cite> sequence.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>During the resolution change sequence, the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue must remain
streaming. Calling <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue would
abort the sequence and initiate a seek.</p>
<p>In principle, the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue operates separately from the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queue and this remains true for the duration of the entire resolution change
sequence as well.</p>
<p>The client should, for best performance and simplicity, keep queuing/dequeuing
buffers to/from the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue even while processing this sequence.</p>
</div>
</div>
<div class="section" id="drain">
<h2><span class="section-number">4.5.1.10. </span>Drain<a class="headerlink" href="#drain" title="Permalink to this headline">¶</a></h2>
<p>To ensure that all queued <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers have been processed and related
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers are given to the client, the client must follow the drain
sequence described below. After the drain sequence ends, the client has
received all decoded frames for all <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued before the
sequence was started.</p>
<ol class="arabic">
<li><p>Begin drain by issuing <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code>.</p>
<ul>
<li><p><strong>Required fields:</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>set to <code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_STOP</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>set to 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pts</span></code></dt><dd><p>set to 0.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The sequence can be only initiated if both <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> and <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queues are streaming. For compatibility reasons, the call to
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code> will not fail even if any of the queues is
not streaming, but at the same time it will not initiate the <cite>Drain</cite>
sequence and so the steps described below would not be applicable.</p>
</div>
</li>
<li><p>Any <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued by the client before the
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code> was issued will be processed and decoded as
normal. The client must continue to handle both queues independently,
similarly to normal decode operation. This includes:</p>
<ul>
<li><p>handling any operations triggered as a result of processing those buffers,
such as the <cite>Dynamic Resolution Change</cite> sequence, before continuing with
the drain sequence,</p></li>
<li><p>queuing and dequeuing <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers, until a buffer marked with the
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> flag is dequeued,</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The last buffer may be empty (with <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buffer</span></code>
<code class="docutils literal notranslate"><span class="pre">bytesused</span></code> = 0) and in that case it must be ignored by the client,
as it does not contain a decoded frame.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any attempt to dequeue more <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers beyond the buffer
marked with <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> will result in a -EPIPE error from
<code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DQBUF()</span></code>.</p>
</div>
</li>
<li><p>dequeuing processed <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers, until all the buffers queued
before the <code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_STOP</span></code> command are dequeued,</p></li>
<li><p>dequeuing the <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_EOS</span></code> event, if the client subscribed to it.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For backwards compatibility, the decoder will signal a <code class="docutils literal notranslate"><span class="pre">V4L2_EVENT_EOS</span></code>
event when the last frame has been decoded and all frames are ready to be
dequeued. It is a deprecated behavior and the client must not rely on it.
The <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_LAST</span></code> buffer flag should be used instead.</p>
</div>
</li>
<li><p>Once all the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> buffers queued before the <code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_STOP</span></code> call
are dequeued and the last <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffer is dequeued, the decoder is
stopped and it will accept, but not process, any newly queued <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>
buffers until the client issues any of the following operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_START</span></code> - the decoder will not be reset and will resume
operation normally, with all the state from before the drain,</p></li>
<li><p>a pair of <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue - the decoder will resume the operation normally,
however any <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> buffers still in the queue will be returned to the
client,</p></li>
<li><p>a pair of <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMON()</span></code> on the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue - any pending source buffers will be returned to the
client and the <cite>Seek</cite> sequence will be triggered.</p></li>
</ul>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once the drain sequence is initiated, the client needs to drive it to
completion, as described by the steps above, unless it aborts the process by
issuing <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_STREAMOFF()</span></code> on any of the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> or <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
queues.  The client is not allowed to issue <code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_START</span></code> or
<code class="docutils literal notranslate"><span class="pre">V4L2_DEC_CMD_STOP</span></code> again while the drain sequence is in progress and they
will fail with -EBUSY error code if attempted.</p>
<p>Although not mandatory, the availability of decoder commands may be queried
using <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_TRY_DECODER_CMD()</span></code>.</p>
</div>
</div>
<div class="section" id="end-of-stream">
<h2><span class="section-number">4.5.1.11. </span>End of Stream<a class="headerlink" href="#end-of-stream" title="Permalink to this headline">¶</a></h2>
<p>If the decoder encounters an end of stream marking in the stream, the decoder
will initiate the <cite>Drain</cite> sequence, which the client must handle as described
above, skipping the initial <code class="xref c c-func docutils literal notranslate"><span class="pre">VIDIOC_DECODER_CMD()</span></code>.</p>
</div>
<div class="section" id="commit-points">
<h2><span class="section-number">4.5.1.12. </span>Commit Points<a class="headerlink" href="#commit-points" title="Permalink to this headline">¶</a></h2>
<p>Setting formats and allocating buffers trigger changes in the behavior of the
decoder.</p>
<ol class="arabic simple">
<li><p>Setting the format on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue may change the set of formats
supported/advertised on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue. In particular, it also means
that the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format may be reset and the client must not rely on the
previously set format being preserved.</p></li>
<li><p>Enumerating formats on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue always returns only formats
supported for the current <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format.</p></li>
<li><p>Setting the format on the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue does not change the list of
formats available on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue. An attempt to set a <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code>
format that is not supported for the currently selected <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> format
will result in the decoder adjusting the requested <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format to a
supported one.</p></li>
<li><p>Enumerating formats on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue always returns the full set of
supported coded formats, irrespectively of the current <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> format.</p></li>
<li><p>While buffers are allocated on any of the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> or <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queues,
the client must not change the format on the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue. Drivers will
return the -EBUSY error code for any such format change attempt.</p></li>
</ol>
<p>To summarize, setting formats and allocation must always start with the
<code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue and the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> queue is the master that governs the
set of supported formats for the <code class="docutils literal notranslate"><span class="pre">CAPTURE</span></code> queue.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dev-encoder.html" class="btn btn-neutral float-right" title="4.5.2. Memory-to-Memory Stateful Video Encoder Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dev-mem2mem.html" class="btn btn-neutral float-left" title="4.5. Video Memory-To-Memory Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>