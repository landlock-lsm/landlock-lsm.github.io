

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>General Purpose Input/Output (GPIO) &mdash; The Linux Kernel 5.8.0-rc4+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Introduction" href="intro.html" />
    <link rel="prev" title="PINCTRL (PIN CONTROL) subsystem" href="../pinctl.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0-rc4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">General Purpose Input/Output (GPIO)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="using-gpio.html">Using GPIO Lines in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver.html">GPIO Driver Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>General Purpose Input/Output (GPIO)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/gpio/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="general-purpose-input-output-gpio">
<h1>General Purpose Input/Output (GPIO)<a class="headerlink" href="#general-purpose-input-output-gpio" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html#gpio-interfaces">GPIO Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#common-gpio-properties">Common GPIO Properties</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using-gpio.html">Using GPIO Lines in Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">GPIO Driver Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="driver.html#internal-representation-of-gpios">Internal Representation of GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#controller-drivers-gpio-chip">Controller Drivers: gpio_chip</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#gpio-drivers-providing-irqs">GPIO drivers providing IRQs</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#requesting-self-owned-gpio-pins">Requesting self-owned GPIO pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#guidelines-for-gpios-consumers">Guidelines for GPIOs consumers</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#obtaining-and-disposing-gpios">Obtaining and Disposing GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#using-gpios">Using GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#gpios-and-acpi">GPIOs and ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#interacting-with-the-legacy-gpio-subsystem">Interacting With the Legacy GPIO Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="board.html">GPIO Mappings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="board.html#device-tree">Device Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#acpi">ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#platform-data">Platform Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#arrays-of-pins">Arrays of pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-conventions">GPIO conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-do-these-conventions-omit">What do these conventions omit?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-implementor-s-framework-optional">GPIO implementor’s framework (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#sysfs-interface-for-userspace-optional">Sysfs Interface for Userspace (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="bt8xxgpio.html#how-to-physically-access-the-gpio-pins">How to physically access the GPIO pins</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.gpio_irq_chip">
struct <code class="sig-name descname">gpio_irq_chip</code><a class="headerlink" href="#c.gpio_irq_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>GPIO interrupt controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_irq_chip {
  struct irq_chip *chip;
  struct irq_domain *domain;
  const struct irq_domain_ops *domain_ops;
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
  struct fwnode_handle *fwnode;
  struct irq_domain *parent_domain;
  int (*child_to_parent_hwirq)(struct gpio_chip *gc,unsigned int child_hwirq,unsigned int child_type,unsigned int *parent_hwirq, unsigned int *parent_type);
  void *(*populate_parent_alloc_arg)(struct gpio_chip *gc,unsigned int parent_hwirq, unsigned int parent_type);
  unsigned int (*child_offset_to_irq)(struct gpio_chip *gc, unsigned int pin);
  struct irq_domain_ops child_irq_domain_ops;
#endif;
  irq_flow_handler_t handler;
  unsigned int default_type;
  struct lock_class_key *lock_key;
  struct lock_class_key *request_key;
  irq_flow_handler_t parent_handler;
  void *parent_handler_data;
  unsigned int num_parents;
  unsigned int *parents;
  unsigned int *map;
  bool threaded;
  int (*init_hw)(struct gpio_chip *gc);
  void (*init_valid_mask)(struct gpio_chip *gc,unsigned long *valid_mask, unsigned int ngpios);
  unsigned long *valid_mask;
  unsigned int first;
  void (*irq_enable)(struct irq_data *data);
  void (*irq_disable)(struct irq_data *data);
  void (*irq_unmask)(struct irq_data *data);
  void (*irq_mask)(struct irq_data *data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>GPIO IRQ chip implementation, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>Interrupt translation domain; responsible for mapping between GPIO
hwirq number and Linux IRQ number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain_ops</span></code></dt><dd><p>Table of interrupt domain operations for this IRQ chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Firmware node corresponding to this gpiochip/irqchip, necessary
for hierarchical irqdomain support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_domain</span></code></dt><dd><p>If non-NULL, will be set as the parent of this GPIO interrupt
controller’s IRQ domain to establish a hierarchical interrupt
domain. The presence of this will activate the hierarchical
interrupt support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_to_parent_hwirq</span></code></dt><dd><p>This callback translates a child hardware IRQ offset to a parent
hardware IRQ offset on a hierarchical interrupt chip. The child
hardware IRQs correspond to the GPIO index 0..ngpio-1 (see the
ngpio field of struct gpio_chip) and the corresponding parent
hardware IRQ and type (such as IRQ_TYPE_*) shall be returned by
the driver. The driver can calculate this from an offset or using
a lookup table or whatever method is best for this chip. Return
0 on successful translation in the driver.</p>
<p>If some ranges of hardware IRQs do not have a corresponding parent
HWIRQ, return -EINVAL, but also make sure to fill in <strong>valid_mask</strong> and
<strong>need_valid_mask</strong> to make these GPIO lines unavailable for
translation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">populate_parent_alloc_arg</span></code></dt><dd><p>This optional callback allocates and populates the specific struct
for the parent’s IRQ domain. If this is not specified, then
<code class="xref c c-type docutils literal notranslate"><span class="pre">gpiochip_populate_parent_fwspec_twocell</span></code> will be used. A four-cell
variant named <code class="xref c c-type docutils literal notranslate"><span class="pre">gpiochip_populate_parent_fwspec_fourcell</span></code> is also
available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_offset_to_irq</span></code></dt><dd><p>This optional callback is used to translate the child’s GPIO line
offset on the GPIO chip to an IRQ number for the GPIO to_irq()
callback. If this is not specified, then a default callback will be
provided that returns the line offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_irq_domain_ops</span></code></dt><dd><p>The IRQ domain operations that will be used for this GPIO IRQ
chip. If no operations are provided, then default callbacks will
be populated to setup the IRQ hierarchy. Some drivers need to
supply their own translate function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>The IRQ handler to use (often a predefined IRQ core function) for
GPIO IRQs, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">default_type</span></code></dt><dd><p>Default IRQ triggering type applied during GPIO driver
initialization, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_key</span></code></dt><dd><p>Per GPIO IRQ chip lockdep class for IRQ lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_key</span></code></dt><dd><p>Per GPIO IRQ chip lockdep class for IRQ request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_handler</span></code></dt><dd><p>The interrupt handler for the GPIO chip’s parent interrupts, may be
NULL if the parent interrupts are nested rather than cascaded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_handler_data</span></code></dt><dd><p>Data associated, and passed to, the handler for the parent
interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_parents</span></code></dt><dd><p>The number of interrupt parents of a GPIO chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parents</span></code></dt><dd><p>A list of interrupt parents of a GPIO chip. This is owned by the
driver, so the core will only reference this list, not modify it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>A list of interrupt parents for each line of a GPIO chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">threaded</span></code></dt><dd><p>True if set the interrupt handling uses nested threads.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_hw</span></code></dt><dd><p>optional routine to initialize hardware before
an IRQ chip will be added. This is quite useful when
a particular driver wants to clear IRQ related registers
in order to avoid undesired events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_valid_mask</span></code></dt><dd><p>optional routine to initialize <strong>valid_mask</strong>, to be
used if not all GPIO lines are valid interrupts. Sometimes some
lines just cannot fire interrupts, and this routine, when defined,
is passed a bitmap in “valid_mask” and it will have ngpios
bits from 0..(ngpios-1) set to “1” as in valid. The callback can
then directly set some bits to “0” if they cannot be used for
interrupts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_mask</span></code></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> holds bitmask of GPIOs which are valid to be included
in IRQ domain of the chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code></dt><dd><p>Required for static IRQ allocation. If set, irq_domain_add_simple()
will allocate and map all IRQs during initialization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_enable</span></code></dt><dd><p>Store old irq_chip irq_enable callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_disable</span></code></dt><dd><p>Store old irq_chip irq_disable callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_unmask</span></code></dt><dd><p>Store old irq_chip irq_unmask callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_mask</span></code></dt><dd><p>Store old irq_chip irq_mask callback</p>
</dd>
</dl>
<dl class="type">
<dt id="c.gpio_chip">
struct <code class="sig-name descname">gpio_chip</code><a class="headerlink" href="#c.gpio_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract a GPIO controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_chip {
  const char              *label;
  struct gpio_device      *gpiodev;
  struct device           *parent;
  struct module           *owner;
  int (*request)(struct gpio_chip *gc, unsigned int offset);
  void (*free)(struct gpio_chip *gc, unsigned int offset);
  int (*get_direction)(struct gpio_chip *gc, unsigned int offset);
  int (*direction_input)(struct gpio_chip *gc, unsigned int offset);
  int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value);
  int (*get)(struct gpio_chip *gc, unsigned int offset);
  int (*get_multiple)(struct gpio_chip *gc,unsigned long *mask, unsigned long *bits);
  void (*set)(struct gpio_chip *gc, unsigned int offset, int value);
  void (*set_multiple)(struct gpio_chip *gc,unsigned long *mask, unsigned long *bits);
  int (*set_config)(struct gpio_chip *gc,unsigned int offset, unsigned long config);
  int (*to_irq)(struct gpio_chip *gc, unsigned int offset);
  void (*dbg_show)(struct seq_file *s, struct gpio_chip *gc);
  int (*init_valid_mask)(struct gpio_chip *gc,unsigned long *valid_mask, unsigned int ngpios);
  int (*add_pin_ranges)(struct gpio_chip *gc);
  int base;
  u16 ngpio;
  const char              *const *names;
  bool can_sleep;
#if IS_ENABLED(CONFIG_GPIO_GENERIC);
  unsigned long (*read_reg)(void __iomem *reg);
  void (*write_reg)(void __iomem *reg, unsigned long data);
  bool be_bits;
  void __iomem *reg_dat;
  void __iomem *reg_set;
  void __iomem *reg_clr;
  void __iomem *reg_dir_out;
  void __iomem *reg_dir_in;
  bool bgpio_dir_unreadable;
  int bgpio_bits;
  spinlock_t bgpio_lock;
  unsigned long bgpio_data;
  unsigned long bgpio_dir;
#endif ;
#ifdef CONFIG_GPIOLIB_IRQCHIP;
  struct gpio_irq_chip irq;
#endif ;
  unsigned long *valid_mask;
#if defined(CONFIG_OF_GPIO);
  struct device_node *of_node;
  unsigned int of_gpio_n_cells;
  int (*of_xlate)(struct gpio_chip *gc, const struct of_phandle_args *gpiospec, u32 *flags);
#endif ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>a functional name for the GPIO device, such as a part
number or the name of the SoC IP-block implementing it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpiodev</span></code></dt><dd><p>the internal state holder, opaque struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>optional parent device providing the GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>helps prevent removal of modules exporting active GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>optional hook for chip-specific activation, such as
enabling module power and clock; may sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>optional hook for chip-specific deactivation, such as
disabling module power and clock; may sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_direction</span></code></dt><dd><p>returns direction for signal “offset”, 0=out, 1=in,
(same as GPIO_LINE_DIRECTION_OUT / GPIO_LINE_DIRECTION_IN),
or negative error. It is recommended to always implement this
function, even on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction_input</span></code></dt><dd><p>configures signal “offset” as input, or returns error
This can be omitted on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction_output</span></code></dt><dd><p>configures signal “offset” as output, or returns error
This can be omitted on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>returns value for signal “offset”, 0=low, 1=high, or negative error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_multiple</span></code></dt><dd><p>reads values for multiple signals defined by “mask” and
stores them in “bits”, returns 0 on success or negative error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>assigns output value for signal “offset”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_multiple</span></code></dt><dd><p>assigns output values for multiple signals defined by “mask”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_config</span></code></dt><dd><p>optional hook for all kinds of settings. Uses the same
packed config format as generic pinconf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to_irq</span></code></dt><dd><p>optional hook supporting non-static gpio_to_irq() mappings;
implementation may not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbg_show</span></code></dt><dd><p>optional routine to show contents in debugfs; default code
will be used when this is omitted, but custom code can show extra
state (such as pullup/pulldown configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_valid_mask</span></code></dt><dd><p>optional routine to initialize <strong>valid_mask</strong>, to be used if
not all GPIOs are valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_pin_ranges</span></code></dt><dd><p>optional routine to initialize pin ranges, to be used when
requires special mapping of the pins that provides GPIO functionality.
It is called after adding GPIO chip and before adding IRQ chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>identifies the first GPIO number handled by this chip;
or, if negative during registration, requests dynamic ID allocation.
DEPRECATION: providing anything non-negative and nailing the base
offset of GPIO chips is deprecated. Please pass -1 as base to
let gpiolib select the chip base in all possible cases. We want to
get rid of the static GPIO number space in the long run.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ngpio</span></code></dt><dd><p>the number of GPIOs handled by this controller; the last GPIO
handled is (base + ngpio - 1).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">names</span></code></dt><dd><p>if set, must be an array of strings to use as alternative
names for the GPIOs in this chip. Any entry in the array
may be NULL if there is no alias for the GPIO, however the
array must be <strong>ngpio</strong> entries long.  A name can include a single printk
format specifier for an unsigned int.  It is substituted by the actual
number of the gpio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_sleep</span></code></dt><dd><p>flag must be set iff get()/set() methods sleep, as they
must while accessing GPIO expander chips over I2C or SPI. This
implies that if the chip supports IRQs, these IRQs need to be threaded
as the chip access may sleep when e.g. reading out the IRQ status
registers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_reg</span></code></dt><dd><p>reader function for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_reg</span></code></dt><dd><p>writer function for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">be_bits</span></code></dt><dd><p>if the generic GPIO has big endian bit order (bit 31 is representing
line 0, bit 30 is line 1 … bit 0 is line 31) this is set to true by the
generic GPIO core. It is for internal housekeeping only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dat</span></code></dt><dd><p>data (in) register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_set</span></code></dt><dd><p>output set register (out=high) for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_clr</span></code></dt><dd><p>output clear register (out=low) for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dir_out</span></code></dt><dd><p>direction out setting register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dir_in</span></code></dt><dd><p>direction in setting register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_dir_unreadable</span></code></dt><dd><p>indicates that the direction register(s) cannot
be read and we need to rely on out internal state tracking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_bits</span></code></dt><dd><p>number of register bits used for a generic GPIO i.e.
&lt;register width&gt; * 8</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_lock</span></code></dt><dd><p>used to lock chip-&gt;bgpio_data. Also, this is needed to keep
shadowed and real data registers writes together.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_data</span></code></dt><dd><p>shadowed data register for generic GPIO to clear/set bits
safely.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_dir</span></code></dt><dd><p>shadowed direction register for generic GPIO to clear/set
direction safely. A “1” in this word means the line is set as
output.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Integrates interrupt chip functionality with the GPIO chip. Can be
used to handle IRQs for most practical cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_mask</span></code></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> holds bitmask of GPIOs which are valid to be used
from the chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>Pointer to a device tree node representing this GPIO controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_gpio_n_cells</span></code></dt><dd><p>Number of cells used to form the GPIO specifier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_xlate</span></code></dt><dd><p>Callback to translate a device tree GPIO specifier into a chip-
relative GPIO number and flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip can help platforms abstract various sources of GPIOs so
they can all be accessed through a common programing interface.
Example sources would be SOC controllers, FPGAs, multifunction
chips, dedicated GPIO expanders, and so on.</p>
<p>Each chip controls a number of signals, identified in method calls
by “offset” values in the range 0..(<strong>ngpio</strong> - 1).  When those signals
are referenced through calls like gpio_get_value(gpio), the offset
is calculated by subtracting <strong>base</strong> from the gpio number.</p>
<dl class="function">
<dt id="c.gpiochip_add_data">
<code class="sig-name descname">gpiochip_add_data</code><span class="sig-paren">(</span><em>gc</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>register a gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gc</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>driver-private data associated with this chip</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a> is called very early during boot, so that GPIOs
can be freely used, the chip-&gt;parent device must be registered before
the gpio framework’s arch_initcall().  Otherwise sysfs initialization
for GPIOs will fail rudely.</p>
<p><a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a> must only be called after gpiolib initialization,
ie after core_initcall().</p>
<p>If chip-&gt;base is negative, this requests dynamic assignment of
a range of valid GPIOs.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can’t be registered, such as because the
chip-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
<dl class="type">
<dt id="c.gpio_pin_range">
struct <code class="sig-name descname">gpio_pin_range</code><a class="headerlink" href="#c.gpio_pin_range" title="Permalink to this definition">¶</a></dt>
<dd><p>pin range controlled by a gpio chip</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_pin_range {
  struct list_head node;
  struct pinctrl_dev *pctldev;
  struct pinctrl_gpio_range range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list for maintaining set of pin ranges, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pctldev</span></code></dt><dd><p>pinctrl device which handles corresponding pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range</span></code></dt><dd><p>actual range of pins controlled by a gpio controller</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpio_to_desc">
struct gpio_desc * <code class="sig-name descname">gpio_to_desc</code><span class="sig-paren">(</span>unsigned<em> gpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_to_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a GPIO number to its descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>global GPIO number</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The GPIO descriptor associated with the given GPIO, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no GPIO
with the given number exists in the system.</p>
<dl class="function">
<dt id="c.gpiochip_get_desc">
struct gpio_desc * <code class="sig-name descname">gpiochip_get_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned int<em> hwnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_get_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>get the GPIO descriptor corresponding to the given hardware number for this chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwnum</span></code></dt><dd><p>hardware number of the GPIO for this chip</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the GPIO descriptor or <code class="docutils literal notranslate"><span class="pre">ERR_PTR(-EINVAL)</span></code> if no GPIO exists
in the given chip for the specified hardware number.</p>
<dl class="function">
<dt id="c.desc_to_gpio">
int <code class="sig-name descname">desc_to_gpio</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.desc_to_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a GPIO descriptor to the integer namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should disappear in the future but is needed since we still
use GPIO numbers for error messages and sysfs nodes.</p>
<p><strong>Return</strong></p>
<p>The global GPIO number for the GPIO specified by its descriptor.</p>
<dl class="function">
<dt id="c.gpiod_to_chip">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="sig-name descname">gpiod_to_chip</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the GPIO chip to which a GPIO descriptor belongs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>descriptor to return the chip of</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_get_direction">
int <code class="sig-name descname">gpiod_get_direction</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current direction of a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to get the direction of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for output, 1 for input, or an error code in case of error.</p>
<p>This function may sleep if <a class="reference internal" href="#c.gpiod_cansleep" title="gpiod_cansleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_cansleep()</span></code></a> is true.</p>
<dl class="function">
<dt id="c.gpiochip_get_data">
void * <code class="sig-name descname">gpiochip_get_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get per-subdriver data for the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The per-subdriver data for the chip.</p>
<dl class="function">
<dt id="c.gpiochip_remove">
void <code class="sig-name descname">gpiochip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the chip to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip with any GPIOs still requested may not be removed.</p>
<dl class="function">
<dt id="c.gpiochip_find">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="sig-name descname">gpiochip_find</code><span class="sig-paren">(</span>void *<em> data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *gc, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_find" title="Permalink to this definition">¶</a></dt>
<dd><p>iterator for locating a specific gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt><dd><p>Callback function to check gpio_chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to bus_find_device.  It returns a reference to a gpio_chip as
determined by a user supplied <strong>match</strong> callback.  The callback should return
0 if the device doesn’t match and non-zero if it does.  If the callback is
non-zero, this function will return to the caller and not iterate over any
more gpio_chips.</p>
<dl class="function">
<dt id="c.gpiochip_set_nested_irqchip">
void <code class="sig-name descname">gpiochip_set_nested_irqchip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_chip" title="irq_chip">irq_chip</a> *<em> irqchip</em>, unsigned int<em> parent_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_set_nested_irqchip" title="Permalink to this definition">¶</a></dt>
<dd><p>connects a nested irqchip to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to set the irqchip nested handler to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*</span> <span class="pre">irqchip</span></code></dt><dd><p>the irqchip to nest to the gpiochip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">parent_irq</span></code></dt><dd><p>the irq number corresponding to the parent IRQ for this
nested irqchip</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_irq_map">
int <code class="sig-name descname">gpiochip_irq_map</code><span class="sig-paren">(</span>struct irq_domain *<em> d</em>, unsigned int<em> irq</em>, irq_hw_number_t<em> hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps an IRQ into a GPIO irqchip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">d</span></code></dt><dd><p>the irqdomain used by this irqchip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the global irq number used by this GPIO irqchip irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>the local IRQ/GPIO line offset on this gpiochip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will set up the mapping for a certain IRQ line on a
gpiochip by assigning the gpiochip as chip data, and using the irqchip
stored inside the gpiochip.</p>
<dl class="function">
<dt id="c.gpiochip_irq_domain_activate">
int <code class="sig-name descname">gpiochip_irq_domain_activate</code><span class="sig-paren">(</span>struct irq_domain *<em> domain</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em> data</em>, bool<em> reserve</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_domain_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock a GPIO to be used as an IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">domain</span></code></dt><dd><p>The IRQ domain used by this IRQ chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>Outermost irq_data associated with the IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">reserve</span></code></dt><dd><p>If set, only reserve an interrupt vector instead of assigning one</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper that calls <a class="reference internal" href="#c.gpiochip_lock_as_irq" title="gpiochip_lock_as_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_lock_as_irq()</span></code></a> and is to be
used as the activate function for the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code>. The host_data
for the IRQ domain must be the <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>.</p>
<dl class="function">
<dt id="c.gpiochip_irq_domain_deactivate">
void <code class="sig-name descname">gpiochip_irq_domain_deactivate</code><span class="sig-paren">(</span>struct irq_domain *<em> domain</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_domain_deactivate" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock a GPIO used as an IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">domain</span></code></dt><dd><p>The IRQ domain used by this IRQ chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>Outermost irq_data associated with the IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper that will call <a class="reference internal" href="#c.gpiochip_unlock_as_irq" title="gpiochip_unlock_as_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_unlock_as_irq()</span></code></a> and is to
be used as the deactivate function for the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code>. The
host_data for the IRQ domain must be the <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>.</p>
<dl class="function">
<dt id="c.gpiochip_irqchip_add_key">
int <code class="sig-name descname">gpiochip_irqchip_add_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_chip" title="irq_chip">irq_chip</a> *<em> irqchip</em>, unsigned int<em> first_irq</em>, irq_flow_handler_t<em> handler</em>, unsigned int<em> type</em>, bool<em> threaded</em>, struct lock_class_key *<em> lock_key</em>, struct lock_class_key *<em> request_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irqchip_add_key" title="Permalink to this definition">¶</a></dt>
<dd><p>adds an irqchip to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to add the irqchip to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*</span> <span class="pre">irqchip</span></code></dt><dd><p>the irqchip to add to the gpiochip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">first_irq</span></code></dt><dd><p>if not dynamically assigned, the base (first) IRQ to
allocate gpiochip irqs from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flow_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>the irq handler to use (often a predefined irq core function)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the default type for IRQs on this irqchip, pass IRQ_TYPE_NONE
to have the core avoid setting up any default type in the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">threaded</span></code></dt><dd><p>whether this irqchip uses a nested thread handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">lock_key</span></code></dt><dd><p>lockdep class for IRQ lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">request_key</span></code></dt><dd><p>lockdep class for IRQ request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function closely associates a certain irqchip with a certain
gpiochip, providing an irq domain to translate the local IRQs to
global irqs in the gpiolib core, and making sure that the gpiochip
is passed as chip data to all related functions. Driver callbacks
need to use <a class="reference internal" href="#c.gpiochip_get_data" title="gpiochip_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_get_data()</span></code></a> to get their local state containers back
from the gpiochip passed as chip data. An irqdomain will be stored
in the gpiochip that shall be used by the driver to handle IRQ number
translation. The gpiochip will need to be initialized and registered
before calling this function.</p>
<p>This function will handle two cell:ed simple IRQs and assumes all
the pins on the gpiochip can generate a unique IRQ. Everything else
need to be open coded.</p>
<dl class="function">
<dt id="c.gpiochip_irqchip_add_domain">
int <code class="sig-name descname">gpiochip_irqchip_add_domain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, struct irq_domain *<em> domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irqchip_add_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>adds an irqdomain to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to add the irqchip to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">domain</span></code></dt><dd><p>the irqdomain to add to the gpiochip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds an IRQ domain to the gpiochip.</p>
<dl class="function">
<dt id="c.gpiochip_generic_request">
int <code class="sig-name descname">gpiochip_generic_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request the gpio function for a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip owning the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to request for GPIO function</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_generic_free">
void <code class="sig-name descname">gpiochip_generic_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free the gpio function from a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to request the gpio function for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to free from GPIO function</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_generic_config">
int <code class="sig-name descname">gpiochip_generic_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned<em> offset</em>, unsigned long<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_config" title="Permalink to this definition">¶</a></dt>
<dd><p>apply configuration for a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip owning the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to apply the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">config</span></code></dt><dd><p>the configuration to be applied</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_add_pingroup_range">
int <code class="sig-name descname">gpiochip_add_pingroup_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, struct pinctrl_dev *<em> pctldev</em>, unsigned int<em> gpio_offset</em>, const char *<em> pin_group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pingroup_range" title="Permalink to this definition">¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to add the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pinctrl_dev</span> <span class="pre">*</span> <span class="pre">pctldev</span></code></dt><dd><p>the pin controller to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt><dd><p>the start offset in the current gpio_chip number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin_group</span></code></dt><dd><p>name of the pin group inside the pin controller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the “gpio-ranges” property.</p>
<dl class="function">
<dt id="c.gpiochip_add_pin_range">
int <code class="sig-name descname">gpiochip_add_pin_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, const char *<em> pinctl_name</em>, unsigned int<em> gpio_offset</em>, unsigned int<em> pin_offset</em>, unsigned int<em> npins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pin_range" title="Permalink to this definition">¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the gpiochip to add the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pinctl_name</span></code></dt><dd><p>the dev_name() of the pin controller to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt><dd><p>the start offset in the current gpio_chip number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pin_offset</span></code></dt><dd><p>the start offset in the pin controller number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">npins</span></code></dt><dd><p>the number of pins from the offset of each pin space (GPIO and
pin controller) to accumulate in this range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error-code on failure.</p>
<p><strong>Description</strong></p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the “gpio-ranges” property.</p>
<dl class="function">
<dt id="c.gpiochip_remove_pin_ranges">
void <code class="sig-name descname">gpiochip_remove_pin_ranges</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove_pin_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all the GPIO &lt;-&gt; pin mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the chip to remove all the mappings for</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_is_requested">
const char * <code class="sig-name descname">gpiochip_is_requested</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_is_requested" title="Permalink to this definition">¶</a></dt>
<dd><p>return string iff signal was requested</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>controller managing the signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt><dd><p>of signal within controller’s 0..(ngpio - 1) range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the GPIO is not currently requested, else a string.
The string returned is the label passed to gpio_request(); if none has been
passed it is a meaningless, non-NULL constant.</p>
<p>This function is for use by GPIO controller drivers.  The label can
help with diagnostics, and knowing that the signal is used as a GPIO
can help avoid accidentally multiplexing it to another controller.</p>
<dl class="function">
<dt id="c.gpiochip_request_own_desc">
struct gpio_desc * <code class="sig-name descname">gpiochip_request_own_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned int<em> hwnum</em>, const char *<em> label</em>, enum gpio_lookup_flags<em> lflags</em>, enum gpiod_flags<em> dflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_request_own_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow GPIO chip to request its own descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwnum</span></code></dt><dd><p>hardware number of the GPIO for which to request the descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label for the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpio_lookup_flags</span> <span class="pre">lflags</span></code></dt><dd><p>lookup flags for this GPIO or 0 if default, this can be used to
specify things like line inversion semantics with the machine flags
such as GPIO_OUT_LOW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>descriptor request flags for this GPIO or 0 if default, this
can be used to specify consumer semantics such as open drain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function allows GPIO chip drivers to request and use their own GPIO
descriptors via gpiolib API. Difference to gpiod_request() is that this
function will not increase reference count of the GPIO chip module. This
allows the GPIO chip module to be unloaded as needed (we assume that the
GPIO chip driver handles freeing the GPIOs it has requested).</p>
<p><strong>Return</strong></p>
<p>A pointer to the GPIO descriptor, or an ERR_PTR()-encoded negative error
code on failure.</p>
<dl class="function">
<dt id="c.gpiochip_free_own_desc">
void <code class="sig-name descname">gpiochip_free_own_desc</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_free_own_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GPIO requested by the chip driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO descriptor to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function frees the given GPIO requested previously with
<a class="reference internal" href="#c.gpiochip_request_own_desc" title="gpiochip_request_own_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_request_own_desc()</span></code></a>.</p>
<dl class="function">
<dt id="c.gpiod_direction_input">
int <code class="sig-name descname">gpiod_direction_input</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_input" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to set to input</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to input, such as <a class="reference internal" href="#c.gpiod_get_value" title="gpiod_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_value()</span></code></a> can
be called safely on it.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_direction_output_raw">
int <code class="sig-name descname">gpiod_direction_output_raw</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to set to output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>initial output value of the GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as raw value on the physical line without regard for the ACTIVE_LOW status.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_direction_output">
int <code class="sig-name descname">gpiod_direction_output</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to set to output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>initial output value of the GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_set_config">
int <code class="sig-name descname">gpiod_set_config</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, unsigned long<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <strong>config</strong> for a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>descriptor of the GPIO for which to set the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">config</span></code></dt><dd><p>Same packed config format as generic pinconf</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, <code class="docutils literal notranslate"><span class="pre">-ENOTSUPP</span></code> if the controller doesn’t support setting the
configuration.</p>
<dl class="function">
<dt id="c.gpiod_set_debounce">
int <code class="sig-name descname">gpiod_set_debounce</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, unsigned<em> debounce</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_debounce" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <strong>debounce</strong> time for a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>descriptor of the GPIO for which to set debounce time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">debounce</span></code></dt><dd><p>debounce time in microseconds</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, <code class="docutils literal notranslate"><span class="pre">-ENOTSUPP</span></code> if the controller doesn’t support setting the
debounce time.</p>
<dl class="function">
<dt id="c.gpiod_set_transitory">
int <code class="sig-name descname">gpiod_set_transitory</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, bool<em> transitory</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_transitory" title="Permalink to this definition">¶</a></dt>
<dd><p>Lose or retain GPIO state on suspend or reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>descriptor of the GPIO for which to configure persistence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">transitory</span></code></dt><dd><p>True to lose state on suspend or reset, false for persistence</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, otherwise a negative error code.</p>
<dl class="function">
<dt id="c.gpiod_is_active_low">
int <code class="sig-name descname">gpiod_is_active_low</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_is_active_low" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether a GPIO is active-low or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>the gpio descriptor to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if the GPIO is active-low, 0 otherwise.</p>
<dl class="function">
<dt id="c.gpiod_toggle_active_low">
void <code class="sig-name descname">gpiod_toggle_active_low</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_toggle_active_low" title="Permalink to this definition">¶</a></dt>
<dd><p>toggle whether a GPIO is active-low or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>the gpio descriptor to change</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_get_raw_value">
int <code class="sig-name descname">gpiod_get_raw_value</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_value">
int <code class="sig-name descname">gpiod_get_value</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value">
int <code class="sig-name descname">gpiod_get_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function can be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_array_value">
int <code class="sig-name descname">gpiod_get_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function can be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_value">
void <code class="sig-name descname">gpiod_set_raw_value</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_value">
void <code class="sig-name descname">gpiod_set_value</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW,
OPEN_DRAIN and OPEN_SOURCE flags into account.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value">
int <code class="sig-name descname">gpiod_set_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_array_value">
int <code class="sig-name descname">gpiod_set_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_cansleep">
int <code class="sig-name descname">gpiod_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>report whether gpio value access may sleep</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio to check</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_set_consumer_name">
int <code class="sig-name descname">gpiod_set_consumer_name</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_consumer_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set the consumer name for the descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio to set the consumer name on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the new consumer name</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_to_irq">
int <code class="sig-name descname">gpiod_to_irq</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>return the IRQ corresponding to a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose IRQ will be returned (already requested)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the IRQ corresponding to the passed GPIO, or an error code in case of
error.</p>
<dl class="function">
<dt id="c.gpiochip_lock_as_irq">
int <code class="sig-name descname">gpiochip_lock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_lock_as_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>lock a GPIO to be used as IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the chip the GPIO to lock belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to lock as IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to lock down
a certain GPIO line to be used for IRQs.</p>
<dl class="function">
<dt id="c.gpiochip_unlock_as_irq">
void <code class="sig-name descname">gpiochip_unlock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_unlock_as_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a GPIO used as IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the chip the GPIO to lock belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to lock as IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to indicate
that a certain GPIO is no longer used exclusively for IRQ.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_value_cansleep">
int <code class="sig-name descname">gpiod_get_raw_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_value_cansleep">
int <code class="sig-name descname">gpiod_get_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value_cansleep">
int <code class="sig-name descname">gpiod_get_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_array_value_cansleep">
int <code class="sig-name descname">gpiod_get_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_value_cansleep">
void <code class="sig-name descname">gpiod_set_raw_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_value_cansleep">
void <code class="sig-name descname">gpiod_set_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value_cansleep">
int <code class="sig-name descname">gpiod_set_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_array_value_cansleep">
int <code class="sig-name descname">gpiod_set_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc **<em> desc_array</em>, struct gpio_array *<em> array_info</em>, unsigned long *<em> value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*</span> <span class="pre">array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_add_lookup_table">
void <code class="sig-name descname">gpiod_add_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table *<em> table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><p>register GPIO device consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt><dd><p>table of consumers to register</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_remove_lookup_table">
void <code class="sig-name descname">gpiod_remove_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table *<em> table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_remove_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister GPIO device consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt><dd><p>table of consumers to unregister</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_add_hogs">
void <code class="sig-name descname">gpiod_add_hogs</code><span class="sig-paren">(</span>struct gpiod_hog *<em> hogs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_hogs" title="Permalink to this definition">¶</a></dt>
<dd><p>register a set of GPIO hogs from machine code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_hog</span> <span class="pre">*</span> <span class="pre">hogs</span></code></dt><dd><p>table of gpio hog entries with a zeroed sentinel at the end</p>
</dd>
</dl>
<dl class="function">
<dt id="c.fwnode_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">fwnode_gpiod_get_index</code><span class="sig-paren">(</span>struct fwnode_handle *<em> fwnode</em>, const char *<em> con_id</em>, int<em> index</em>, enum gpiod_flags<em> flags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from firmware node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt><dd><p>handle of the firmware node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used for drivers that get their configuration
from opaque firmware.</p>
<p>The function properly finds the corresponding GPIO using whatever is the
underlying firmware interface and then makes sure that the GPIO
descriptor is requested before it is returned to the caller.</p>
<p>In case of error an ERR_PTR() is returned.</p>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>flags</strong>.</p>
<dl class="function">
<dt id="c.gpiod_count">
int <code class="sig-name descname">gpiod_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_count" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of GPIOs associated with a device / function or -ENOENT if no GPIO has been assigned to the requested function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_get">
struct gpio_desc * <code class="sig-name descname">gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO for a given GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO descriptor corresponding to the function con_id of device
dev, -ENOENT if no GPIO has been assigned to the requested function, or
another IS_ERR() code if an error occurred while trying to acquire the GPIO.</p>
<dl class="function">
<dt id="c.gpiod_get_optional">
struct gpio_desc * <code class="sig-name descname">gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an optional GPIO for a given GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a>, except that when no GPIO was assigned to
the requested function it will return NULL. This is convenient for drivers
that need to handle optional GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, unsigned int<em> idx</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> allows to access GPIOs other than the first
defined one for functions that define several GPIOs.</p>
<p>Return a valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the
requested function and/or index, or another IS_ERR() code if an error
occurred while trying to acquire the GPIO.</p>
<dl class="function">
<dt id="c.fwnode_get_named_gpiod">
struct gpio_desc * <code class="sig-name descname">fwnode_get_named_gpiod</code><span class="sig-paren">(</span>struct fwnode_handle *<em> fwnode</em>, const char *<em> propname</em>, int<em> index</em>, enum gpiod_flags<em> dflags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_get_named_gpiod" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from firmware node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt><dd><p>handle of the firmware node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt><dd><p>name of the firmware property representing the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used for drivers that get their configuration
from opaque firmware.</p>
<p>The function properly finds the corresponding GPIO using whatever is the
underlying firmware interface and then makes sure that the GPIO
descriptor is requested before it is returned to the caller.</p>
<p>In case of error an ERR_PTR() is returned.</p>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<dl class="function">
<dt id="c.gpiod_get_index_optional">
struct gpio_desc * <code class="sig-name descname">gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, unsigned int<em> index</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an optional GPIO from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a>, except that when no GPIO with the
specified index was assigned to the requested function it will return NULL.
This is convenient for drivers that need to handle optional GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_array">
struct gpio_descs * <code class="sig-name descname">gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires all the GPIOs defined under a given function.</p>
<p>Return a struct gpio_descs containing an array of descriptors, -ENOENT if
no GPIO has been assigned to the requested function, or another IS_ERR()
code if an error occurred while trying to acquire the GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_array_optional">
struct gpio_descs * <code class="sig-name descname">gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>, except that when no GPIO was
assigned to the requested function it will return NULL.</p>
<dl class="function">
<dt id="c.gpiod_put">
void <code class="sig-name descname">gpiod_put</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put" title="Permalink to this definition">¶</a></dt>
<dd><p>dispose of a GPIO descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO descriptor to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No descriptor can be used after <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a> has been called on it.</p>
<dl class="function">
<dt id="c.gpiod_put_array">
void <code class="sig-name descname">gpiod_put_array</code><span class="sig-paren">(</span>struct gpio_descs *<em> descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put_array" title="Permalink to this definition">¶</a></dt>
<dd><p>dispose of multiple GPIO descriptors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*</span> <span class="pre">descs</span></code></dt><dd><p>struct gpio_descs containing an array of descriptors</p>
</dd>
</dl>
</div>
<div class="section" id="acpi-support">
<h2>ACPI support<a class="headerlink" href="#acpi-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.acpi_gpiochip_request_interrupts">
void <code class="sig-name descname">acpi_gpiochip_request_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_request_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Register isr for gpio chip ACPI events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
handled by ACPI event methods which need to be called from the GPIO
chip’s interrupt handler. <a class="reference internal" href="#c.acpi_gpiochip_request_interrupts" title="acpi_gpiochip_request_interrupts"><code class="xref c c-func docutils literal notranslate"><span class="pre">acpi_gpiochip_request_interrupts()</span></code></a> finds out which
GPIO pins have ACPI event methods and assigns interrupt handlers that calls
the ACPI event methods for those pins.</p>
<dl class="function">
<dt id="c.acpi_gpiochip_free_interrupts">
void <code class="sig-name descname">acpi_gpiochip_free_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_free_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GPIO ACPI event interrupts.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free interrupts associated with GPIO ACPI event method for the given
GPIO chip.</p>
<dl class="function">
<dt id="c.acpi_dev_gpio_irq_get">
int <code class="sig-name descname">acpi_dev_gpio_irq_get</code><span class="sig-paren">(</span>struct acpi_device *<em> adev</em>, int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_dev_gpio_irq_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Find GpioInt and translate it to Linux IRQ number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>pointer to a ACPI device to get IRQ from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of GpioInt resource (starting from <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device has one or more GpioInt resources, this function can be
used to translate from the GPIO offset in the resource to the Linux IRQ
number.</p>
<p>The function is idempotent, though each time it runs it will configure GPIO
pin direction according to the flags in GpioInt resource.</p>
<p><strong>Return</strong></p>
<p>Linux IRQ number (&gt; <code class="docutils literal notranslate"><span class="pre">0</span></code>) on success, negative errno on failure.</p>
</div>
<div class="section" id="device-tree-support">
<h2>Device tree support<a class="headerlink" href="#device-tree-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.gpiod_get_from_of_node">
struct gpio_desc * <code class="sig-name descname">gpiod_get_from_of_node</code><span class="sig-paren">(</span>struct device_node *<em> node</em>, const char *<em> propname</em>, int<em> index</em>, enum gpiod_flags<em> dflags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_from_of_node" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt><dd><p>handle of the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt><dd><p>name of the DT property representing the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p><strong>Description</strong></p>
<p>In case of error an ERR_PTR() is returned.</p>
<dl class="function">
<dt id="c.of_mm_gpiochip_add_data">
int <code class="sig-name descname">of_mm_gpiochip_add_data</code><span class="sig-paren">(</span>struct device_node *<em> np</em>, struct of_mm_gpio_chip *<em> mm_gc</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add memory mapped GPIO chip (bank)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>device node of the GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*</span> <span class="pre">mm_gc</span></code></dt><dd><p>pointer to the of_mm_gpio_chip allocated structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>driver data to store in the struct gpio_chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To use this function you should allocate and fill mm_gc with:</p>
<ol class="arabic simple">
<li><p>In the gpio_chip structure:
- all the callbacks
- of_gpio_n_cells
- of_xlate callback (optional)</p></li>
</ol>
<ol class="arabic simple" start="3">
<li><p>In the of_mm_gpio_chip structure:
- save_regs callback (optional)</p></li>
</ol>
<p>If succeeded, this function will map bank’s memory and will
do all necessary work for you. Then you’ll able to use .regs
to manage GPIOs from the callbacks.</p>
<dl class="function">
<dt id="c.of_mm_gpiochip_remove">
void <code class="sig-name descname">of_mm_gpiochip_remove</code><span class="sig-paren">(</span>struct of_mm_gpio_chip *<em> mm_gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove memory mapped GPIO chip (bank)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*</span> <span class="pre">mm_gc</span></code></dt><dd><p>pointer to the of_mm_gpio_chip allocated structure</p>
</dd>
</dl>
</div>
<div class="section" id="device-managed-api">
<h2>Device-managed API<a class="headerlink" href="#device-managed-api" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.devm_gpiod_get">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_optional">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a>. GPIO descriptors returned from this function
are automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a> for
detailed information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, unsigned int<em> idx</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_from_of_node">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_from_of_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct device_node *<em> node</em>, const char *<em> propname</em>, int<em> index</em>, enum gpiod_flags<em> dflags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_from_of_node" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for lifecycle management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt><dd><p>handle of the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt><dd><p>name of the DT property representing the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p><strong>Description</strong></p>
<p>In case of error an ERR_PTR() is returned.</p>
<dl class="function">
<dt id="c.devm_fwnode_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">devm_fwnode_gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct fwnode_handle *<em> fwnode</em>, const char *<em> con_id</em>, int<em> index</em>, enum gpiod_flags<em> flags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>get a GPIO descriptor from a given node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt><dd><p>firmware node containing GPIO reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GPIO descriptors returned from this function are automatically disposed on
driver detach.</p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>flags</strong>.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_index_optional">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, unsigned int<em> index</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach. See
<a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a> for detailed information about behavior and
return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_array">
struct gpio_descs * <code class="sig-name descname">devm_gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_array_optional">
struct gpio_descs * <code class="sig-name descname">devm_gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach.
See <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a> for detailed information about behavior and
return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_put">
void <code class="sig-name descname">devm_gpiod_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO descriptor to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of a GPIO descriptor obtained with <a class="reference internal" href="#c.devm_gpiod_get" title="devm_gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get()</span></code></a> or
<a class="reference internal" href="#c.devm_gpiod_get_index" title="devm_gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get_index()</span></code></a>. Normally this function will not be called as the GPIO
will be disposed of by the resource management code.</p>
<dl class="function">
<dt id="c.devm_gpiod_unhinge">
void <code class="sig-name descname">devm_gpiod_unhinge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_unhinge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove resource management from a gpio descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO descriptor to remove resource management from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove resource management from a GPIO descriptor. This is needed when
you want to hand over lifecycle management of a descriptor to another
mechanism.</p>
<dl class="function">
<dt id="c.devm_gpiod_put_array">
void <code class="sig-name descname">devm_gpiod_put_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct gpio_descs *<em> descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put_array" title="gpiod_put_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put_array()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*</span> <span class="pre">descs</span></code></dt><dd><p>GPIO descriptor array to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of an array of GPIO descriptors obtained with <a class="reference internal" href="#c.devm_gpiod_get_array" title="devm_gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get_array()</span></code></a>.
Normally this function will not be called as the GPIOs will be disposed of
by the resource management code.</p>
<dl class="function">
<dt id="c.devm_gpio_request">
int <code class="sig-name descname">devm_gpio_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, unsigned<em> gpio</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request a GPIO for a managed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to request the GPIO for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>GPIO to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>the name of the requested GPIO</p>
<p>Except for the extra <strong>dev</strong> argument, this function takes the
same arguments and performs the same function as
gpio_request().  GPIOs requested with this function will be
automatically freed on driver detach.</p>
<p>If an GPIO allocated with this function needs to be freed
separately, <a class="reference internal" href="#c.devm_gpio_free" title="devm_gpio_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpio_free()</span></code></a> must be used.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_gpio_request_one">
int <code class="sig-name descname">devm_gpio_request_one</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, unsigned<em> gpio</em>, unsigned long<em> flags</em>, const char *<em> label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request_one" title="Permalink to this definition">¶</a></dt>
<dd><p>request a single GPIO with initial setup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to request for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>the GPIO number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>GPIO configuration as specified by GPIOF_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt><dd><p>a literal description string of this GPIO</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_gpio_free">
void <code class="sig-name descname">devm_gpio_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, unsigned int<em> gpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to free GPIO for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio</span></code></dt><dd><p>GPIO to free</p>
<p>Except for the extra <strong>dev</strong> argument, this function takes the
same arguments and performs the same function as gpio_free().
This function instead of gpio_free() should be used to manually
free GPIOs allocated with <a class="reference internal" href="#c.devm_gpio_request" title="devm_gpio_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpio_request()</span></code></a>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_gpiochip_add_data">
int <code class="sig-name descname">devm_gpiochip_add_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em> gc</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiochip_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource managed <a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to the device that gpio_chip belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt><dd><p>the GPIO chip to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>driver-private data associated with this chip</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>The gpio chip automatically be released when the device is unbound.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can’t be registered, such as because the
gc-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
</div>
<div class="section" id="sysfs-helpers">
<h2>sysfs helpers<a class="headerlink" href="#sysfs-helpers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.gpiod_export">
int <code class="sig-name descname">gpiod_export</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em>, bool<em> direction_may_change</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export" title="Permalink to this definition">¶</a></dt>
<dd><p>export a GPIO through sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to make available, already requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">direction_may_change</span></code></dt><dd><p>true if userspace may change GPIO direction</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>arch_initcall or later</p>
<p><strong>Description</strong></p>
<p>When drivers want to make a GPIO accessible to userspace after they
have requested it – perhaps while debugging, or as part of their
public interface – they may use this routine.  If the GPIO can
change direction (some can’t) and the caller allows it, userspace
will see “direction” sysfs attribute which may be used to change
the gpio’s direction.  A “value” attribute will always be provided.</p>
<p>Returns zero on success, else an error.</p>
<dl class="function">
<dt id="c.gpiod_export_link">
int <code class="sig-name descname">gpiod_export_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> name</em>, struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a sysfs link to an exported GPIO node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device under which to create symlink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of the symlink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to create symlink to, already exported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up a symlink from /sys/…/dev/name to /sys/class/gpio/gpioN
node. Caller is responsible for unlinking.</p>
<p>Returns zero on success, else an error.</p>
<dl class="function">
<dt id="c.gpiod_unexport">
void <code class="sig-name descname">gpiod_unexport</code><span class="sig-paren">(</span>struct gpio_desc *<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_unexport" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of <a class="reference internal" href="#c.gpiod_export" title="gpiod_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_export()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>GPIO to make unavailable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is implicit on gpiod_free().</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="intro.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../pinctl.html" class="btn btn-neutral float-left" title="PINCTRL (PIN CONTROL) subsystem" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>