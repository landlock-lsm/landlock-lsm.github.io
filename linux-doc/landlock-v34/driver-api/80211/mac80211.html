

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>mac80211 subsystem (basics) &mdash; The Linux Kernel 5.12.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="mac80211 subsystem (advanced)" href="mac80211-advanced.html" />
    <link rel="prev" title="cfg80211 subsystem" href="cfg80211.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.12.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux 802.11 Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="cfg80211.html">cfg80211 subsystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">mac80211 subsystem (basics)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-hardware-handling">Basic hardware handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phy-configuration">PHY configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtual-interfaces">Virtual interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receive-and-transmit-processing">Receive and transmit processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frame-filtering">Frame filtering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-mac80211-workqueue">The mac80211 workqueue</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mac80211-advanced.html">mac80211 subsystem (advanced)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux 802.11 Driver Developer’s Guide</a> &raquo;</li>
        
      <li>mac80211 subsystem (basics)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/80211/mac80211.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mac80211-subsystem-basics">
<h1>mac80211 subsystem (basics)<a class="headerlink" href="#mac80211-subsystem-basics" title="Permalink to this headline">¶</a></h1>
<p>You should read and understand the information contained within this
part of the book while implementing a mac80211 driver. In some chapters,
advanced usage is noted, those may be skipped if this isn’t needed.</p>
<p>This part of the book only covers station and monitor mode
functionality, additional information required to implement the other
modes is covered in the second part of the book.</p>
<div class="section" id="basic-hardware-handling">
<h2>Basic hardware handling<a class="headerlink" href="#basic-hardware-handling" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>This chapter shall contain information on getting a hw struct allocated
and registered with mac80211.</p>
<p>Since it is required to allocate rates/modes before registering a hw
struct, this chapter shall also contain information on setting up the
rate/mode structs.</p>
<p>Additionally, some discussion about the callbacks and the general
programming model should be in here, including the definition of
ieee80211_ops which will be referred to a lot.</p>
<p>Finally, a discussion of hardware capabilities should be done with
references to other parts of the book.</p>
<dl class="c enum">
<dt id="c.ieee80211_hw_flags">
<em class="property">enum </em><code class="sig-name descname">ieee80211_hw_flags</code><a class="headerlink" href="#c.ieee80211_hw_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hardware flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_HAS_RATE_CONTROL</span></code></dt><dd><p>The hardware or firmware includes rate control, and cannot be
controlled by the stack. As such, no rate control algorithm
should be instantiated, and the TX rate reported to userspace
will be taken from the TX status instead of the rate control
algorithm.
Note that this requires that the driver implement a number of
callbacks so it has the correct information, it needs to have
the <strong>set_rts_threshold</strong> callback and must look at the BSS config
<strong>use_cts_prot</strong> for G/N protection, <strong>use_short_slot</strong> for slot
timing in 2.4 GHz and <strong>use_short_preamble</strong> for preambles for
CCK frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_RX_INCLUDES_FCS</span></code></dt><dd><p>Indicates that received frames passed to the stack include
the FCS at the end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING</span></code></dt><dd><p>Some wireless LAN chipsets buffer broadcast/multicast frames
for power saving stations in the hardware/firmware and others
rely on the host system for such buffering. This option is used
to configure the IEEE 802.11 upper layer to buffer broadcast and
multicast frames when there are power saving stations so that
the driver can fetch them with <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_get_buffered_bc" title="ieee80211_get_buffered_bc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_get_buffered_bc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SIGNAL_UNSPEC</span></code></dt><dd><p>Hardware can provide signal values but we don’t know its units. We
expect values between 0 and <strong>max_signal</strong>.
If possible please provide dB or dBm instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SIGNAL_DBM</span></code></dt><dd><p>Hardware gives signal values in dBm, decibel difference from
one milliwatt. This is the preferred method since it is standardized
between different devices. <strong>max_signal</strong> does not need to be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC</span></code></dt><dd><p>This device needs to get data from beacon before association (i.e.
dtim_period).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SPECTRUM_MGMT</span></code></dt><dd><p>Hardware supports spectrum management defined in 802.11h
Measurement, Channel Switch, Quieting, TPC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AMPDU_AGGREGATION</span></code></dt><dd><p>Hardware supports 11n A-MPDU aggregation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_PS</span></code></dt><dd><p>Hardware has power save support (i.e. can go to sleep).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_PS_NULLFUNC_STACK</span></code></dt><dd><p>Hardware requires nullfunc frame handling in stack, implies
stack support for dynamic PS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_DYNAMIC_PS</span></code></dt><dd><p>Hardware has support for dynamic PS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_MFP_CAPABLE</span></code></dt><dd><p>Hardware supports management frame protection (MFP, IEEE 802.11w).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_WANT_MONITOR_VIF</span></code></dt><dd><p>The driver would like to be informed of
a virtual monitor interface when monitor interfaces are the only
active interfaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_NO_AUTO_VIF</span></code></dt><dd><p>The driver would like for no wlanX to
be created.  It is expected user-space will create vifs as
desired (and thus have them named as desired).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SW_CRYPTO_CONTROL</span></code></dt><dd><p>The driver wants to control which of the
crypto algorithms can be done in software - so don’t automatically
try to fall back to it if hardware crypto fails, but do so only if
the driver returns 1. This also forces the driver to advertise its
supported cipher suites.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORT_FAST_XMIT</span></code></dt><dd><p>The driver/hardware supports fast-xmit,
this currently requires only the ability to calculate the duration
for frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_REPORTS_TX_ACK_STATUS</span></code></dt><dd><p>Hardware can provide ack status reports of Tx frames to
the stack.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_CONNECTION_MONITOR</span></code></dt><dd><p>The hardware performs its own connection monitoring, including
periodic keep-alives to the AP and probing the AP on beacon loss.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_QUEUE_CONTROL</span></code></dt><dd><p>The driver wants to control per-interface
queue mapping in order to use different queues (not just one per AC)
for different virtual interfaces. See the doc section on HW queue
control for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_PER_STA_GTK</span></code></dt><dd><p>The device’s crypto engine supports
per-station GTKs as used by IBSS RSN or during fast transition. If
the device doesn’t support per-station GTKs, but can be asked not
to decrypt group addressed frames, then IBSS RSN support is still
possible but software crypto will be used. Advertise the wiphy flag
only in that case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AP_LINK_PS</span></code></dt><dd><p>When operating in AP mode the device
autonomously manages the PS status of connected stations. When
this flag is set mac80211 will not trigger PS mode for connected
stations based on the PM bit of incoming frames.
Use ieee80211_start_ps()/ieee8021_end_ps() to manually configure
the PS mode of connected stations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TX_AMPDU_SETUP_IN_HW</span></code></dt><dd><p>The device handles TX A-MPDU session
setup strictly in HW. mac80211 should not attempt to do this in
software.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_RC_TABLE</span></code></dt><dd><p>The driver supports using a rate
selection table provided by the rate control algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF</span></code></dt><dd><p>Use the P2P Device address for any
P2P Interface. This will be honoured even if more than one interface
is supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TIMING_BEACON_ONLY</span></code></dt><dd><p>Use sync timing from beacon frames
only, to allow getting TBTT of a DTIM beacon.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_HT_CCK_RATES</span></code></dt><dd><p>Hardware supports mixing HT/CCK rates
and can cope with CCK rates in an aggregation session (e.g. by not
using aggregation for such frames.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_CHANCTX_STA_CSA</span></code></dt><dd><p>Support 802.11h based channel-switch (CSA)
for a single active channel while using channel contexts. When support
is not enabled the default action is to disconnect when getting the
CSA frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_CLONED_SKBS</span></code></dt><dd><p>The driver will never modify the payload
or tailroom of TX skbs without copying them first.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS</span></code></dt><dd><p>The HW supports scanning on all bands
in one command, mac80211 doesn’t have to run separate scans per band.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TDLS_WIDER_BW</span></code></dt><dd><p>The device/driver supports wider bandwidth
than then BSS bandwidth for a TDLS link on the base channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU</span></code></dt><dd><p>The driver supports receiving A-MSDUs
within A-MPDU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_BEACON_TX_STATUS</span></code></dt><dd><p>The device/driver provides TX status
for sent beacons.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR</span></code></dt><dd><p>Hardware (or driver) requires that each
station has a unique address, i.e. each station entry can be identified
by just its MAC address; this prevents, for example, the same station
from connecting to two virtual AP interfaces at the same time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_REORDERING_BUFFER</span></code></dt><dd><p>Hardware (or driver) manages the
reordering buffer internally, guaranteeing mac80211 receives frames in
order and does not need to manage its own reorder buffer or BA session
timeout.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_USES_RSS</span></code></dt><dd><p>The device uses RSS and thus requires parallel RX,
which implies using per-CPU station statistics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TX_AMSDU</span></code></dt><dd><p>Hardware (or driver) supports software aggregated
A-MSDU frames. Requires software tx queueing and fast-xmit support.
When not using minstrel/minstrel_ht rate control, the driver must
limit the maximum A-MSDU size based on the current tx rate by setting
max_rc_amsdu_len in <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_sta" title="ieee80211_sta"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TX_FRAG_LIST</span></code></dt><dd><p>Hardware (or driver) supports sending frag_list
skbs, needed for zero-copy software A-MSDU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_REPORTS_LOW_ACK</span></code></dt><dd><p>The driver (or firmware) reports low ack event
by ieee80211_report_low_ack() based on its own algorithm. For such
drivers, mac80211 packet loss mechanism will not be triggered and driver
is completely depending on firmware event for station kickout.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_TX_FRAG</span></code></dt><dd><p>Hardware does fragmentation by itself.
The stack will not do fragmentation.
The callback for <strong>set_frag_threshold</strong> should be set as well.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA</span></code></dt><dd><p>Hardware supports buffer STA on
TDLS links.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP</span></code></dt><dd><p>The driver requires the
mgd_prepare_tx() callback to be called before transmission of a
deauthentication frame in case the association was completed but no
beacon was heard. This is required in multi-channel scenarios, where the
virtual interface might not be given air time for the transmission of
the frame, as it is not synced with the AP/P2P GO yet, and thus the
deauthentication frame might not be transmitted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP</span></code></dt><dd><p>The driver (or firmware) doesn’t
support QoS NDP for AP probing - that’s most likely a driver bug.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_BUFF_MMPDU_TXQ</span></code></dt><dd><p>use the TXQ for bufferable MMPDUs, this of
course requires the driver to use TXQs to start with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW</span></code></dt><dd><p>(Hardware) rate control supports VHT
extended NSS BW (dot11VHTExtendedNSSBWCapable). This flag will be set if
the selected rate control algorithm sets <code class="docutils literal notranslate"><span class="pre">RATE_CTRL_CAPA_VHT_EXT_NSS_BW</span></code>
but if the rate control is built-in then it must be set by the driver.
See also the documentation for that flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_STA_MMPDU_TXQ</span></code></dt><dd><p>use the extra non-TID per-station TXQ for all
MMPDUs on station interfaces. This of course requires the driver to use
TXQs to start with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN</span></code></dt><dd><p>Driver does not report accurate A-MPDU
length in tx status information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_MULTI_BSSID</span></code></dt><dd><p>Hardware supports multi BSSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID</span></code></dt><dd><p>Hardware supports multi BSSID
only for HE APs. Applies if <strong>IEEE80211_HW_SUPPORTS_MULTI_BSSID</strong> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT</span></code></dt><dd><p>The card and driver is only
aggregating MPDUs with the same keyid, allowing mac80211 to keep Tx
A-MPDU sessions active while rekeying with Extended Key ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD</span></code></dt><dd><p>Hardware supports tx encapsulation
offload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD</span></code></dt><dd><p>Hardware supports rx decapsulation
offload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUM_IEEE80211_HW_FLAGS</span></code></dt><dd><p>number of hardware flags, used for sizing arrays</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags are used to indicate hardware capabilities to
the stack. Generally, flags here should have their meaning
done in a way that the simplest hardware doesn’t need setting
any particular flags. There are some exceptions to this rule,
however, so you are advised to review these flags carefully.</p>
<dl class="c struct">
<dt id="c.ieee80211_hw">
<em class="property">struct </em><code class="sig-name descname">ieee80211_hw</code><a class="headerlink" href="#c.ieee80211_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hardware information and state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_hw {
  struct ieee80211_conf conf;
  struct wiphy *wiphy;
  const char *rate_control_algorithm;
  void *priv;
  unsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];
  unsigned int extra_tx_headroom;
  unsigned int extra_beacon_tailroom;
  int vif_data_size;
  int sta_data_size;
  int chanctx_data_size;
  int txq_data_size;
  u16 queues;
  u16 max_listen_interval;
  s8 max_signal;
  u8 max_rates;
  u8 max_report_rates;
  u8 max_rate_tries;
  u16 max_rx_aggregation_subframes;
  u16 max_tx_aggregation_subframes;
  u8 max_tx_fragments;
  u8 offchannel_tx_hw_queue;
  u8 radiotap_mcs_details;
  u16 radiotap_vht_details;
  struct {
    int units_pos;
    s16 accuracy;
  } radiotap_timestamp;
  netdev_features_t netdev_features;
  u8 uapsd_queues;
  u8 uapsd_max_sp_len;
  u8 n_cipher_schemes;
  const struct ieee80211_cipher_scheme *cipher_schemes;
  u8 max_nan_de_entries;
  u8 tx_sk_pacing_shift;
  u8 weight_multiplier;
  u32 max_mtu;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">conf</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_conf" title="ieee80211_conf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_conf</span></code></a>, device configuration, don’t use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wiphy</span></code></dt><dd><p>This points to the <a class="reference internal" href="cfg80211.html#c.wiphy" title="wiphy"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span></code></a> allocated for this
802.11 PHY. You must fill in the <strong>perm_addr</strong> and <strong>dev</strong>
members of this structure using <a class="reference internal" href="#c.SET_IEEE80211_DEV" title="SET_IEEE80211_DEV"><code class="xref c c-func docutils literal notranslate"><span class="pre">SET_IEEE80211_DEV()</span></code></a>
and <a class="reference internal" href="#c.SET_IEEE80211_PERM_ADDR" title="SET_IEEE80211_PERM_ADDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">SET_IEEE80211_PERM_ADDR()</span></code></a>. Additionally, all supported
bands (with channels, bitrates) are registered here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_control_algorithm</span></code></dt><dd><p>rate control algorithm for this hardware.
If unset (NULL), the default algorithm will be used. Must be
set before calling <a class="reference internal" href="#c.ieee80211_register_hw" title="ieee80211_register_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_register_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>pointer to private area that was allocated for driver use
along with this structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>hardware flags, see <a class="reference internal" href="#c.ieee80211_hw_flags" title="ieee80211_hw_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_hw_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra_tx_headroom</span></code></dt><dd><p>headroom to reserve in each transmit skb
for use by the driver (e.g. for transmit headers.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra_beacon_tailroom</span></code></dt><dd><p>tailroom to reserve in each beacon tx skb.
Can be used by drivers to add extra IEs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vif_data_size</span></code></dt><dd><p>size (in bytes) of the drv_priv data area
within <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_data_size</span></code></dt><dd><p>size (in bytes) of the drv_priv data area
within <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_sta" title="ieee80211_sta"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chanctx_data_size</span></code></dt><dd><p>size (in bytes) of the drv_priv data area
within <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_chanctx_conf</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq_data_size</span></code></dt><dd><p>size (in bytes) of the drv_priv data area
within <strong>struct</strong> ieee80211_txq.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queues</span></code></dt><dd><p>number of available hardware transmit queues for
data packets. WMM/QoS requires at least four, these
queues need to have configurable access parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_listen_interval</span></code></dt><dd><p>max listen interval in units of beacon interval
that HW supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_signal</span></code></dt><dd><p>Maximum value for signal (rssi) in RX information, used
only when <strong>IEEE80211_HW_SIGNAL_UNSPEC</strong> or <strong>IEEE80211_HW_SIGNAL_DB</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_rates</span></code></dt><dd><p>maximum number of alternate rate retry stages the hw
can handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_report_rates</span></code></dt><dd><p>maximum number of alternate rate retry stages
the hw can report back.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_rate_tries</span></code></dt><dd><p>maximum number of tries for each stage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_rx_aggregation_subframes</span></code></dt><dd><p>maximum buffer size (number of
sub-frames) to be used for A-MPDU block ack receiver
aggregation.
This is only relevant if the device has restrictions on the
number of subframes, if it relies on mac80211 to do reordering
it shouldn’t be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_tx_aggregation_subframes</span></code></dt><dd><p>maximum number of subframes in an
aggregate an HT/HE device will transmit. In HT AddBA we’ll
advertise a constant value of 64 as some older APs crash if
the window size is smaller (an example is LinkSys WRT120N
with FW v1.0.07 build 002 Jun 18 2012).
For AddBA to HE capable peers this value will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_tx_fragments</span></code></dt><dd><p>maximum number of tx buffers per (A)-MSDU, sum
of 1 + skb_shinfo(skb)-&gt;nr_frags for each skb in the frag_list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offchannel_tx_hw_queue</span></code></dt><dd><p>HW queue ID to use for offchannel TX
(if <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_QUEUE_CONTROL</span></code> is set)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radiotap_mcs_details</span></code></dt><dd><p>lists which MCS information can the HW
reports, by default it is set to _MCS, _GI and _BW but doesn’t
include _FMT. Use <code class="docutils literal notranslate"><span class="pre">IEEE80211_RADIOTAP_MCS_HAVE_</span></code>* values, only
adding _BW is supported today.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radiotap_vht_details</span></code></dt><dd><p>lists which VHT MCS information the HW reports,
the default is _GI | _BANDWIDTH.
Use the <code class="docutils literal notranslate"><span class="pre">IEEE80211_RADIOTAP_VHT_KNOWN_</span></code>* values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radiotap_timestamp</span></code></dt><dd><p>Information for the radiotap timestamp field; if the
<strong>units_pos</strong> member is set to a non-negative value then the timestamp
field will be added and populated from the <a class="reference internal" href="#c.ieee80211_rx_status" title="ieee80211_rx_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_rx_status</span></code></a>
device_timestamp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radiotap_timestamp.units_pos</span></code></dt><dd><p>Must be set to a combination of a
IEEE80211_RADIOTAP_TIMESTAMP_UNIT_* and a
IEEE80211_RADIOTAP_TIMESTAMP_SPOS_* value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radiotap_timestamp.accuracy</span></code></dt><dd><p>If non-negative, fills the accuracy in the
radiotap field and the accuracy known flag will be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features</span></code></dt><dd><p>netdev features to be set in each netdev created
from this HW. Note that not all features are usable with mac80211,
other features will be rejected during HW registration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uapsd_queues</span></code></dt><dd><p>This bitmap is included in (re)association frame to indicate
for each access category if it is uAPSD trigger-enabled and delivery-
enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.
Each bit corresponds to different AC. Value ‘1’ in specific bit means
that corresponding AC is both trigger- and delivery-enabled. ‘0’ means
neither enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uapsd_max_sp_len</span></code></dt><dd><p>maximum number of total buffered frames the WMM AP may
deliver to a WMM STA during any Service Period triggered by the WMM STA.
Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_cipher_schemes</span></code></dt><dd><p>a size of an array of cipher schemes definitions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cipher_schemes</span></code></dt><dd><p>a pointer to an array of cipher scheme definitions
supported by HW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_nan_de_entries</span></code></dt><dd><p>maximum number of NAN DE functions supported by the
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_sk_pacing_shift</span></code></dt><dd><p>Pacing shift to set on TCP sockets when frames from
them are encountered. The default should typically not be changed,
unless the driver has good reasons for needing more buffers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">weight_multiplier</span></code></dt><dd><p>Driver specific airtime weight multiplier used while
refilling deficit of each TXQ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_mtu</span></code></dt><dd><p>the max mtu could be set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure contains the configuration and hardware
information for an 802.11 PHY.</p>
<dl class="c function">
<dt id="c.SET_IEEE80211_DEV">
void <code class="sig-name descname">SET_IEEE80211_DEV</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.SET_IEEE80211_DEV" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set device for 802.11 hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span></code></a> to set the device for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of this 802.11 device</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.SET_IEEE80211_PERM_ADDR">
void <code class="sig-name descname">SET_IEEE80211_PERM_ADDR</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">const</em> u8 *<em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.SET_IEEE80211_PERM_ADDR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the permanent MAC address for 802.11 hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span></code></a> to set the MAC address for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>the address to set</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.ieee80211_ops">
<em class="property">struct </em><code class="sig-name descname">ieee80211_ops</code><a class="headerlink" href="#c.ieee80211_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>callbacks from mac80211 to the driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_ops {
  void (*tx)(struct ieee80211_hw *hw,struct ieee80211_tx_control *control, struct sk_buff *skb);
  int (*start)(struct ieee80211_hw *hw);
  void (*stop)(struct ieee80211_hw *hw);
#ifdef CONFIG_PM;
  int (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
  int (*resume)(struct ieee80211_hw *hw);
  void (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);
#endif;
  int (*add_interface)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*change_interface)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, enum nl80211_iftype new_type, bool p2p);
  void (*remove_interface)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*config)(struct ieee80211_hw *hw, u32 changed);
  void (*bss_info_changed)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_bss_conf *info, u32 changed);
  int (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u64 (*prepare_multicast)(struct ieee80211_hw *hw, struct netdev_hw_addr_list *mc_list);
  void (*configure_filter)(struct ieee80211_hw *hw,unsigned int changed_flags,unsigned int *total_flags, u64 multicast);
  void (*config_iface_filter)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,unsigned int filter_flags, unsigned int changed_flags);
  int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set);
  int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key);
  void (*update_tkip_key)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct ieee80211_sta *sta, u32 iv32, u16 *phase1key);
  void (*set_rekey_data)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_gtk_rekey_data *data);
  void (*set_default_unicast_key)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int idx);
  int (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_scan_request *req);
  void (*cancel_hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*sched_scan_start)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_sched_scan_request *req, struct ieee80211_scan_ies *ies);
  int (*sched_scan_stop)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*sw_scan_start)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, const u8 *mac_addr);
  void (*sw_scan_complete)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*get_stats)(struct ieee80211_hw *hw, struct ieee80211_low_level_stats *stats);
  void (*get_key_seq)(struct ieee80211_hw *hw,struct ieee80211_key_conf *key, struct ieee80211_key_seq *seq);
  int (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);
  int (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);
  int (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta);
  int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS;
  void (*sta_add_debugfs)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, struct dentry *dir);
#endif;
  void (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, enum sta_notify_cmd, struct ieee80211_sta *sta);
  int (*sta_set_txpwr)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta);
  int (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta,enum ieee80211_sta_state old_state, enum ieee80211_sta_state new_state);
  void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta);
  void (*sta_rc_update)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, u32 changed);
  void (*sta_rate_tbl_update)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta);
  void (*sta_statistics)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, struct station_info *sinfo);
  int (*conf_tx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 ac, const struct ieee80211_tx_queue_params *params);
  u64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u64 tsf);
  void (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, s64 offset);
  void (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*tx_last_beacon)(struct ieee80211_hw *hw);
  int (*ampdu_action)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_ampdu_params *params);
  int (*get_survey)(struct ieee80211_hw *hw, int idx, struct survey_info *survey);
  void (*rfkill_poll)(struct ieee80211_hw *hw);
  void (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE;
  int (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, void *data, int len);
  int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,struct netlink_callback *cb, void *data, int len);
#endif;
  void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u32 queues, bool drop);
  void (*channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_channel_switch *ch_switch);
  int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
  int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
  int (*remain_on_channel)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel *chan,int duration, enum ieee80211_roc_type type);
  int (*cancel_remain_on_channel)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);
  void (*get_ringparam)(struct ieee80211_hw *hw, u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  bool (*tx_frames_pending)(struct ieee80211_hw *hw);
  int (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, const struct cfg80211_bitrate_mask *mask);
  void (*event_callback)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, const struct ieee80211_event *event);
  void (*allow_buffered_frames)(struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason, bool more_data);
  void (*release_buffered_frames)(struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason, bool more_data);
  int (*get_et_sset_count)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int sset);
  void (*get_et_stats)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ethtool_stats *stats, u64 *data);
  void (*get_et_strings)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u32 sset, u8 *data);
  void (*mgd_prepare_tx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 duration);
  void (*mgd_protect_tdls_discover)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*add_chanctx)(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *ctx);
  void (*remove_chanctx)(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *ctx);
  void (*change_chanctx)(struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx, u32 changed);
  int (*assign_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_chanctx_conf *ctx);
  void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_chanctx_conf *ctx);
  int (*switch_vif_chanctx)(struct ieee80211_hw *hw,struct ieee80211_vif_chanctx_switch *vifs,int n_vifs, enum ieee80211_chanctx_switch_mode mode);
  void (*reconfig_complete)(struct ieee80211_hw *hw, enum ieee80211_reconfig_type reconfig_type);
#if IS_ENABLED(CONFIG_IPV6);
  void (*ipv6_addr_change)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct inet6_dev *idev);
#endif;
  void (*channel_switch_beacon)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_chan_def *chandef);
  int (*pre_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_channel_switch *ch_switch);
  int (*post_channel_switch)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*abort_channel_switch)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_channel_switch *ch_switch);
  int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u32 (*get_expected_throughput)(struct ieee80211_hw *hw, struct ieee80211_sta *sta);
  int (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int *dbm);
  int (*tdls_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, u8 oper_class,struct cfg80211_chan_def *chandef, struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);
  void (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta);
  void (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_tdls_ch_sw_params *params);
  void (*wake_tx_queue)(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
  void (*sync_rx_queues)(struct ieee80211_hw *hw);
  int (*start_nan)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_nan_conf *conf);
  int (*stop_nan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (*nan_change_conf)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_nan_conf *conf, u32 changes);
  int (*add_nan_func)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, const struct cfg80211_nan_func *nan_func);
  void (*del_nan_func)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, u8 instance_id);
  bool (*can_aggregate_in_amsdu)(struct ieee80211_hw *hw,struct sk_buff *head, struct sk_buff *skb);
  int (*get_ftm_responder_stats)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_ftm_responder_stats *ftm_stats);
  int (*start_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct cfg80211_pmsr_request *request);
  void (*abort_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct cfg80211_pmsr_request *request);
  int (*set_tid_config)(struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta, struct cfg80211_tid_config *tid_conf);
  int (*reset_tid_config)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta, u8 tids);
  void (*update_vif_offload)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta, bool enabled);
  int (*set_sar_specs)(struct ieee80211_hw *hw, const struct cfg80211_sar_specs *sar);
  void (*sta_set_decap_offload)(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_sta *sta, bool enabled);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">tx</span></code></dt><dd><p>Handler that 802.11 module calls for each transmitted frame.
skb contains the buffer starting from the IEEE 802.11 header.
The low-level driver should send the frame out based on
configuration in the TX control data. This handler should,
preferably, never fail and stop queues appropriately.
Must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Called before the first netdevice attached to the hardware
is enabled. This should turn on the hardware and must turn on
frame reception (for possibly enabled monitor interfaces.)
Returns negative error codes, these may be seen in userspace,
or zero.
When the device is started it should not have a MAC address
to avoid acknowledging frames before a non-monitor device
is added.
Must be implemented and can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop</span></code></dt><dd><p>Called after last netdevice attached to the hardware
is disabled. This should turn off the hardware (at least
it must turn off frame reception.)
May be called right after add_interface if that rejects
an interface. If you added any work onto the mac80211 workqueue
you should ensure to cancel it on this callback.
Must be implemented and can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Suspend the device; mac80211 itself will quiesce before and
stop transmitting and doing any other configuration, and then
ask the device to suspend. This is only invoked when WoWLAN is
configured, otherwise the device is deconfigured completely and
reconfigured at resume time.
The driver may also impose special conditions under which it
wants to use the “normal” suspend (deconfigure), say if it only
supports WoWLAN when the device is associated. In this case, it
must return 1 from this function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>If WoWLAN was configured, this indicates that mac80211 is
now resuming its operation, after this the device must be fully
functional again. If this returns an error, the only way out is
to also unregister the device. If it returns 1, then mac80211
will also go through the regular complete restart on resume.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_wakeup</span></code></dt><dd><p>Enable or disable wakeup when WoWLAN configuration is
modified. The reason is that device_set_wakeup_enable() is
supposed to be called when the configuration changes, not only
in suspend().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_interface</span></code></dt><dd><p>Called when a netdevice attached to the hardware is
enabled. Because it is not called for monitor mode devices, <strong>start</strong>
and <strong>stop</strong> must be implemented.
The driver should perform any initialization it needs before
the device can be enabled. The initial configuration for the
interface is given in the conf parameter.
The callback may refuse to add an interface by returning a
negative error code (which will be seen in userspace.)
Must be implemented and can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_interface</span></code></dt><dd><p>Called when a netdevice changes type. This callback
is optional, but only if it is supported can interface types be
switched while the interface is UP. The callback may sleep.
Note that while an interface is being switched, it will not be
found by the interface iteration callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove_interface</span></code></dt><dd><p>Notifies a driver that an interface is going down.
The <strong>stop</strong> callback is called after this if it is the last interface
and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the hardware
must be cleared so the device no longer acknowledges packets,
the mac_addr member of the conf structure is, however, set to the
MAC address of the device going away.
Hence, this callback must be implemented. It can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>Handler for configuration requests. IEEE 802.11 code calls this
function to change hardware configuration, e.g., channel.
This function should never fail but returns a negative error code
if it does. The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_info_changed</span></code></dt><dd><p>Handler for configuration requests related to BSS
parameters that may vary during BSS’s lifespan, and may affect low
level driver (e.g. assoc/disassoc status, erp parameters).
This function should not be used if no BSS has been set, unless
for association indication. The <strong>changed</strong> parameter indicates which
of the bss parameters has changed when a call is made. The callback
can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_ap</span></code></dt><dd><p>Start operation on the AP interface, this is called after all the
information in bss_conf is set and beacon can be retrieved. A channel
context is bound before this is called. Note that if the driver uses
software scan or ROC, this (and <strong>stop_ap</strong>) isn’t called when the AP is
just “paused” for scanning/ROC, which is indicated by the beacon being
disabled/enabled via <strong>bss_info_changed</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_ap</span></code></dt><dd><p>Stop operation on the AP interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_multicast</span></code></dt><dd><p>Prepare for multicast filter configuration.
This callback is optional, and its return value is passed
to configure_filter(). This callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">configure_filter</span></code></dt><dd><p>Configure the device’s RX filter.
See the section “Frame filtering” for more information.
This callback must be implemented and can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_iface_filter</span></code></dt><dd><p>Configure the interface’s RX filter.
This callback is optional and is used to configure which frames
should be passed to mac80211. The filter_flags is the combination
of FIF_* flags. The changed_flags is a bit mask that indicates
which flags are changed.
This callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tim</span></code></dt><dd><p>Set TIM bit. mac80211 calls this function when a TIM bit
must be set or cleared for a given STA. Must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_key</span></code></dt><dd><p>See the section “Hardware crypto acceleration”
This callback is only called between add_interface and
remove_interface calls, i.e. while the given virtual interface
is enabled.
Returns a negative error code if the key can’t be added.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_tkip_key</span></code></dt><dd><p>See the section “Hardware crypto acceleration”
This callback will be called in the context of Rx. Called for drivers
which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
The callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_rekey_data</span></code></dt><dd><p>If the device supports GTK rekeying, for example while the
host is suspended, it can assign this callback to retrieve the data
necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
After rekeying was done it should (for example during resume) notify
userspace of the new replay counter using ieee80211_gtk_rekey_notify().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_default_unicast_key</span></code></dt><dd><p>Set the default (unicast) key index, useful for
WEP when the device sends data packets autonomously, e.g. for ARP
offloading. The index can be 0-3, or -1 for unsetting it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_scan</span></code></dt><dd><p>Ask the hardware to service the scan request, no need to start
the scan state machine in stack. The scan must honour the channel
configuration done by the regulatory agent in the wiphy’s
registered bands. The hardware (or the driver) needs to make sure
that power save is disabled.
The <strong>req</strong> ie/ie_len members are rewritten by mac80211 to contain the
entire IEs after the SSID, so that drivers need not look at these
at all but just send them after the SSID – mac80211 includes the
(extended) supported rates and HT information (where applicable).
When the scan finishes, <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_scan_completed" title="ieee80211_scan_completed"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_scan_completed()</span></code></a> must be called;
note that it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error code.
This callback is also allowed to return the special return value 1,
this indicates that hardware scan isn’t desirable right now and a
software scan should be done instead. A driver wishing to use this
capability must ensure its (hardware) scan capabilities aren’t
advertised as more capable than mac80211’s software scan is.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cancel_hw_scan</span></code></dt><dd><p>Ask the low-level tp cancel the active hw scan.
The driver should ask the hardware to cancel the scan (if possible),
but the scan will be completed only after the driver will call
<a class="reference internal" href="mac80211-advanced.html#c.ieee80211_scan_completed" title="ieee80211_scan_completed"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_scan_completed()</span></code></a>.
This callback is needed for wowlan, to prevent enqueueing a new
scan_work after the low-level driver was already suspended.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_scan_start</span></code></dt><dd><p>Ask the hardware to start scanning repeatedly at
specific intervals.  The driver must call the
ieee80211_sched_scan_results() function whenever it finds results.
This process will continue until sched_scan_stop is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_scan_stop</span></code></dt><dd><p>Tell the hardware to stop an ongoing scheduled scan.
In this case, ieee80211_sched_scan_stopped() must not be called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_scan_start</span></code></dt><dd><p>Notifier function that is called just before a software scan
is started. Can be NULL, if the driver doesn’t need this notification.
The mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,
the driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it
can use this parameter. The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_scan_complete</span></code></dt><dd><p>Notifier function that is called just after a
software scan finished. Can be NULL, if the driver doesn’t need
this notification.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_stats</span></code></dt><dd><p>Return low-level statistics.
Returns zero if statistics are available.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_key_seq</span></code></dt><dd><p>If your device implements encryption in hardware and does
IV/PN assignment then this callback should be provided to read the
IV/PN for the given key from hardware.
The callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_frag_threshold</span></code></dt><dd><p>Configuration of fragmentation threshold. Assign this
if the device does fragmentation by itself. Note that to prevent the
stack from doing fragmentation IEEE80211_HW_SUPPORTS_TX_FRAG
should be set as well.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_rts_threshold</span></code></dt><dd><p>Configuration of RTS threshold (if device needs it)
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_add</span></code></dt><dd><p>Notifies low level driver about addition of an associated station,
AP, IBSS/WDS/mesh peer etc. This callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_remove</span></code></dt><dd><p>Notifies low level driver about removal of an associated
station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
returns it isn’t safe to use the pointer, not even RCU protected;
no RCU grace period is guaranteed between returning here and freeing
the station. See <strong>sta_pre_rcu_remove</strong> if needed.
This callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_add_debugfs</span></code></dt><dd><p>Drivers can use this callback to add debugfs files
when a station is added to mac80211’s station list. This callback
should be within a CONFIG_MAC80211_DEBUGFS conditional. This
callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_notify</span></code></dt><dd><p>Notifies low level driver about power state transition of an
associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
in AP mode, this callback will not be called when the flag
<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AP_LINK_PS</span></code> is set. Must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_set_txpwr</span></code></dt><dd><p>Configure the station tx power. This callback set the tx
power for the station.
This callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_state</span></code></dt><dd><p>Notifies low level driver about state transition of a
station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
This callback is mutually exclusive with <strong>sta_add</strong>/<strong>sta_remove</strong>.
It must not fail for down transitions but may fail for transitions
up the list of states. Also note that after the callback returns it
isn’t safe to use the pointer, not even RCU protected - no RCU grace
period is guaranteed between returning here and freeing the station.
See <strong>sta_pre_rcu_remove</strong> if needed.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_pre_rcu_remove</span></code></dt><dd><p>Notify driver about station removal before RCU
synchronisation. This is useful if a driver needs to have station
pointers protected using RCU, it can then use this call to clear
the pointers instead of waiting for an RCU grace period to elapse
in <strong>sta_state</strong>.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_rc_update</span></code></dt><dd><p>Notifies the driver of changes to the bitrates that can be
used to transmit to the station. The changes are advertised with bits
from <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_rate_control_changed" title="ieee80211_rate_control_changed"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_rate_control_changed</span></code></a> and the values are reflected
in the station data. This callback should only be used when the driver
uses hardware rate control (<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_HAS_RATE_CONTROL</span></code>) since
otherwise the rate control algorithm is notified directly.
Must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_rate_tbl_update</span></code></dt><dd><p>Notifies the driver that the rate table changed. This
is only used if the configured rate control algorithm actually uses
the new rate table API, and is therefore optional. Must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_statistics</span></code></dt><dd><p>Get statistics for this station. For example with beacon
filtering, the statistics kept by mac80211 might not be accurate, so
let the driver pre-fill the statistics. The driver can fill most of
the values (indicating which by setting the filled bitmap), but not
all of them make sense - see the source for which ones are possible.
Statistics that the driver doesn’t fill will be filled by mac80211.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conf_tx</span></code></dt><dd><p>Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
bursting) for a hardware TX queue.
Returns a negative error code on failure.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_tsf</span></code></dt><dd><p>Get the current TSF timer value from firmware/hardware. Currently,
this is only used for IBSS mode BSSID merging and debugging. Is not a
required function.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tsf</span></code></dt><dd><p>Set the TSF timer to the specified value in the firmware/hardware.
Currently, this is only used for IBSS mode debugging. Is not a
required function.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset_tsf</span></code></dt><dd><p>Offset the TSF timer by the specified value in the
firmware/hardware.  Preferred to set_tsf as it avoids delay between
calling set_tsf() and hardware getting programmed, which will show up
as TSF delay. Is not a required function.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_tsf</span></code></dt><dd><p>Reset the TSF timer and allow firmware/hardware to synchronize
with other STAs in the IBSS. This is only used in IBSS mode. This
function is optional if the firmware/hardware takes full care of
TSF synchronization.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_last_beacon</span></code></dt><dd><p>Determine whether the last IBSS beacon was sent by us.
This is needed only for IBSS mode and the result of this function is
used to determine whether to reply to Probe Requests.
Returns non-zero if this device sent the last beacon.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_action</span></code></dt><dd><p>Perform a certain A-MPDU action.
The RA/TID combination determines the destination and TID we want
the ampdu action to be performed for. The action is defined through
ieee80211_ampdu_mlme_action.
When the action is set to <code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_OPERATIONAL</span></code> the driver
may neither send aggregates containing more subframes than <strong>buf_size</strong>
nor send aggregates in a way that lost frames would exceed the
buffer size. If just limiting the aggregate size, this would be
possible with a buf_size of 8:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TX:</span> <span class="pre">1.....7</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RX:</span>&#160; <span class="pre">2....7</span></code> (lost frame #1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TX:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">8..1...</span></code></p></li>
</ul>
<p>which is invalid since #1 was now re-transmitted well past the
buffer size of 8. Correct ways to retransmit #1 would be:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TX:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">1</span>&#160;&#160; <span class="pre">or</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TX:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">18</span>&#160; <span class="pre">or</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TX:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">81</span></code></p></li>
</ul>
<p>Even <code class="docutils literal notranslate"><span class="pre">189</span></code> would be wrong since 1 could be lost again.</p>
<p>Returns a negative error code on failure. The driver may return
<code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START_IMMEDIATE</span></code> for <code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START</span></code>
if the session can start immediately.</p>
<p>The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_survey</span></code></dt><dd><p>Return per-channel survey information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rfkill_poll</span></code></dt><dd><p>Poll rfkill hardware state. If you need this, you also
need to set wiphy-&gt;rfkill_poll to <code class="docutils literal notranslate"><span class="pre">true</span></code> before registration,
and need to call <a class="reference internal" href="cfg80211.html#c.wiphy_rfkill_set_hw_state" title="wiphy_rfkill_set_hw_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_rfkill_set_hw_state()</span></code></a> in the callback.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_coverage_class</span></code></dt><dd><p>Set slot time for given coverage class as specified
in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
accordingly; coverage class equals to -1 to enable ACK timeout
estimation algorithm (dynack). To disable dynack set valid value for
coverage class. This callback is not required and may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">testmode_cmd</span></code></dt><dd><p>Implement a cfg80211 test mode command. The passed <strong>vif</strong> may
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">testmode_dump</span></code></dt><dd><p>Implement a cfg80211 test mode dump. The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush</span></code></dt><dd><p>Flush all pending frames from the hardware queue, making sure
that the hardware queues are empty. The <strong>queues</strong> parameter is a bitmap
of queues to flush, which is useful if different virtual interfaces
use different hardware queues; it may also indicate all queues.
If the parameter <strong>drop</strong> is set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, pending frames may be dropped.
Note that vif can be NULL.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_switch</span></code></dt><dd><p>Drivers that need (or want) to offload the channel
switch operation for CSAs received from the AP may implement this
callback. They must then call ieee80211_chswitch_done() to indicate
completion of the channel switch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_antenna</span></code></dt><dd><p>Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <strong>NL80211_ATTR_WIPHY_ANTENNA_TX</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_antenna</span></code></dt><dd><p>Get current antenna configuration from device (tx_ant, rx_ant).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remain_on_channel</span></code></dt><dd><p>Starts an off-channel period on the given channel, must
call back to ieee80211_ready_on_channel() when on that channel. Note
that normal channel traffic is not stopped as this is intended for hw
offload. Frames to transmit on the off-channel channel are transmitted
normally except for the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_TX_OFFCHAN</span></code> flag. When the
duration (which will always be non-zero) expires, the driver must call
ieee80211_remain_on_channel_expired().
Note that this callback may be called while the device is in IDLE and
must be accepted in this case.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cancel_remain_on_channel</span></code></dt><dd><p>Requests that an ongoing off-channel period is
aborted before it expires. This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ringparam</span></code></dt><dd><p>Set tx and rx ring sizes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_ringparam</span></code></dt><dd><p>Get tx and rx ring current and maximum sizes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_frames_pending</span></code></dt><dd><p>Check if there is any pending frame in the hardware
queues before entering power save.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_bitrate_mask</span></code></dt><dd><p>Set a mask of rates to be used for rate control selection
when transmitting a frame. Currently only legacy rates are handled.
The callback can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_callback</span></code></dt><dd><p>Notify driver about any event in mac80211. See
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_event_type</span></code> for the different types.
The callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allow_buffered_frames</span></code></dt><dd><p>Prepare device to allow the given number of frames
to go out to the given station. The frames will be sent by mac80211
via the usual TX path after this call. The TX information for frames
released will also have the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_PS_BUFFER</span></code> flag set
and the last one will also have <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code> set. In case
frames from multiple TIDs are released and the driver might reorder
them between the TIDs, it must set the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code> flag
on the last frame and clear it on all others and also handle the EOSP
bit in the QoS header correctly. Alternatively, it can also call the
<a class="reference internal" href="mac80211-advanced.html#c.ieee80211_sta_eosp" title="ieee80211_sta_eosp"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_eosp()</span></code></a> function.
The <strong>tids</strong> parameter is a bitmap and tells the driver which TIDs the
frames will be on; it will at most have two bits set.
This callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_buffered_frames</span></code></dt><dd><p>Release buffered frames according to the given
parameters. In the case where the driver buffers some frames for
sleeping stations mac80211 will use this callback to tell the driver
to release some frames, either for PS-poll or uAPSD.
Note that if the <strong>more_data</strong> parameter is <code class="docutils literal notranslate"><span class="pre">false</span></code> the driver must check
if there are more frames on the given TIDs, and if there are more than
the frames being released then it must still set the more-data bit in
the frame. If the <strong>more_data</strong> parameter is <code class="docutils literal notranslate"><span class="pre">true</span></code>, then of course the
more-data bit must always be set.
The <strong>tids</strong> parameter tells the driver which TIDs to release frames
from, for PS-poll it will always have only a single bit set.
In the case this is used for a PS-poll initiated release, the
<strong>num_frames</strong> parameter will always be 1 so code can be shared. In
this case the driver must also set <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code> flag
on the TX status (and must report TX status) so that the PS-poll
period is properly ended. This is used to avoid sending multiple
responses for a retried PS-poll frame.
In the case this is used for uAPSD, the <strong>num_frames</strong> parameter may be
bigger than one, but the driver may send fewer frames (it must send
at least one, however). In this case it is also responsible for
setting the EOSP flag in the QoS header of the frames. Also, when the
service period ends, the driver must set <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code>
on the last frame in the SP. Alternatively, it may call the function
<a class="reference internal" href="mac80211-advanced.html#c.ieee80211_sta_eosp" title="ieee80211_sta_eosp"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_eosp()</span></code></a> to inform mac80211 of the end of the SP.
This callback must be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_et_sset_count</span></code></dt><dd><p>Ethtool API to get string-set count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_et_stats</span></code></dt><dd><p>Ethtool API to get a set of u64 stats.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_et_strings</span></code></dt><dd><p>Ethtool API to get a set of strings to describe stats
and perhaps other supported types of ethtool data-sets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgd_prepare_tx</span></code></dt><dd><p>Prepare for transmitting a management frame for association
before associated. In multi-channel scenarios, a virtual interface is
bound to a channel before it is associated, but as it isn’t associated
yet it need not necessarily be given airtime, in particular since any
transmission to a P2P GO needs to be synchronized against the GO’s
powersave state. mac80211 will call this function before transmitting a
management frame prior to having successfully associated to allow the
driver to give it channel time for the transmission, to get a response
and to be able to synchronize with the GO.
For drivers that set <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP</span></code>, mac80211
would also call this function before transmitting a deauthentication
frame in case that no beacon was heard from the AP/P2P GO.
The callback will be called before each transmission and upon return
mac80211 will transmit the frame right away.
If duration is greater than zero, mac80211 hints to the driver the
duration for which the operation is requested.
The callback is optional and can (should!) sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgd_protect_tdls_discover</span></code></dt><dd><p>Protect a TDLS discovery session. After sending
a TDLS discovery-request, we expect a reply to arrive on the AP’s
channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
setup-response is a direct packet not buffered by the AP.
mac80211 will call this function just before the transmission of a TDLS
discovery-request. The recommended period of protection is at least
2 * (DTIM period).
The callback is optional and can sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_chanctx</span></code></dt><dd><p>Notifies device driver about new channel context creation.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove_chanctx</span></code></dt><dd><p>Notifies device driver about channel context destruction.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_chanctx</span></code></dt><dd><p>Notifies device driver about channel context changes that
may happen when combining different virtual interfaces on the same
channel context with different settings
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assign_vif_chanctx</span></code></dt><dd><p>Notifies device driver about channel context being bound
to vif. Possible use is for hw queue remapping.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unassign_vif_chanctx</span></code></dt><dd><p>Notifies device driver about channel context being
unbound from vif.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">switch_vif_chanctx</span></code></dt><dd><p>switch a number of vifs from one chanctx to
another, as specified in the list of
<strong>ieee80211_vif_chanctx_switch</strong> passed to the driver, according
to the mode defined in <code class="xref c c-type docutils literal notranslate"><span class="pre">ieee80211_chanctx_switch_mode</span></code>.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reconfig_complete</span></code></dt><dd><p>Called after a call to ieee80211_restart_hw() and
during resume, when the reconfiguration has completed.
This can help the driver implement the reconfiguration step (and
indicate mac80211 is ready to receive frames).
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipv6_addr_change</span></code></dt><dd><p>IPv6 address assignment on the given interface changed.
Currently, this is only called for managed or P2P client interfaces.
This callback is optional; it must not sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_switch_beacon</span></code></dt><dd><p>Starts a channel switch to a new channel.
Beacons are modified to include CSA or ECSA IEs before calling this
function. The corresponding count fields in these IEs must be
decremented, and when they reach 1 the driver must call
ieee80211_csa_finish(). Drivers which use <a class="reference internal" href="mac80211-advanced.html#c.ieee80211_beacon_get" title="ieee80211_beacon_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_beacon_get()</span></code></a>
get the csa counter decremented by mac80211, but must check if it is
1 using ieee80211_beacon_counter_is_complete() after the beacon has been
transmitted and then call ieee80211_csa_finish().
If the CSA count starts as zero or 1, this function will not be called,
since there won’t be any time to beacon before the switch anyway.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_channel_switch</span></code></dt><dd><p>This is an optional callback that is called
before a channel switch procedure is started (ie. when a STA
gets a CSA or a userspace initiated channel-switch), allowing
the driver to prepare for the channel switch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_channel_switch</span></code></dt><dd><p>This is an optional callback that is called
after a channel switch procedure is completed, allowing the
driver to go back to a normal configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_channel_switch</span></code></dt><dd><p>This is an optional callback that is called
when channel switch procedure was completed, allowing the
driver to go back to a normal configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_switch_rx_beacon</span></code></dt><dd><p>This is an optional callback that is called
when channel switch procedure is in progress and additional beacon with
CSA IE was received, allowing driver to track changes in count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">join_ibss</span></code></dt><dd><p>Join an IBSS (on an IBSS interface); this is called after all
information in bss_conf is set up and the beacon can be retrieved. A
channel context is bound before this is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leave_ibss</span></code></dt><dd><p>Leave the IBSS again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_expected_throughput</span></code></dt><dd><p>extract the expected throughput towards the
specified station. The returned value is expressed in Kbps. It returns 0
if the RC algorithm does not have proper data to provide.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_txpower</span></code></dt><dd><p>get current maximum tx power (in dBm) based on configuration
and hardware limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_channel_switch</span></code></dt><dd><p>Start channel-switching with a TDLS peer. The driver
is responsible for continually initiating channel-switching operations
and returning to the base channel for communication with the AP. The
driver receives a channel-switch request template and the location of
the switch-timing IE within the template as part of the invocation.
The template is valid only within the call, and the driver can
optionally copy the skb for further re-use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_cancel_channel_switch</span></code></dt><dd><p>Stop channel-switching with a TDLS peer. Both
peers must be on the base channel when the call completes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_recv_channel_switch</span></code></dt><dd><p>a TDLS channel-switch related frame (request or
response) has been received from a remote peer. The driver gets
parameters parsed from the incoming frame and may use them to continue
an ongoing channel-switch operation. In addition, a channel-switch
response template is provided, together with the location of the
switch-timing IE within the template. The skb can only be used within
the function call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wake_tx_queue</span></code></dt><dd><p>Called when new packets have been added to the queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_rx_queues</span></code></dt><dd><p>Process all pending frames in RSS queues. This is a
synchronization which is needed in case driver has in its RSS queues
pending frames that were received prior to the control path action
currently taken (e.g. disassociation) but are not processed yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_nan</span></code></dt><dd><p>join an existing NAN cluster, or create a new one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_nan</span></code></dt><dd><p>leave the NAN cluster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nan_change_conf</span></code></dt><dd><p>change NAN configuration. The data in cfg80211_nan_conf
contains full new configuration and changes specify which parameters
are changed with respect to the last NAN config.
The driver gets both full configuration and the changed parameters since
some devices may need the full configuration while others need only the
changed parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_nan_func</span></code></dt><dd><p>Add a NAN function. Returns 0 on success. The data in
cfg80211_nan_func must not be referenced outside the scope of
this call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_nan_func</span></code></dt><dd><p>Remove a NAN function. The driver must call
ieee80211_nan_func_terminated() with
NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_aggregate_in_amsdu</span></code></dt><dd><p>Called in order to determine if HW supports
aggregating two specific frames in the same A-MSDU. The relation
between the skbs should be symmetric and transitive. Note that while
skb is always a real frame, head may or may not be an A-MSDU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_ftm_responder_stats</span></code></dt><dd><p>Retrieve FTM responder statistics, if available.
Statistics should be cumulative, currently no way to reset is provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_pmsr</span></code></dt><dd><p>start peer measurement (e.g. FTM) (this call can sleep)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_pmsr</span></code></dt><dd><p>abort peer measurement (this call can sleep)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tid_config</span></code></dt><dd><p>Apply TID specific configurations. This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_tid_config</span></code></dt><dd><p>Reset TID specific configuration for the peer.
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_vif_offload</span></code></dt><dd><p>Update virtual interface offload flags
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_set_4addr</span></code></dt><dd><p>Called to notify the driver when a station starts/stops using
4-address mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_sar_specs</span></code></dt><dd><p>Update the SAR (TX power) settings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_set_decap_offload</span></code></dt><dd><p>Called to notify the driver when a station is allowed
to use rx decapsulation offload</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure contains various callbacks that the driver may
handle or, in some cases, must handle, for example to configure
the hardware to a new channel or to transmit a frame.</p>
<dl class="c function">
<dt id="c.ieee80211_alloc_hw">
<em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<code class="sig-name descname">ieee80211_alloc_hw</code><span class="sig-paren">(</span>size_t <em>priv_data_len</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_ops" title="ieee80211_ops">ieee80211_ops</a> *<em>ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_alloc_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new hardware device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">priv_data_len</span></code></dt><dd><p>length of private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_ops</span> <span class="pre">*ops</span></code></dt><dd><p>callbacks for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called once for each hardware device. The returned pointer
must be used to refer to this device when calling other functions.
mac80211 allocates a private data area for the driver pointed to by
<strong>priv</strong> in <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span></code></a>, the size of this area is given as
<strong>priv_data_len</strong>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the new hardware device, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="c function">
<dt id="c.ieee80211_register_hw">
int <code class="sig-name descname">ieee80211_register_hw</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_register_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register hardware device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the device to register as returned by <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You must call this function before any other functions in
mac80211. Note that before a hardware can be registered, you
need to fill the contained wiphy’s information.</p>
<p><strong>Return</strong></p>
<p>0 on success. An error code otherwise.</p>
<dl class="c function">
<dt id="c.ieee80211_unregister_hw">
void <code class="sig-name descname">ieee80211_unregister_hw</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_unregister_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister a hardware device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function instructs mac80211 to free allocated resources
and unregister netdevices from the networking subsystem.</p>
<dl class="c function">
<dt id="c.ieee80211_free_hw">
void <code class="sig-name descname">ieee80211_free_hw</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_free_hw" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free hardware descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees everything that was allocated, including the
private data for the driver. You must call <a class="reference internal" href="#c.ieee80211_unregister_hw" title="ieee80211_unregister_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_unregister_hw()</span></code></a>
before calling this function.</p>
</div>
<div class="section" id="phy-configuration">
<h2>PHY configuration<a class="headerlink" href="#phy-configuration" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>This chapter should describe PHY handling including start/stop callbacks
and the various structures used.</p>
<dl class="c enum">
<dt id="c.ieee80211_conf_flags">
<em class="property">enum </em><code class="sig-name descname">ieee80211_conf_flags</code><a class="headerlink" href="#c.ieee80211_conf_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configuration flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_MONITOR</span></code></dt><dd><p>there’s a monitor interface present – use this
to determine for example whether to calculate timestamps for packets
or not, do not use instead of filter flags!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code></dt><dd><p>Enable 802.11 power save mode (managed mode only).
This is the power save mode defined by IEEE 802.11-2007 section 11.2,
meaning that the hardware still wakes up for beacons, is able to
transmit frames and receive the possible acknowledgment frames.
Not to be confused with hardware specific wakeup/sleep states,
driver is responsible for that. See the section “Powersave support”
for more.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_IDLE</span></code></dt><dd><p>The device is running, but idle; if the flag is set
the driver should be prepared to handle configuration requests but
may turn the device off as much as possible. Typically, this flag will
be set when an interface is set UP but not associated or scanning, but
it can also be unset in that case when monitor interfaces are active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_OFFCHANNEL</span></code></dt><dd><p>The device is currently not on its main
operating channel.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flags to define PHY configuration options</p>
<dl class="c struct">
<dt id="c.ieee80211_conf">
<em class="property">struct </em><code class="sig-name descname">ieee80211_conf</code><a class="headerlink" href="#c.ieee80211_conf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configuration of the device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_conf {
  u32 flags;
  int power_level, dynamic_ps_timeout;
  u16 listen_interval;
  u8 ps_dtim_period;
  u8 long_frame_max_tx_count, short_frame_max_tx_count;
  struct cfg80211_chan_def chandef;
  bool radar_enabled;
  enum ieee80211_smps_mode smps_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>configuration flags defined above</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power_level</span></code></dt><dd><p>requested transmit power (in dBm), backward compatibility
value only that is set to the minimum of all interfaces</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dynamic_ps_timeout</span></code></dt><dd><p>The dynamic powersave timeout (in ms), see the
powersave documentation below. This variable is valid only when
the CONF_PS flag is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">listen_interval</span></code></dt><dd><p>listen interval in units of beacon interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ps_dtim_period</span></code></dt><dd><p>The DTIM period of the AP we’re connected to, for use
in power saving. Power saving will not be enabled until a beacon
has been received and the DTIM period is known.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long_frame_max_tx_count</span></code></dt><dd><p>Maximum number of transmissions for a “long” frame
(a frame not RTS protected), called “dot11LongRetryLimit” in 802.11,
but actually means the number of transmissions not the number of retries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short_frame_max_tx_count</span></code></dt><dd><p>Maximum number of transmissions for a “short”
frame, called “dot11ShortRetryLimit” in 802.11, but actually means the
number of transmissions not the number of retries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chandef</span></code></dt><dd><p>the channel definition to tune to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radar_enabled</span></code></dt><dd><p>whether radar detection is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smps_mode</span></code></dt><dd><p>spatial multiplexing powersave mode; note that
<code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_STATIC</span></code> is used when the device is not
configured for an HT channel.
Note that this is only valid if channel contexts are not used,
otherwise each channel context has the number of chains listed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct indicates how the driver shall configure the hardware.</p>
</div>
<div class="section" id="virtual-interfaces">
<h2>Virtual interfaces<a class="headerlink" href="#virtual-interfaces" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>This chapter should describe virtual interface basics that are relevant
to the driver (VLANs, MGMT etc are not.) It should explain the use of
the add_iface/remove_iface callbacks as well as the interface
configuration callbacks.</p>
<p>Things related to AP mode should be discussed there.</p>
<p>Things related to supporting multiple interfaces should be in the
appropriate chapter, a BIG FAT note should be here about this though and
the recommendation to allow only a single interface in STA mode at
first!</p>
<dl class="c struct">
<dt id="c.ieee80211_vif">
<em class="property">struct </em><code class="sig-name descname">ieee80211_vif</code><a class="headerlink" href="#c.ieee80211_vif" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>per-interface data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_vif {
  enum nl80211_iftype type;
  struct ieee80211_bss_conf bss_conf;
  u8 addr[ETH_ALEN] ;
  bool p2p;
  bool csa_active;
  bool mu_mimo_owner;
  u8 cab_queue;
  u8 hw_queue[IEEE80211_NUM_ACS];
  struct ieee80211_txq *txq;
  struct ieee80211_chanctx_conf __rcu *chanctx_conf;
  u32 driver_flags;
  u32 offload_flags;
#ifdef CONFIG_MAC80211_DEBUGFS;
  struct dentry *debugfs_dir;
#endif;
  bool probe_req_reg;
  bool rx_mcast_action_reg;
  bool txqs_stopped[IEEE80211_NUM_ACS];
  u8 drv_priv[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of this virtual interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_conf</span></code></dt><dd><p>BSS configuration for this interface, either our own
or the BSS we’re associated to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>address of this interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p2p</span></code></dt><dd><p>indicates whether this AP or STA interface is a p2p
interface, i.e. a GO or p2p-sta respectively</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csa_active</span></code></dt><dd><p>marks whether a channel switch is going on. Internally it is
write-protected by sdata_lock and local-&gt;mtx so holding either is fine
for read access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mu_mimo_owner</span></code></dt><dd><p>indicates interface owns MU-MIMO capability</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cab_queue</span></code></dt><dd><p>content-after-beacon (DTIM beacon really) queue, AP mode only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_queue</span></code></dt><dd><p>hardware queue for each AC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq</span></code></dt><dd><p>the multicast data TX queue (if driver uses the TXQ abstraction)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chanctx_conf</span></code></dt><dd><p>The channel context this interface is assigned to, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
when it is not assigned. This pointer is RCU-protected due to the TX
path needing to access it; even though the netdev carrier will always
be off when it is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> there can still be races and packets could be
processed after it switches back to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_flags</span></code></dt><dd><p>flags/capabilities the driver has for this interface,
these need to be set (or cleared) when the interface is added
or, if supported by the driver, the interface type is changed
at runtime, mac80211 will never touch this field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_flags</span></code></dt><dd><p>802.3 -&gt; 802.11 enapsulation offload flags, see
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_offload_flags</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_dir</span></code></dt><dd><p>debugfs dentry, can be used by drivers to create own per
interface debug files. Note that it will be NULL for the virtual
monitor interface (if that is requested.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_req_reg</span></code></dt><dd><p>probe requests should be reported to mac80211 for this
interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_mcast_action_reg</span></code></dt><dd><p>multicast Action frames should be reported to mac80211
for this interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txqs_stopped</span></code></dt><dd><p>per AC flag to indicate that intermediate TXQs are stopped,
protected by fq-&gt;lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_priv</span></code></dt><dd><p>data area for driver use, will always be aligned to
sizeof(void *).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Data in this structure is continually present for driver
use during the life of a virtual interface.</p>
</div>
<div class="section" id="receive-and-transmit-processing">
<h2>Receive and transmit processing<a class="headerlink" href="#receive-and-transmit-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-should-be-here">
<h3>what should be here<a class="headerlink" href="#what-should-be-here" title="Permalink to this headline">¶</a></h3>
<p>TBD</p>
<p>This should describe the receive and transmit paths in mac80211/the
drivers as well as transmit status handling.</p>
</div>
<div class="section" id="frame-format">
<h3>Frame format<a class="headerlink" href="#frame-format" title="Permalink to this headline">¶</a></h3>
<p>As a general rule, when frames are passed between mac80211 and the driver,
they start with the IEEE 802.11 header and include the same octets that are
sent over the air except for the FCS which should be calculated by the
hardware.</p>
<p>There are, however, various exceptions to this rule for advanced features:</p>
<p>The first exception is for hardware encryption and decryption offload
where the IV/ICV may or may not be generated in hardware.</p>
<p>Secondly, when the hardware handles fragmentation, the frame handed to
the driver from mac80211 is the MSDU, not the MPDU.</p>
</div>
<div class="section" id="packet-alignment">
<h3>Packet alignment<a class="headerlink" href="#packet-alignment" title="Permalink to this headline">¶</a></h3>
<p>Drivers always need to pass packets that are aligned to two-byte boundaries
to the stack.</p>
<p>Additionally, should, if possible, align the payload data in a way that
guarantees that the contained IP header is aligned to a four-byte
boundary. In the case of regular frames, this simply means aligning the
payload to a four-byte boundary (because either the IP header is directly
contained, or IV/RFC1042 headers that have a length divisible by four are
in front of it).  If the payload data is not properly aligned and the
architecture doesn’t support efficient unaligned operations, mac80211
will align the data.</p>
<p>With A-MSDU frames, however, the payload data address must yield two modulo
four because there are 14-byte 802.3 headers within the A-MSDU frames that
push the IP header further back to a multiple of four again. Thankfully, the
specs were sane enough this time around to require padding each A-MSDU
subframe to a length that is a multiple of four.</p>
<p>Padding like Atheros hardware adds which is between the 802.11 header and
the payload is not supported, the driver is required to move the 802.11
header to be directly in front of the payload in that case.</p>
</div>
<div class="section" id="calling-into-mac80211-from-interrupts">
<h3>Calling into mac80211 from interrupts<a class="headerlink" href="#calling-into-mac80211-from-interrupts" title="Permalink to this headline">¶</a></h3>
<p>Only <a class="reference internal" href="#c.ieee80211_tx_status_irqsafe" title="ieee80211_tx_status_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_irqsafe()</span></code></a> and <a class="reference internal" href="#c.ieee80211_rx_irqsafe" title="ieee80211_rx_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_irqsafe()</span></code></a> can be
called in hardware interrupt context. The low-level driver must not call any
other functions in hardware interrupt context. If there is a need for such
call, the low-level driver should first ACK the interrupt and perform the
IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
tasklet function.</p>
<dl class="simple">
<dt>NOTE: If the driver opts to use the _irqsafe() functions, it may not also</dt><dd><p>use the non-IRQ-safe functions!</p>
</dd>
</dl>
</div>
<div class="section" id="functions-definitions">
<h3>functions/definitions<a class="headerlink" href="#functions-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="c enum">
<dt id="c.mac80211_tx_info_flags">
<em class="property">enum </em><code class="sig-name descname">mac80211_tx_info_flags</code><a class="headerlink" href="#c.mac80211_tx_info_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flags to describe transmission information/status</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_REQ_TX_STATUS</span></code></dt><dd><p>require TX status callback for this frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_ASSIGN_SEQ</span></code></dt><dd><p>The driver has to assign a sequence
number to this frame, taking care of not overwriting the fragment
number and increasing the sequence number only when the
IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
assign sequence numbers to QoS-data frames but cannot do so correctly
for non-QoS-data and management frames because beacons need them from
that counter as well and mac80211 cannot guarantee proper sequencing.
If this flag is set, the driver should instruct the hardware to
assign a sequence number to the frame or assign one itself. Cf. IEEE
802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
beacons and always be clear for frames without a sequence number field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_ACK</span></code></dt><dd><p>tell the low level not to wait for an ack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_CLEAR_PS_FILT</span></code></dt><dd><p>clear powersave filter for destination
station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_FIRST_FRAGMENT</span></code></dt><dd><p>this is a first fragment of the frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_SEND_AFTER_DTIM</span></code></dt><dd><p>send this frame after DTIM beacon</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_AMPDU</span></code></dt><dd><p>this frame should be sent as part of an A-MPDU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_INJECTED</span></code></dt><dd><p>Frame was injected, internal to mac80211.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_TX_FILTERED</span></code></dt><dd><p>The frame was not transmitted
because the destination STA was in powersave mode. Note that to
avoid race conditions, the filter must be set by the hardware or
firmware upon receiving a frame that indicates that the station
went to sleep (must be done on device to filter frames already on
the queue) and may only be unset after mac80211 gives the OK for
that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
since only then is it guaranteed that no more frames are in the
hardware queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_ACK</span></code></dt><dd><p>Frame was acknowledged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_AMPDU</span></code></dt><dd><p>The frame was aggregated, so status
is for the whole aggregation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_AMPDU_NO_BACK</span></code></dt><dd><p>no block ack was returned,
so consider using block ack request (BAR).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_RATE_CTRL_PROBE</span></code></dt><dd><p>internal to mac80211, can be
set by rate control algorithms to indicate probe rate, will
be cleared for fragmented frames (except on the last fragment)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_OFFCHAN_TX_OK</span></code></dt><dd><p>Internal to mac80211. Used to indicate
that a frame can be transmitted while the queues are stopped for
off-channel operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_HW_80211_ENCAP</span></code></dt><dd><p>This frame uses hardware encapsulation
(header conversion)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_RETRIED</span></code></dt><dd><p>completely internal to mac80211,
used to indicate that a frame was already retried due to PS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_DONT_ENCRYPT</span></code></dt><dd><p>completely internal to mac80211,
used to indicate frame should not be encrypted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_PS_BUFFER</span></code></dt><dd><p>This frame is a response to a poll
frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
be sent although the station is in powersave mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_MORE_FRAMES</span></code></dt><dd><p>More frames will be passed to the
transmit function after the current frame, this can be used
by drivers to kick the DMA queue only if unset or when the
queue gets full.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_RETRANSMISSION</span></code></dt><dd><p>This frame is being retransmitted
after TX status because the destination was asleep, it must not
be modified again (no seqno assignment, crypto, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_MLME_CONN_TX</span></code></dt><dd><p>This frame was transmitted by the MLME
code for connection establishment, this indicates that its status
should kick the MLME state machine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_NL80211_FRAME_TX</span></code></dt><dd><p>Frame was requested through nl80211
MLME command (internal to mac80211 to figure out whether to send TX
status to user space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_LDPC</span></code></dt><dd><p>tells the driver to use LDPC for this frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_STBC</span></code></dt><dd><p>Enables Space-Time Block Coding (STBC) for this
frame and selects the maximum number of streams that it can use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_TX_OFFCHAN</span></code></dt><dd><p>Marks this packet to be transmitted on
the off-channel channel when a remain-on-channel offload is done
in hardware – normal packets still flow and are expected to be
handled properly by the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTFL_TKIP_MIC_FAILURE</span></code></dt><dd><p>Marks this packet to be used for TKIP
testing. It will be sent out with incorrect Michael MIC key to allow
TKIP countermeasures to be tested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_CCK_RATE</span></code></dt><dd><p>This frame will be sent at non CCK rate.
This flag is actually used for management frame especially for P2P
frames not being sent at CCK rate in 2GHz band.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code></dt><dd><p>This packet marks the end of service period,
when its status is reported the service period ends. For frames in
an SP that mac80211 transmits, it is already set; for driver frames
the driver may set this flag. It is also used to do the same for
PS-Poll responses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_USE_MINRATE</span></code></dt><dd><p>This frame will be sent at lowest rate.
This flag is used to send nullfunc frame at minimum rate when
the nullfunc is used for connection monitoring purpose.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_DONTFRAG</span></code></dt><dd><p>Don’t fragment this packet even if it
would be fragmented by size (this is optional, only used for
monitor injection).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_NOACK_TRANSMITTED</span></code></dt><dd><p>A frame that was marked with
IEEE80211_TX_CTL_NO_ACK has been successfully transmitted without
any errors (like issues specific to the driver/HW).
This flag must not be set for frames that don’t request no-ack
behaviour with IEEE80211_TX_CTL_NO_ACK.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags are used with the <strong>flags</strong> member of <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">ieee80211_tx_info</span></code></a>.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>If you have to add new flags to the enumeration, then don’t</dt><dd><p>forget to update <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_TEMPORARY_FLAGS</span></code> when necessary.</p>
</dd>
</dl>
<dl class="c enum">
<dt id="c.mac80211_tx_control_flags">
<em class="property">enum </em><code class="sig-name descname">mac80211_tx_control_flags</code><a class="headerlink" href="#c.mac80211_tx_control_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>flags to describe transmit control</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_PORT_CTRL_PROTO</span></code></dt><dd><p>this frame is a port control
protocol frame (e.g. EAP)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_PS_RESPONSE</span></code></dt><dd><p>This frame is a response to a poll
frame (PS-Poll or uAPSD).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_RATE_INJECT</span></code></dt><dd><p>This frame is injected with rate information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_AMSDU</span></code></dt><dd><p>This frame is an A-MSDU frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_FAST_XMIT</span></code></dt><dd><p>This frame is going through the fast_xmit path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP</span></code></dt><dd><p>This frame skips mesh path lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_INTCFL_NEED_TXPROCESSING</span></code></dt><dd><p>completely internal to mac80211,
used to indicate that a pending frame requires TX processing before
it can be sent out.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_NO_SEQNO</span></code></dt><dd><p>Do not overwrite the sequence number that
has already been assigned to this frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTRL_DONT_REORDER</span></code></dt><dd><p>This frame should not be reordered
relative to other frames that have this flag set, independent
of their QoS TID or other priority field values.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags are used in tx_info-&gt;control.flags.</p>
<dl class="c enum">
<dt id="c.mac80211_rate_control_flags">
<em class="property">enum </em><code class="sig-name descname">mac80211_rate_control_flags</code><a class="headerlink" href="#c.mac80211_rate_control_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>per-rate flags set by the Rate Control algorithm.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_USE_RTS_CTS</span></code></dt><dd><p>Use RTS/CTS exchange for this rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_USE_CTS_PROTECT</span></code></dt><dd><p>CTS-to-self protection is required.
This is set if the current BSS requires ERP protection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_USE_SHORT_PREAMBLE</span></code></dt><dd><p>Use short preamble.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_MCS</span></code></dt><dd><p>HT rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_GREEN_FIELD</span></code></dt><dd><p>Indicates whether this rate should be used in
Greenfield mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_40_MHZ_WIDTH</span></code></dt><dd><p>Indicates if the Channel Width should be 40 MHz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_DUP_DATA</span></code></dt><dd><p>The frame should be transmitted on both of the
adjacent 20 MHz channels, if the current channel type is
NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_SHORT_GI</span></code></dt><dd><p>Short Guard interval should be used for this rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_VHT_MCS</span></code></dt><dd><p>VHT MCS rate, in this case the idx field is split
into a higher 4 bits (Nss) and lower 4 bits (MCS number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_80_MHZ_WIDTH</span></code></dt><dd><p>Indicates 80 MHz transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_RC_160_MHZ_WIDTH</span></code></dt><dd><p>Indicates 160 MHz transmission
(80+80 isn’t supported yet)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags are set by the Rate control algorithm for each rate during tx,
in the <strong>flags</strong> member of <a class="reference internal" href="#c.ieee80211_tx_rate" title="ieee80211_tx_rate"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_rate</span></code></a>.</p>
<dl class="c struct">
<dt id="c.ieee80211_tx_rate">
<em class="property">struct </em><code class="sig-name descname">ieee80211_tx_rate</code><a class="headerlink" href="#c.ieee80211_tx_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>rate selection/status</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tx_rate {
  s8 idx;
  u16 count:5, flags:11;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">idx</span></code></dt><dd><p>rate index to attempt to send with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>number of tries in this rate before going to the next rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>rate control flags (<a class="reference internal" href="#c.mac80211_rate_control_flags" title="mac80211_rate_control_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mac80211_rate_control_flags</span></code></a>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A value of -1 for <strong>idx</strong> indicates an invalid rate and, if used
in an array of retry rates, that no more rates should be tried.</p>
<p>When used for transmit status reporting, the driver should
always report the rate along with the flags it used.</p>
<p><a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> contains an array of these structs
in the control information, and it will be filled by the rate
control algorithm according to what should be sent. For example,
if this array contains, in the format { &lt;idx&gt;, &lt;count&gt; } the
information:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{ 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
</pre></div>
</div>
<p>then this means that the frame should be transmitted
up to twice at rate 3, up to twice at rate 2, and up to four
times at rate 1 if it doesn’t get acknowledged. Say it gets
acknowledged by the peer after the fifth attempt, the status
information should then contain:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{ 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
</pre></div>
</div>
<p>since it was transmitted twice at rate 3, twice at rate 2
and once at rate 1 after which we received an acknowledgement.</p>
<dl class="c struct">
<dt id="c.ieee80211_tx_info">
<em class="property">struct </em><code class="sig-name descname">ieee80211_tx_info</code><a class="headerlink" href="#c.ieee80211_tx_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>skb transmit information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tx_info {
  u32 flags;
  u32 band:3,ack_frame_id:13,hw_queue:4, tx_time_est:10;
  union {
    struct {
      union {
        struct {
          struct ieee80211_tx_rate rates[ IEEE80211_TX_MAX_RATES];
          s8 rts_cts_rate_idx;
          u8 use_rts:1;
          u8 use_cts_prot:1;
          u8 short_preamble:1;
          u8 skip_table:1;
        };
        unsigned long jiffies;
      };
      struct ieee80211_vif *vif;
      struct ieee80211_key_conf *hw_key;
      u32 flags;
      codel_time_t enqueue_time;
    } control;
    struct {
      u64 cookie;
    } ack;
    struct {
      struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
      s32 ack_signal;
      u8 ampdu_ack_len;
      u8 ampdu_len;
      u8 antenna;
      u16 tx_time;
      bool is_valid_ack_signal;
      void *status_driver_data[19 / sizeof(void *)];
    } status;
    struct {
      struct ieee80211_tx_rate driver_rates[ IEEE80211_TX_MAX_RATES];
      u8 pad[4];
      void *rate_driver_data[ IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];
    };
    void *driver_data[ IEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>transmit info flags, defined above</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">band</span></code></dt><dd><p>the band to transmit on (use for checking for races)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack_frame_id</span></code></dt><dd><p>internal frame ID for TX status, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_queue</span></code></dt><dd><p>HW queue to put the frame on, skb_get_queue_mapping() gives the AC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_time_est</span></code></dt><dd><p>TX time estimate in units of 4us, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control</span></code></dt><dd><p>union part for control data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.rates</span></code></dt><dd><p>TX rates array to try</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.rts_cts_rate_idx</span></code></dt><dd><p>rate for RTS or CTS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.use_rts</span></code></dt><dd><p>use RTS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.use_cts_prot</span></code></dt><dd><p>use RTS/CTS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.short_preamble</span></code></dt><dd><p>use short preamble (CCK only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.skip_table</span></code></dt><dd><p>skip externally configured rate table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.jiffies</span></code></dt><dd><p>timestamp for expiry on powersave clients</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.vif</span></code></dt><dd><p>virtual interface (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.hw_key</span></code></dt><dd><p>key to encrypt with (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.flags</span></code></dt><dd><p>control flags, see <a class="reference internal" href="#c.mac80211_tx_control_flags" title="mac80211_tx_control_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mac80211_tx_control_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control.enqueue_time</span></code></dt><dd><p>enqueue time (for iTXQs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack</span></code></dt><dd><p>union part for pure ACK data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack.cookie</span></code></dt><dd><p>cookie for the ACK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>union part for status data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.rates</span></code></dt><dd><p>attempted rates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.ack_signal</span></code></dt><dd><p>ACK signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.ampdu_ack_len</span></code></dt><dd><p>AMPDU ack length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.ampdu_len</span></code></dt><dd><p>AMPDU length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.antenna</span></code></dt><dd><p>(legacy, kept only for iwlegacy)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.tx_time</span></code></dt><dd><p>airtime consumed for transmission; note this is only
used for WMM AC, not for airtime fairness</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.is_valid_ack_signal</span></code></dt><dd><p>ACK signal is valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status.status_driver_data</span></code></dt><dd><p>driver use area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_rates</span></code></dt><dd><p>alias to <strong>control.rates</strong> to reserve space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>padding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_driver_data</span></code></dt><dd><p>driver use area if driver needs <strong>control.rates</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>array of driver_data pointers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This structure is placed in skb-&gt;cb for three uses:</dt><dd><ol class="arabic simple">
<li><p>mac80211 TX control - mac80211 tells the driver what to do</p></li>
<li><p>driver internal use (if applicable)</p></li>
<li><p>TX status information - driver tells mac80211 what happened</p></li>
</ol>
</dd>
</dl>
<dl class="c struct">
<dt id="c.ieee80211_tx_status">
<em class="property">struct </em><code class="sig-name descname">ieee80211_tx_status</code><a class="headerlink" href="#c.ieee80211_tx_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>extended tx status info for rate control</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tx_status {
  struct ieee80211_sta *sta;
  struct ieee80211_tx_info *info;
  struct sk_buff *skb;
  struct rate_info *rate;
  struct list_head *free_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sta</span></code></dt><dd><p>Station that the packet was transmitted for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>Basic tx status information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb</span></code></dt><dd><p>Packet skb (can be NULL if not provided by the driver)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate</span></code></dt><dd><p>The TX rate that was used when sending the packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_list</span></code></dt><dd><p>list where processed skbs are stored to be free’d by the driver</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.ieee80211_tx_info_clear_status">
void <code class="sig-name descname">ieee80211_tx_info_clear_status</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info">ieee80211_tx_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_tx_info_clear_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear TX status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span> <span class="pre">*info</span></code></dt><dd><p>The <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> to be cleared.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the driver passes an skb back to mac80211, it must report
a number of things in TX status. This function clears everything
in the TX status but the rate control information (it does clear
the count since you need to fill that in anyway).</p>
<p><strong>NOTE</strong></p>
<dl class="simple">
<dt>You can only use this function if you do NOT use</dt><dd><p>info-&gt;driver_data! Use info-&gt;rate_driver_data
instead if you need only the less space that allows.</p>
</dd>
</dl>
<dl class="c enum">
<dt id="c.mac80211_rx_flags">
<em class="property">enum </em><code class="sig-name descname">mac80211_rx_flags</code><a class="headerlink" href="#c.mac80211_rx_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>receive flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MMIC_ERROR</span></code></dt><dd><p>Michael MIC error was reported on this frame.
Use together with <code class="docutils literal notranslate"><span class="pre">RX_FLAG_MMIC_STRIPPED</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_DECRYPTED</span></code></dt><dd><p>This frame was decrypted in hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MACTIME_PLCP_START</span></code></dt><dd><p>The timestamp passed in the RX status (<strong>mactime</strong>
field) is valid and contains the time the SYNC preamble was received.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MMIC_STRIPPED</span></code></dt><dd><p>the Michael MIC is stripped off this frame,
verification has been done by the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_IV_STRIPPED</span></code></dt><dd><p>The IV and ICV are stripped from this frame.
If this flag is set, the stack cannot do any replay detection
hence the driver or hardware will have to do that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_FAILED_FCS_CRC</span></code></dt><dd><p>Set this flag if the FCS check failed on
the frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_FAILED_PLCP_CRC</span></code></dt><dd><p>Set this flag if the PCLP check failed on
the frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MACTIME_START</span></code></dt><dd><p>The timestamp passed in the RX status (<strong>mactime</strong>
field) is valid and contains the time the first symbol of the MPDU
was received. This is useful in monitor mode and for proper IBSS
merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_NO_SIGNAL_VAL</span></code></dt><dd><p>The signal strength value is not present.
Valid only for data frames (mainly A-MPDU)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_DETAILS</span></code></dt><dd><p>A-MPDU details are known, in particular the reference
number (<strong>ampdu_reference</strong>) must be populated and be a distinct number for
each A-MPDU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_PN_VALIDATED</span></code></dt><dd><p>Currently only valid for CCMP/GCMP frames, this
flag indicates that the PN was verified for replay protection.
Note that this flag is also currently only supported when a frame
is also decrypted (ie. <strong>RX_FLAG_DECRYPTED</strong> must be set)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_DUP_VALIDATED</span></code></dt><dd><p>The driver should set this flag if it did
de-duplication by itself.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_LAST_KNOWN</span></code></dt><dd><p>last subframe is known, should be set on all
subframes of a single A-MPDU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_IS_LAST</span></code></dt><dd><p>this subframe is the last subframe of the A-MPDU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_DELIM_CRC_ERROR</span></code></dt><dd><p>A delimiter CRC error has been detected
on this subframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_DELIM_CRC_KNOWN</span></code></dt><dd><p>The delimiter CRC field is known (the CRC
is stored in the <strong>ampdu_delimiter_crc</strong> field)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MACTIME_END</span></code></dt><dd><p>The timestamp passed in the RX status (<strong>mactime</strong>
field) is valid and contains the time the last symbol of the MPDU
(including FCS) was received.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_ONLY_MONITOR</span></code></dt><dd><p>Report frame only to monitor interfaces without
processing it in any regular way.
This is useful if drivers offload some frames but still want to report
them for sniffing purposes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_SKIP_MONITOR</span></code></dt><dd><p>Process and report frame to all interfaces except
monitor interfaces.
This is useful if drivers offload some frames but still want to report
them for sniffing purposes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMSDU_MORE</span></code></dt><dd><p>Some drivers may prefer to report separate A-MSDU
subframes instead of a one huge frame for performance reasons.
All, but the last MSDU from an A-MSDU should have this flag set. E.g.
if an A-MSDU has 3 frames, the first 2 must have the flag set, while
the 3rd (last) one must not have this flag set. The flag is used to
deal with retransmission/duplication recovery properly since A-MSDU
subframes share the same sequence number. Reported subframes can be
either regular MSDU or singly A-MSDUs. Subframes must not be
interleaved with other frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_RADIOTAP_VENDOR_DATA</span></code></dt><dd><p>This frame contains vendor-specific
radiotap data in the skb-&gt;data (before the frame) as described by
the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vendor_radiotap</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_MIC_STRIPPED</span></code></dt><dd><p>The mic was stripped of this packet. Decryption was
done by the hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_ALLOW_SAME_PN</span></code></dt><dd><p>Allow the same PN as same packet before.
This is used for AMSDU subframes which can have the same PN as
the first subframe.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_ICV_STRIPPED</span></code></dt><dd><p>The ICV is stripped from this frame. CRC checking must
be done in the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_EOF_BIT</span></code></dt><dd><p>Value of the EOF bit in the A-MPDU delimiter for this
frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_AMPDU_EOF_BIT_KNOWN</span></code></dt><dd><p>The EOF value is known</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_RADIOTAP_HE</span></code></dt><dd><p>HE radiotap data is present
(<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_radiotap_he</span></code>, mac80211 will fill in</p>
<blockquote>
<div><ul class="simple">
<li><p>DATA3_DATA_MCS</p></li>
<li><p>DATA3_DATA_DCM</p></li>
<li><p>DATA3_CODING</p></li>
<li><p>DATA5_GI</p></li>
<li><p>DATA5_DATA_BW_RU_ALLOC</p></li>
<li><p>DATA6_NSTS</p></li>
<li><p>DATA3_STBC</p></li>
</ul>
</div></blockquote>
<p>from the RX info data, so leave those zeroed when building this data)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_RADIOTAP_HE_MU</span></code></dt><dd><p>HE MU radiotap data is present
(<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_radiotap_he_mu</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_RADIOTAP_LSIG</span></code></dt><dd><p>L-SIG radiotap data is present</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_NO_PSDU</span></code></dt><dd><p>use the frame only for radiotap reporting, with
the “0-length PSDU” field included there.  The value for it is
in <a class="reference internal" href="#c.ieee80211_rx_status" title="ieee80211_rx_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_rx_status</span></code></a>.  Note that if this value isn’t
known the frame shouldn’t be reported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_FLAG_8023</span></code></dt><dd><p>the frame has an 802.3 header (decap offload performed by
hardware or driver)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags are used with the <strong>flag</strong> member of <a class="reference internal" href="#c.ieee80211_rx_status" title="ieee80211_rx_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_rx_status</span></code></a>.</p>
<dl class="c enum">
<dt id="c.mac80211_rx_encoding_flags">
<em class="property">enum </em><code class="sig-name descname">mac80211_rx_encoding_flags</code><a class="headerlink" href="#c.mac80211_rx_encoding_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>MCS &amp; bandwidth flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_SHORTPRE</span></code></dt><dd><p>Short preamble was used for this frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_SHORT_GI</span></code></dt><dd><p>Short guard interval was used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_HT_GF</span></code></dt><dd><p>This frame was received in a HT-greenfield transmission,
if the driver fills this value it should add
<code class="docutils literal notranslate"><span class="pre">IEEE80211_RADIOTAP_MCS_HAVE_FMT</span></code>
to <strong>hw.radiotap_mcs_details</strong> to advertise that fact.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_STBC_MASK</span></code></dt><dd><p>STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_LDPC</span></code></dt><dd><p>LDPC was used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RX_ENC_FLAG_BF</span></code></dt><dd><p>packet was beamformed</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.ieee80211_rx_status">
<em class="property">struct </em><code class="sig-name descname">ieee80211_rx_status</code><a class="headerlink" href="#c.ieee80211_rx_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>receive status</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_rx_status {
  u64 mactime;
  u64 boottime_ns;
  u32 device_timestamp;
  u32 ampdu_reference;
  u32 flag;
  u16 freq: 13, freq_offset: 1;
  u8 enc_flags;
  u8 encoding:2, bw:3, he_ru:3;
  u8 he_gi:2, he_dcm:1;
  u8 rate_idx;
  u8 nss;
  u8 rx_flags;
  u8 band;
  u8 antenna;
  s8 signal;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  u8 ampdu_delimiter_crc;
  u8 zero_length_psdu_type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mactime</span></code></dt><dd><p>value in microseconds of the 64-bit Time Synchronization Function
(TSF) timer when the first data symbol (MPDU) arrived at the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boottime_ns</span></code></dt><dd><p>CLOCK_BOOTTIME timestamp the frame was received at, this is
needed only for beacons and probe responses that update the scan cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_timestamp</span></code></dt><dd><p>arbitrary timestamp for the device, mac80211 doesn’t use
it but can store it and pass it back to the driver for synchronisation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_reference</span></code></dt><dd><p>A-MPDU reference number, must be a different value for
each A-MPDU but the same for each subframe within one A-MPDU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flag</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">RX_FLAG_</span></code>*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freq</span></code></dt><dd><p>frequency the radio was tuned to when receiving this frame, in MHz
This field must be set for management frames, but isn’t strictly needed
for data (other) frames - for those it only affects radiotap reporting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freq_offset</span></code></dt><dd><p><strong>freq</strong> has a positive offset of 500Khz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enc_flags</span></code></dt><dd><p>uses bits from <a class="reference internal" href="#c.mac80211_rx_encoding_flags" title="mac80211_rx_encoding_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mac80211_rx_encoding_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoding</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mac80211_rx_encoding</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bw</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rate_info_bw</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_ru</span></code></dt><dd><p>HE RU, from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_he_ru_alloc</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_gi</span></code></dt><dd><p>HE GI, from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_he_gi</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_dcm</span></code></dt><dd><p>HE DCM value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_idx</span></code></dt><dd><p>index of data rate into band’s supported rates or MCS index if
HT or VHT is used (<code class="docutils literal notranslate"><span class="pre">RX_FLAG_HT</span></code>/<code class="docutils literal notranslate"><span class="pre">RX_FLAG_VHT</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nss</span></code></dt><dd><p>number of streams (VHT and HE only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_flags</span></code></dt><dd><p>internal RX flags for mac80211</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">band</span></code></dt><dd><p>the active band when this frame was received</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">antenna</span></code></dt><dd><p>antenna used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>signal strength when receiving this frame, either in dBm, in dB or
unspecified depending on the hardware capabilities flags
<strong>IEEE80211_HW_SIGNAL_*</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chains</span></code></dt><dd><p>bitmask of receive chains for which separate signal strength
values were filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_signal</span></code></dt><dd><p>per-chain signal strength, in dBm (unlike <strong>signal</strong>, doesn’t
support dB or unspecified units)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_delimiter_crc</span></code></dt><dd><p>A-MPDU delimiter CRC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zero_length_psdu_type</span></code></dt><dd><p>radiotap type of the 0-length PSDU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The low-level driver should provide this information (the subset
supported by hardware) to the 802.11 code with each received
frame, in the skb’s control buffer (cb).</p>
<dl class="c function">
<dt id="c.ieee80211_rx">
void <code class="sig-name descname">ieee80211_rx</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_rx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>receive frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware this frame came in on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to receive, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to hand received frames to mac80211. The receive
buffer in <strong>skb</strong> must start with an IEEE 802.11 header. In case of a
paged <strong>skb</strong> is used, the driver is recommended to put the ieee80211
header of the frame on the linear part of the <strong>skb</strong> to avoid memory
allocation and/or memcpy by the stack.</p>
<p>This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls to
this function, <a class="reference internal" href="#c.ieee80211_rx_ni" title="ieee80211_rx_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_ni()</span></code></a> and <a class="reference internal" href="#c.ieee80211_rx_irqsafe" title="ieee80211_rx_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_irqsafe()</span></code></a> may not be
mixed for a single hardware. Must not run concurrently with
<a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> or <a class="reference internal" href="#c.ieee80211_tx_status_ni" title="ieee80211_tx_status_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_ni()</span></code></a>.</p>
<p>In process context use instead <a class="reference internal" href="#c.ieee80211_rx_ni" title="ieee80211_rx_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_ni()</span></code></a>.</p>
<dl class="c function">
<dt id="c.ieee80211_rx_irqsafe">
void <code class="sig-name descname">ieee80211_rx_irqsafe</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_rx_irqsafe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>receive frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware this frame came in on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to receive, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_rx" title="ieee80211_rx"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx()</span></code></a> but can be called in IRQ context
(internally defers to a tasklet.)</p>
<p>Calls to this function, <a class="reference internal" href="#c.ieee80211_rx" title="ieee80211_rx"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx()</span></code></a> or <a class="reference internal" href="#c.ieee80211_rx_ni" title="ieee80211_rx_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_ni()</span></code></a> may not
be mixed for a single hardware.Must not run concurrently with
<a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> or <a class="reference internal" href="#c.ieee80211_tx_status_ni" title="ieee80211_tx_status_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_ni()</span></code></a>.</p>
<dl class="c function">
<dt id="c.ieee80211_rx_ni">
void <code class="sig-name descname">ieee80211_rx_ni</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_rx_ni" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>receive frame (in process context)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware this frame came in on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to receive, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_rx" title="ieee80211_rx"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx()</span></code></a> but can be called in process context
(internally disables bottom halves).</p>
<p>Calls to this function, <a class="reference internal" href="#c.ieee80211_rx" title="ieee80211_rx"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx()</span></code></a> and <a class="reference internal" href="#c.ieee80211_rx_irqsafe" title="ieee80211_rx_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_irqsafe()</span></code></a> may
not be mixed for a single hardware. Must not run concurrently with
<a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> or <a class="reference internal" href="#c.ieee80211_tx_status_ni" title="ieee80211_tx_status_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_ni()</span></code></a>.</p>
<dl class="c function">
<dt>
void <code class="sig-name descname">ieee80211_tx_status</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><br /></dt>
<dd><p>transmit status callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware the frame was transmitted by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the frame that was transmitted, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function for all transmitted frames after they have been
transmitted. It is permissible to not call this function for
multicast frames but this can affect statistics.</p>
<p>This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls
to this function, <a class="reference internal" href="#c.ieee80211_tx_status_ni" title="ieee80211_tx_status_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_ni()</span></code></a> and <a class="reference internal" href="#c.ieee80211_tx_status_irqsafe" title="ieee80211_tx_status_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_irqsafe()</span></code></a>
may not be mixed for a single hardware. Must not run concurrently with
<a class="reference internal" href="#c.ieee80211_rx" title="ieee80211_rx"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx()</span></code></a> or <a class="reference internal" href="#c.ieee80211_rx_ni" title="ieee80211_rx_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_rx_ni()</span></code></a>.</p>
<dl class="c function">
<dt id="c.ieee80211_tx_status_ni">
void <code class="sig-name descname">ieee80211_tx_status_ni</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_tx_status_ni" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>transmit status callback (in process context)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware the frame was transmitted by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the frame that was transmitted, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> but can be called in process context.</p>
<p>Calls to this function, <a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> and
<a class="reference internal" href="#c.ieee80211_tx_status_irqsafe" title="ieee80211_tx_status_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_irqsafe()</span></code></a> may not be mixed
for a single hardware.</p>
<dl class="c function">
<dt id="c.ieee80211_tx_status_irqsafe">
void <code class="sig-name descname">ieee80211_tx_status_irqsafe</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_tx_status_irqsafe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>IRQ-safe transmit status callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware the frame was transmitted by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the frame that was transmitted, owned by mac80211 after this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> but can be called in IRQ context
(internally defers to a tasklet.)</p>
<p>Calls to this function, <a class="reference internal" href="#c.ieee80211_tx_status" title="ieee80211_tx_status"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status()</span></code></a> and
<a class="reference internal" href="#c.ieee80211_tx_status_ni" title="ieee80211_tx_status_ni"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_tx_status_ni()</span></code></a> may not be mixed for a single hardware.</p>
<dl class="c function">
<dt id="c.ieee80211_rts_get">
void <code class="sig-name descname">ieee80211_rts_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *<em>vif</em>, <em class="property">const</em> void *<em>frame</em>, size_t <em>frame_len</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info">ieee80211_tx_info</a> *<em>frame_txctl</em>, <em class="property">struct</em> ieee80211_rts *<em>rts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_rts_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>RTS frame generation function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*frame</span></code></dt><dd><p>pointer to the frame that is going to be protected by the RTS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">frame_len</span></code></dt><dd><p>the frame length (in octets).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span> <span class="pre">*frame_txctl</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> of the frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_rts</span> <span class="pre">*rts</span></code></dt><dd><p>The buffer where to store the RTS frame.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the RTS frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next RTS frame from the 802.11 code. The low-level is responsible
for calling this function before and RTS frame is needed.</p>
<dl class="c function">
<dt id="c.ieee80211_rts_duration">
__le16 <code class="sig-name descname">ieee80211_rts_duration</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *<em>vif</em>, size_t <em>frame_len</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info">ieee80211_tx_info</a> *<em>frame_txctl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_rts_duration" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the duration field for an RTS frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">frame_len</span></code></dt><dd><p>the length of the frame that is going to be protected by the RTS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span> <span class="pre">*frame_txctl</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> of the frame.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the RTS is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.</p>
<p><strong>Return</strong></p>
<p>The duration.</p>
<dl class="c function">
<dt id="c.ieee80211_ctstoself_get">
void <code class="sig-name descname">ieee80211_ctstoself_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *<em>vif</em>, <em class="property">const</em> void *<em>frame</em>, size_t <em>frame_len</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info">ieee80211_tx_info</a> *<em>frame_txctl</em>, <em class="property">struct</em> ieee80211_cts *<em>cts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_ctstoself_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CTS-to-self frame generation function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*frame</span></code></dt><dd><p>pointer to the frame that is going to be protected by the CTS-to-self.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">frame_len</span></code></dt><dd><p>the frame length (in octets).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span> <span class="pre">*frame_txctl</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> of the frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_cts</span> <span class="pre">*cts</span></code></dt><dd><p>The buffer where to store the CTS-to-self frame.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the CTS-to-self frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next CTS-to-self frame from the 802.11 code. The low-level is responsible
for calling this function before and CTS-to-self frame is needed.</p>
<dl class="c function">
<dt id="c.ieee80211_ctstoself_duration">
__le16 <code class="sig-name descname">ieee80211_ctstoself_duration</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *<em>vif</em>, size_t <em>frame_len</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info">ieee80211_tx_info</a> *<em>frame_txctl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_ctstoself_duration" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the duration field for a CTS-to-self frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">frame_len</span></code></dt><dd><p>the length of the frame that is going to be protected by the CTS-to-self.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span> <span class="pre">*frame_txctl</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_tx_info" title="ieee80211_tx_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_tx_info</span></code></a> of the frame.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the CTS-to-self is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.</p>
<p><strong>Return</strong></p>
<p>The duration.</p>
<dl class="c function">
<dt id="c.ieee80211_generic_frame_duration">
__le16 <code class="sig-name descname">ieee80211_generic_frame_duration</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *<em>vif</em>, <em class="property">enum</em> nl80211_band <em>band</em>, size_t <em>frame_len</em>, <em class="property">struct</em> <a class="reference internal" href="cfg80211.html#c.ieee80211_rate" title="ieee80211_rate">ieee80211_rate</a> *<em>rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_generic_frame_duration" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the duration field for a frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_band</span> <span class="pre">band</span></code></dt><dd><p>the band to calculate the frame duration on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">frame_len</span></code></dt><dd><p>the length of the frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_rate</span> <span class="pre">*rate</span></code></dt><dd><p>the rate at which the frame is going to be transmitted.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the duration field of some generic frame, given its
length and transmission rate (in 100kbps).</p>
<p><strong>Return</strong></p>
<p>The duration.</p>
<dl class="c function">
<dt id="c.ieee80211_wake_queue">
void <code class="sig-name descname">ieee80211_wake_queue</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, int <em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_wake_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake specific queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">queue</span></code></dt><dd><p>queue number (counted from zero).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this function instead of netif_wake_queue.</p>
<dl class="c function">
<dt id="c.ieee80211_stop_queue">
void <code class="sig-name descname">ieee80211_stop_queue</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, int <em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_stop_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stop specific queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">queue</span></code></dt><dd><p>queue number (counted from zero).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this function instead of netif_stop_queue.</p>
<dl class="c function">
<dt id="c.ieee80211_queue_stopped">
int <code class="sig-name descname">ieee80211_queue_stopped</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, int <em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_queue_stopped" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test status of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">queue</span></code></dt><dd><p>queue number (counted from zero).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this function instead of netif_stop_queue.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the queue is stopped. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.ieee80211_stop_queues">
void <code class="sig-name descname">ieee80211_stop_queues</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_stop_queues" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stop all queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this function instead of netif_stop_queue.</p>
<dl class="c function">
<dt id="c.ieee80211_wake_queues">
void <code class="sig-name descname">ieee80211_wake_queues</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_wake_queues" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake all queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this function instead of netif_wake_queue.</p>
</div>
</div>
<div class="section" id="frame-filtering">
<h2>Frame filtering<a class="headerlink" href="#frame-filtering" title="Permalink to this headline">¶</a></h2>
<p>mac80211 requires to see many management frames for proper
operation, and users may want to see many more frames when
in monitor mode. However, for best CPU usage and power consumption,
having as few frames as possible percolate through the stack is
desirable. Hence, the hardware should filter as much as possible.</p>
<p>To achieve this, mac80211 uses filter flags (see below) to tell
the driver’s configure_filter() function which frames should be
passed to mac80211 and which should be filtered out.</p>
<p>Before configure_filter() is invoked, the prepare_multicast()
callback is invoked with the parameters <strong>mc_count</strong> and <strong>mc_list</strong>
for the combined multicast address list of all virtual interfaces.
It’s use is optional, and it returns a u64 that is passed to
configure_filter(). Additionally, configure_filter() has the
arguments <strong>changed_flags</strong> telling which flags were changed and
<strong>total_flags</strong> with the new flag states.</p>
<p>If your device has no multicast address filters your driver will
need to check both the <code class="docutils literal notranslate"><span class="pre">FIF_ALLMULTI</span></code> flag and the <strong>mc_count</strong>
parameter to see whether multicast frames should be accepted
or dropped.</p>
<p>All unsupported flags in <strong>total_flags</strong> must be cleared.
Hardware does not support a flag if it is incapable of _passing_
the frame to the stack. Otherwise the driver must ignore
the flag, but not clear it.
You must _only_ clear the flag (announce no support for the
flag to mac80211) if you are not able to pass the packet type
to the stack (so the hardware always filters it).
So for example, you should clear <strong>FIF_CONTROL</strong>, if your hardware
always filters control frames. If your hardware always passes
control frames to the kernel and is incapable of filtering them,
you do _not_ clear the <strong>FIF_CONTROL</strong> flag.
This rule applies to all other FIF flags as well.</p>
<dl class="c enum">
<dt id="c.ieee80211_filter_flags">
<em class="property">enum </em><code class="sig-name descname">ieee80211_filter_flags</code><a class="headerlink" href="#c.ieee80211_filter_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hardware filter flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FIF_ALLMULTI</span></code></dt><dd><p>pass all multicast frames, this is used if requested
by the user or if the hardware is not capable of filtering by
multicast address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_FCSFAIL</span></code></dt><dd><p>pass frames with failed FCS (but you need to set the
<code class="docutils literal notranslate"><span class="pre">RX_FLAG_FAILED_FCS_CRC</span></code> for them)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_PLCPFAIL</span></code></dt><dd><p>pass frames with failed PLCP CRC (but you need to set
the <code class="docutils literal notranslate"><span class="pre">RX_FLAG_FAILED_PLCP_CRC</span></code> for them</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_BCN_PRBRESP_PROMISC</span></code></dt><dd><p>This flag is set during scanning to indicate
to the hardware that it should not filter beacons or probe responses
by BSSID. Filtering them can greatly reduce the amount of processing
mac80211 needs to do and the amount of CPU wakeups, so you should
honour this flag if possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_CONTROL</span></code></dt><dd><p>pass control frames (except for PS Poll) addressed to this
station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_OTHER_BSS</span></code></dt><dd><p>pass frames destined to other BSSes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_PSPOLL</span></code></dt><dd><p>pass PS Poll frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_PROBE_REQ</span></code></dt><dd><p>pass probe request frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIF_MCAST_ACTION</span></code></dt><dd><p>pass multicast Action frames</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These flags determine what the filter in hardware should be
programmed to let through and what should not be passed to the
stack. It is always safe to pass more frames than requested,
but this has negative impact on power consumption.</p>
</div>
<div class="section" id="the-mac80211-workqueue">
<h2>The mac80211 workqueue<a class="headerlink" href="#the-mac80211-workqueue" title="Permalink to this headline">¶</a></h2>
<p>mac80211 provides its own workqueue for drivers and internal mac80211 use.
The workqueue is a single threaded workqueue and can only be accessed by
helpers for sanity checking. Drivers must ensure all work added onto the
mac80211 workqueue should be cancelled on the driver <a class="reference internal" href="../../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a> callback.</p>
<p>mac80211 will flushed the workqueue upon interface removal and during
suspend.</p>
<p>All work performed on the mac80211 workqueue must not acquire the RTNL lock.</p>
<dl class="c function">
<dt id="c.ieee80211_queue_work">
void <code class="sig-name descname">ieee80211_queue_work</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> work_struct *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_queue_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add work onto the mac80211 workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware struct for the interface we are adding work for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the work we want to add onto the mac80211 workqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers and mac80211 use this to add work onto the mac80211 workqueue.
This helper ensures drivers are not queueing work when they should not be.</p>
<dl class="c function">
<dt id="c.ieee80211_queue_delayed_work">
void <code class="sig-name descname">ieee80211_queue_delayed_work</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a> *<em>hw</em>, <em class="property">struct</em> delayed_work *<em>dwork</em>, unsigned long <em>delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_queue_delayed_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add work onto the mac80211 workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware struct for the interface we are adding work for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayable work to queue onto the mac80211 workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queueing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers and mac80211 use this to queue delayed work onto the mac80211
workqueue.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="mac80211-advanced.html" class="btn btn-neutral float-right" title="mac80211 subsystem (advanced)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="cfg80211.html" class="btn btn-neutral float-left" title="cfg80211 subsystem" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>